[
  {
    "objectID": "cheatsheet.html",
    "href": "cheatsheet.html",
    "title": "Programação",
    "section": "",
    "text": "Variáveis\nint a; // declarar variável inteira chamada a\nfloat b=3.14; // declarar variável real chamada b e inicializar com 3.14\nchar c1,c2='a'; // declarar variável char c1 e c2, e inicializar c2 com 'a'\n\n\nOperadores\n\nOperadores aritméticos, relacionais, lógicos e de atribuição\n\n\nOperador\nDescrição\nExemplo\nOperador\nDescrição\nExemplo\n\n\n\n\n+\nSoma\na + b\n==\nIgual\na == b\n\n\n-\nSubtração\na - b\n!=\nDiferente\na != b\n\n\n*\nMultiplicação\na * b\n&gt;\nMaior\na &gt; b\n\n\n/\nDivisão\na / b\n&lt;\nMenor\na &lt; b\n\n\n%\nResto da divisão\na % b\n&gt;=\nMaior ou igual\na &gt;= b\n\n\n++\nIncremento\na++\n&&\nE\na && b\n\n\n–\nDecremento\na–\n||\nOU\na || b\n\n\n=\nAtribuição\na = b\n!\nNÃO\n!a\n\n\n+=\nAtribuição com soma\na += b\n\n\n\n\n\n-=\nAtribuição com subtração\na -= b\n\n\n\n\n\n*=\nAtribuição com multiplicação\na *= b\n\n\n\n\n\n/=\nAtribuição com divisão\na /= b\n\n\n\n\n\n\n\n\nI/O Formatado\nscanf(\"%descritor\", &variavel); // lê um dado do tipo tipo_dado e armazena em variavel\nprintf(\"%descritor\", variavel); // escreve um dado do tipo tipo_dado e armazena em variavel\n\nDescritores de tipos de dados\n\n\nDescritor\nTipo de dado\n\n\n\n\n%d\nint\n\n\n%f\nfloat\n\n\n%c\nchar\n\n\n%s\nstring\n\n\n%lf\ndouble\n\n\n%u\nunsigned int\n\n\n%ld\nlong int\n\n\n%lu\nunsigned long int\n\n\n\n\n\nI/O Não Formatado\ngetchar(); // lê um char\nfgets(variavel, tamanho, stdin); // lê uma string\n\nputchar(variavel); // escreve um char\nputs(variavel); // escreve uma string\n\n\nEstruturas de controlo\n\nif\nif (condição) {\n    // bloco de código\n} else if (condição) {\n    // bloco de código\n} else {\n    // bloco de código\n}\nswitch\nswitch (variavel) {\n    case valor1:\n        // bloco de código\n        break;\n    case valor2:\n        // bloco de código\n        break;\n    default:\n        // bloco de código\n        break;\n}\nCiclos\nwhile (condição) { // enquanto condição for verdadeira\n    // bloco de código\n}\n\ndo { // executa o bloco de código pelo menos uma vez\n    // bloco de código\n} while (condição); // enquanto condição for verdadeira\n\nfor (inicialização; condição; incremento) {\n    // bloco de código\n}\n// inicialização é executada uma vez\n// condição é testada antes de cada iteração\n// pós-instrução é executada no final de cada iteração\n\n\n\nFunções\n\nDeclaração de função\ntipo_retorno nome_função (tipo_parametro1 nome_parametro1, tipo_parametro2 nome_parametro2) {\n    // bloco de código\n}\nChamada de função\nint a;\na = funcao(parametro1, parametro2); // se funcao devolvesse um int\n\n\n\nVetores\n\nDeclaração de vetor\nint vetor[10]; // declara vetor de inteiros com 10 posições\nAcesso a posição do vetor\nvetor[0] = 1; // acessa a primeira posição do vetor e atribui 1\nVetores e funções\nint vetor[10];\nfuncao(vetor); // passa o vetor como parâmetro\nvoid funcao(int vetor[]) { // recebe o vetor como parâmetro\n    // função não sabe o tamanho do vetor\n    // alterações ao vetor são persistentes\n}\n\n\n\nVetores multidimensionais\nint matriz[10][10]; // declara matriz de inteiros com 10 linhas e 10 colunas\nmatriz[0][0] = 1; // acessa a primeira linha e primeira coluna da matriz e atribui 1\nint b = matriz[0][0]; // acessa a primeira linha e primeira coluna da matriz e atribui a b\nint matriz[10][10][10]; //vetor tridimensional\nfuncao(matriz); // passa a matriz como parâmetro\nvoid funcao(int matriz[][10][10]) { // recebe a matriz como parâmetro\n    // obrigatório indicar o tamanho de todas as dimensões menos a primeira\n    // alterações à matriz são persistentes\n}\n\n// VLAs (Variable Length Arrays)\nvoid funcao(int x, int y, int z, int matriz[x][y][z]) {\n    // alterações à matriz são persistentes\n}\n\n\nStrings\n\nDeclaração de string\nchar string[10]; // declara string de 10 caracteres\n\nchar string[10] = \"ola\"; // declara e inicializa string\n\nchar string[10] = {'o', 'l', 'a', '\\0'}; // declara e inicializa string\nstring.h\n\n\nFunções úteis da string.h\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nstrlen(string)\nretorna o tamanho da string\n\n\nstrcpy(string1, string2)\ncopia string2 para string1\n\n\nstrcat(string1, string2)\nconcatena string2 a string1\n\n\nstrcmp(string1, string2)\ncompara string1 com string2, devolve 0 se forem iguais, &lt; 0 se string1 &lt; string2 e &gt; 0 se string1 &gt; string2\n\n\n\n\n\nApontadores\nint *p; // declara ponteiro para inteiro\n\nint a = 10;\np = &a; // ponteiro recebe o endereço de memória da variável a\nint a = 10;\nint *p;\np = &a;\nprintf(\"%d\", *p); // imprime o valor apontado por ponteiro\n\n\nAlocação dinâmica de memória\nint *p;\np = (int *) malloc(1 * sizeof(int)); // aloca memória para um inteiro\n\nfree(ponteiro); // libera a memória alocada para ponteiro\n\n\nEstruturas\n\nDeclaração de estrutura\nstruct nome_estrutura {\n    tipo1 nome1;\n    tipo2 nome2;\n};\nAcesso a campo da estrutura\n\nstruct nome_estrutura variavel;\nvariavel.nome1 = 1; // acessa o campo nome1 da variável variavel e atribui 1\nEstruturas e apontadores\nstruct nome_estrutura *ponteiro;\nponteiro = &variavel; // ponteiro recebe o endereço de memória da variável variavel\nponteiro-&gt;nome1 = 1; // acessa o campo nome1 da variável apontada por ponteiro e atribui 1\ntypedef\ntypedef struct nome_estrutura {\n    tipo1 nome1;\n    tipo2 nome2;\n} NomeEstrutura; // NomeEstrutura passa a ser um tipo\n\nNomeEstrutura variavel; // declara variável do tipo NomeEstrutura\n\nvoid funcao(NomeEstrutura x) {\n    // bloco de código\n}\n\nNomeEstrutura funcao2() {\n    temp = NomeEstrutura;\n    return temp;\n}\n\n\n\nFicheiros\n\nAbertura e fecho de ficheiro\nFILE *ficheiro;\nficheiro = fopen(\"nome_ficheiro\", \"modo_abertura\");\n// abre o ficheiro nome_ficheiro no modo modo_abertura\n// se devolver NULL, não foi possível abrir o ficheiro\n\nfclose(ficheiro); // fecha o ficheiro\nfcloseall(); // fecha todos os ficheiros abertos\nModos de abertura de ficheiro\n\nPara ficheiros binários, acrescentar b ao modo de abertura, e.g. “rb”, “wb”, “ab”, “rb+”, “wb+”, “ab+”.\n\n\n\nModos de abertura de ficheiro\n\n\nModo\nLeitura\nEscrita\nCriação\nPosicionamento\n\n\n\n\nr\nSim\nNão\nNão\nInício\n\n\nw\nNão\nSim\nSim\nInício\n\n\na\nNão\nSim\nSim\nFim\n\n\nr+\nSim\nSim\nNão\nInício\n\n\nw+\nSim\nSim\nSim\nInício\n\n\na+\nSim\nSim\nSim\nFim\n\n\n\n\nLeitura e escrita formatada ```c int a = 10; float b = 3.14; char c = ‘a’; // escreve no ficheiro os valores de a, b e c fprintf(ficheiro, “%d %f %c”, a, b, c); // lê do ficheiro os valores de a, b e c // devolve EOF se apanhar o fim do ficheiro fscanf(ficheiro, “%d %f %c”, &a, &b, &c);\nchar linha[100]; // lê uma linha do ficheiro (ou um máximo de 100 char) e guarda em linha // devolve NULL se apanhar o fim do ficheiro fgets(linha, 100, ficheiro);\nfgetc(ficheiro); // lê um char do ficheiro fputc(‘a’, ficheiro); // escreve um char no ficheiro fputs(“ola”, ficheiro); // escreve uma string no ficheiro ```\nLeitura e escrita ficheiros binários\nint a = 10;\nint n_lidos, n_escritos;\nFILE *ficheiro = fopen(\"nome_ficheiro\", \"wb\");\nn_escritos=fwrite(&a, sizeof(int), 1, ficheiro); // escreve no ficheiro o valor de a\nfclose(ficheiro);\n\nficheiro = fopen(\"nome_ficheiro\", \"rb\");\nn_lidos=fread(&a, sizeof(int), 1, ficheiro); // lê do ficheiro o valor de a\nfclose(ficheiro);\nPosicionamento no ficheiro\n// posiciona o cursor no ficheiro na posição 10\nfseek(ficheiro, 10, SEEK_SET);\n// posiciona o cursor no ficheiro 10 posições à frente da posição atual\nfseek(ficheiro, 10, SEEK_CUR);\n// posiciona o cursor no ficheiro 10 posições antes do fim do ficheiro\nfseek(ficheiro, -10, SEEK_END);\nftell(ficheiro); // devolve a posição atual do cursor no ficheiro\nrewind(ficheiro); // posiciona o cursor no início do ficheiro"
  },
  {
    "objectID": "exercicios.html",
    "href": "exercicios.html",
    "title": "Programação",
    "section": "",
    "text": "Os exercícios denominados “King …” são retirados do livro\n“C Programming: A Modern Approach, 2nd Edition” do K. N. King"
  },
  {
    "objectID": "exercicios.html#exercícios-io-formatado-king",
    "href": "exercicios.html#exercícios-io-formatado-king",
    "title": "Programação",
    "section": "Exercícios I/O Formatado King",
    "text": "Exercícios I/O Formatado King\n–\n\nKing 3.1. mudar formato de data\nEscreve um programa que aceita uma data do utilizador no formato “dd/mm/aaaa” e escreve na consola a mesma data no formato “aaaa-mm-dd”.\nInsira data: 01/02/2023\nEscreveu:    2023/02/01\n–\n\n\nKing 3.2. formatar input produtos\nEscreve um programa que formata os dados de um produto inseridos pelo utilizador.\nInsira o ID do produto: 583\nInsira o preço: 13.5\nInsira a data de aquisição (dd/mm/aaaa): 24/10/2010\n\nItem        Preço       Data da\n            Unitário    Compra\n583         €    13.5   2010/10/24\nNota: o ID do item e a data deve estar alinhados à esquerda; o preço unitário deve estar alinhado à direita. Dica: usa “ para alinhas as colunas.\n–\n\n\nKing 3.3. TODO\n–\n\n\nKing 3.4. TODO\n–\n\n\nKing 3.5. TODO\n–\n\n\nKing 3.6. frações\nEscreve um programa que recebe 2 frações do utilizador e escreve a sua soma. O programa recebe as duas frações de uma só vez, separadas por +.\nInsira as fracoes: 5/6+3/4\nSoma: 38/24"
  },
  {
    "objectID": "exercicios.html#king",
    "href": "exercicios.html#king",
    "title": "Programação",
    "section": "King",
    "text": "King\n–\n\nKing 4.1. inverter 2 digitos\nEscreve um programa que pede ao utilizar um número inteiro de 2 digitos e devolve esse número com os digitos invertidos. Exemplo de execução:\nInsira número inteiro: 42\nInvertido:             24\nOs 2 números devem estar alinhados.\nDica: %10 devolve o último digito de um número e /10 remove o último digito.\n–\n\n\nKing 4.2 inverter 3 digitos\nExtende o programa anterior (King 4.1.) para números de 3 digitos.\n–\n\n\nKing 4.3 inverter 3 digitos, variante\nReimplementa o programa do King 4.2 sem usar aritmética."
  },
  {
    "objectID": "exercicios.html#king-1",
    "href": "exercicios.html#king-1",
    "title": "Programação",
    "section": "King",
    "text": "King\n\nKing 5.1 quantos digitos\nEscreve um programa que recebe um número inteiro e indica quantos digitos esse número tem.\nAssume que o número nunca tem mais de 4 digitos.\nIntroduza numero inteiro (maximo 4 digitos): 42\n# digitos:                                   2\nAjuda: usa if para fazer essa verificação, e.g. se o número estiver entre 10 e 99, então tem 2 digitos.\n\n\nKing 5.2 conversão AM/PM\nEscreve um programa que recebe uma hora no formato de 0-24h e converte para o formato 0-12h.\nIntroduza hora no formato 24h: 23:32\nHora no formato 12h:           11:32 PM\n\nIntroduza hora no formato 24h: 10:32\nHora no formato 12h:           10:32 AM\n\n\n\nKing 5.3. TODO\n\n\nKing 5.4 escala Beaufort\nA escala de Beaufort indica uma descrição do vento com base na sua velocidade. Uma versão simplificada é a seguinte:\n\n\n\nSpeed (knots)\nDescription\n\n\n\n\n&lt;1\nCalm\n\n\n1-3\nLight air\n\n\n4-27\nBreeze\n\n\n28-47\nGale\n\n\n48-63\nStorm\n\n\n&gt;63\nHurricane\n\n\n\nEscreve um programa que recebe a velocidade do vento e indica a descrição correspondente.\n\n\nKing 5.5 escalões IRS\nO imposto cobrado sobre o rendimento é feito de forma progressiva por escalões (exemplo no slide seguinte). Versão simplificada dos escalões de 2023:\n\nEscreve um programa que recebe o rendimento anual bruto e indica o imposto total sobre o rendimento e o rendimento líquido final.\nImposto progressivo significa que o mesmo rendimento vai ser tributado em escalões diferentes, e.g.\nRendimento: 20000€\nTributaçao no escalão 1: 7116 * 14,5%\nTributaçao no escalão 2: (15216 - 7116) * 23%\nTributaçao no escalão 3: (20000 - 15216) * 28,5%\nTributaçao no escalão 4 e 5 não existe porque o\nrendimento não é alto o suficiente.\n\n\nKing 5.6 TODO\n\n\nKing 5.7 min e max de 4 números\nEscreve um programa que recebe 4 números inteiros e indica o número mais alto e o mais pequeno.\nEnter four integers: 21 43 10 35\nLargest: 43\nSmallest : 10\nUsa o mínimo de if possível.\nAjuda: 4 if são suficientes.\n\n\nKing 5.8 voo mais próximo TODO\n\n\nKing 5.9 data menor\nEscreve um programa que pede 2 datas ao utilizador e indica qual é a data que vem antes no calendário.\nData 1: 3/6/2007\nData 2: 3/6/2005\n3/6/2005 vem antes de 3/6/2007\n\n\nKing 5.10 nota para letra\nEscreve um programa que converte uma nota entre 0 e 100 para uma letra, segundo a seguinte correspondência: A = 90-100, B = 80-89, C = 70-79, D = 60-69, F = 0-59.\nA nota é lida do utilizador. Usa uma instrução switch para implementar o programa. O programa indica uma mensagem de erro se a nota for inferior a 0 ou superior a 100.\nNota: 84\nLetra: B\n\nNota: -1\nErro, nota deve estar entre 0 e 100.\nAjuda: usa o primeiro digito da nota para fazer a correspondência no switch.\n\n\nKing 5.11 número por extenso\nEscreve um programa que recebe um inteiro de 2 digitos e escreve o número por extenso. Implementa o programa sem if.\nNota: 42\nLetra: quarenta e dois"
  },
  {
    "objectID": "exercicios.html#exercícios-seleção-afa",
    "href": "exercicios.html#exercícios-seleção-afa",
    "title": "Programação",
    "section": "Exercícios Seleção AFA",
    "text": "Exercícios Seleção AFA\n\nAFA 5.1. Converte gramas para outras unidades\nEscreve um programa que converte entre unidades de massa. O programa primeiro pede o valor da massa em gramas. Depois mostra um menu com as opções de conversão. O utilizador recebe a unidade de destino e no final o programa mostra a massa convertida.\nIntroduza massa em gramas: 500\nQual e a unidade de conversao:\n1 - oz\n2 - lb\n3 - kg\nEscolha: 3\n500 g = 0.5000 kg\n\n\nAFA 5.2 Converter unidades de massa\nAltera o programa AFA 5.1 para se possa converter entre quaisquer 2 unidades. Para conseguir isto, o programa pede o valor da massa, depois pede a unidade desse valor e finalmente a unidade da conversão.\nIntroduza massa em gramas: 500\nQual e a unidade desta masa:\n1 - oz\n2 - lb\n3 - kg\n4 - g\nEscolha: 4\n\nQual e a unidade de conversao:\n1 - oz\n2 - lb\n3 - kg\nEscolha: 3\n\n500 g = 0.5000 kg"
  },
  {
    "objectID": "exercicios.html#ciclos-king",
    "href": "exercicios.html#ciclos-king",
    "title": "Programação",
    "section": "Ciclos King",
    "text": "Ciclos King\n\nKing 6.1. Maior número de série recebida\nEscreve um programa que encontra o maior número numa série de números introduzidos pelo utilizador. O programa pede os números um a um, até encontrar um número seguido da letra f.\nNúmero: 60\nNúmero: 38.3\nNúmero: 4.89\nNúmero: 100.62\nNúmero: 75.2295f\n\nNúmero maior: 100.62\n\n\nKing 6.2. Máximo Divisor Comum\nEscreve um programa para calcular o máximo divisor comum (MCD) entre 2 inteiros. O programa pede 2 inteiros ao utilizador e indica o MCD.\nNumeros: 12 28\nMCD: 4\nA estratégia mais simples (embora menos eficiente) é verificar o resto da divisão dos 2 números recebidos por todos os números a partir do menos dos 2 recebidos até 1. Assim que encontrar um número cujo resto das duas divisões seja 0, é esse o MCD, e.g.\n28 % 12 != 0\n12 % 12 == 0\n--\n28 % 11 != 0\n12 % 11 != 0\n--\n28 % 10 != 0\n12 % 10 != 0\n--\n    .\n    .\n    .\n28 % 4 == 0\n12 % 4 == 0\nMCD = 4 -&gt; parar ciclo\n\n\nKing 6.3. Simplificar fração\nEscreve um programa que recebe 1 fração e simplifica-a.\nIntroduza fracao: 6/12\nSimplificada: 1/2\nDica: usar a implementação do 6.2. para dividir o numerador e denominador pelo máximo divisor comum.\n\n\nking 6.5.\nEscreve um programa que recebe um inteiro (de qualquer tamanho) e inverte os digitos. Usar apenas aritmética.\n\n\nKing 6.6. Quadrados inferiores a n\nEscreve um programa que recebe um número n e escreve na consola todos os quadrados pares inferiores a n. Por exemplo, se o utilizador introduzir 100:\n4\n16\n36\n64\n100"
  },
  {
    "objectID": "exercicios.html#exercícios-ciclos-afa",
    "href": "exercicios.html#exercícios-ciclos-afa",
    "title": "Programação",
    "section": "Exercícios Ciclos AFA",
    "text": "Exercícios Ciclos AFA"
  },
  {
    "objectID": "exercicios.html#exercícios-tipos-king",
    "href": "exercicios.html#exercícios-tipos-king",
    "title": "Programação",
    "section": "Exercícios Tipos King",
    "text": "Exercícios Tipos King\n\nKing 7.1. modificado\nEscreve um programa que determina o menor número cujo quadrado causa overflow para int. Modifica o programa para usar short int, unsigned int, long, unsigned long.\nPara valores inteiros, o valor máximo é dado por 2^n, onde n é o número de bits. Com base nos resultados, consegues perceber qual é o número de bits usado para cada tipo?\nA executar para int\nLado do primeiro quadrado que causa overflow: 46341\nQuadro que causa overflow: -2147479015\nUltimo quadrado antes de overflow: 2147395600\nDica: para verificar quando houve overflow, verifica quando um determinado quadrado passa a ser menor que o quadrado anterior.\n\n\nKing 7.2 TODO\n\n\nKing 7.3 TODO\n\n\nKing 7.4 Número teclas telemóvel -&gt; número\nEscreve um programa que recebe um conjunto de letras e converte para um número, com a conversão usada nos teclado alfanuméricos antigos.\nNumero em letras: CALLAT\nNumero: 225\nCorrespondência: 2=ABC, 3=DEF, 4=GHI, 5=JKL, 6=MNO, 7=PRS, 8=TUV, 9=WXY\nSe o número original contém carateres não numéricos, devem permanecer inalterados:\nNumero em letras: 1-800-COL-LECT\nNumero: 1-800-265-5328\nAssunção: todos os carateres são em letras maiúsculas.\nAjuda: - mesmo que um scanf peça apenas 1 char, o utilizador pode inserir um input do tamanho que quiser (até ) - podemos ler os restantes carateres com sucessivas chamadas a scanf ou getchar.\n\n\nKing 7.5. scrabble TODO\n\n\nKing 7.7. frações\nRefaz o problema King 3.6, mas agora o utilizador pode também escolher a operação entre frações (+, -, *, /).\n\n\nKing 7.8. TODO\n\n\nKing 7.9. Horas AM/PM\nCom base na lógica do exercício King 5.2, implementa um programa que agora recebe uma hora no formato 12h e converte para 24h. A hora pode ser recebida das seguintes formas:\n1:15P\n1:15PM\n1:15Pm\n1:15 PM\n1:15 P\n1:15p\n1:15pm\n1:15 pm\n1:15 p\nExemplo de utilização:\nHora 12: 9:11PM\nHora 24: 21:11\n\n\nKing 7.10 Contar vogais\nEscreve um programa que recebe uma frase do utilizador e conta o número de vogais.\n\n\nKing 7.11 Trocar nome\nEscreve um programa que recebe o primeiro e último nome do utilizador, e depois apresenta o nome no formato Ultimo, Primeira letra do primeiro.\nNome: Diogo Silva\nSilva, D.\n\n\nKing 7.12 Avaliar expressão\nEscreve um programa que avalia uma expressão matemática.\nExpressao: 1+2.5*3\nResultado: 10.2\nNotas: - As operações válidas são +, -, *, /. - Os operandos são todos intepretados como valores reais. - Não introduzir parêntises. - Calcular as operações da esquerda para a direita sem atenção à precedência de operações.\n\n\nKing 7.13. Tamanho médio das palavras\nEscreve um programa que recebe uma frase do utilizador e indica o tamanho médio das palavras.\nFrase: Este programa parece mais dificil do que e.\nTamanho medio das palavras: 4.5\nNota: para simplificar, assume que a pontuação faz parte da palavra.\n\n\nKing 7.14 TODO"
  },
  {
    "objectID": "exercicios.html#exercícios-tipos-afa",
    "href": "exercicios.html#exercícios-tipos-afa",
    "title": "Programação",
    "section": "Exercícios Tipos AFA",
    "text": "Exercícios Tipos AFA\n\nAFA 7.1. minúscula -&gt; maiúscula\nEscreve um programa que recebe uma letra minúscula e converte para maiúscula.\n\n\nAFA 7.2. frase -&gt; minúsculas\nEscreve um programa que recebe uma frase e converte todas as letras para minúsculas. Todos os carateres que não são letras maiúsculas não são modificados.\n\n\nAFA 7.3. César letra\n\nEscreve um programa que recebe uma letra e um inteiro (chave), e implementa a cifra de César.\nA cifra de César é um método simples para codificar uma mensagem, com a simples translação do abecedário.\nPor exemplo, se a chave tem o valor 1, então o ‘A’ é convertido para ‘B’, ‘B’ para ‘C’, ‘Z’ para ‘A’.\nSe a chave for negativa, a conversão é no sentido oposto.\nConverte apenas letras.\n\nChave: 2\nLetra: L\nLetra codificada: N\n\n\nAFA 7.4. César frase\n\nEscreve um programa que recebe uma frase e uma chave, e codifica a frase com a cifra de César.\nUsa a lógica do exercício AFA 7.3.."
  },
  {
    "objectID": "exercicios.html#exercícios-funções-king",
    "href": "exercicios.html#exercícios-funções-king",
    "title": "Programação",
    "section": "Exercícios Funções King",
    "text": "Exercícios Funções King\n\nKing 9.2. IRS\nReimplementa o exercício King 5.5. na forma de função. A função tem o nome calcular_irs, recebe um rendimento sobre a forma de um valor real e devolve outro valor real correspondente ao imposto devido.\nO programa pede um rendimento ao utilizador e indica no final o imposto devido e o rendimento total líquido (o valor recebido menos o imposto).\nNotas: - a função criada não lê valores da consola nem os escreve - leitura e escrita na consola é feita na função main\n\n\nKing 9.6. polinómio\nEscreve uma função que recebe um valor real x e devolve o resultado da avaliação desse valor no seguinte polinómio:\n3x^5 + 2x^4 - 5x^3 - x^2 + 7x - 6\nNotas:\n\nx^5 significa x \\times x \\times x \\times x \\times x, x^4=…\nresolva primeiro o exercício AFA 8.1. e use essa função para calcular as potências"
  },
  {
    "objectID": "exercicios.html#exercícios-funções-afa",
    "href": "exercicios.html#exercícios-funções-afa",
    "title": "Programação",
    "section": "Exercícios Funções AFA",
    "text": "Exercícios Funções AFA\n\nAFA 8.1. potência\nEscreve uma função chamada potencia que recebe uma base b (valor real) e um expoente e (inteiro). A função devolve o revolve o resultado da potência.\nNota: - quando um expoente é negativo, o resultado final é 1/(b^e). - não ler nem escrever da consola - usar a função main para testar se a função está a funcionar correctamente.\n\n\nAFA 8.2. máximo divisor comum\n\nReimplementa o exercício do máximo divisor comum (King 6.2.) na forma de função.\nA função\n\nchama-se calcular_mdc\nrecebe 2 valores inteiros\ndevolve o MDC entre esses 2 valores\n\n\n\n\nAFA 8.3. tabela de polinómio\n\nImplementa uma função que avalia um polinómio de 2º grau num determinado intervalo.\nA função\n\nchama-se poli2_intervalo\nrecebe o limite inferior e limite superior do intervalo a avaliar (reais)\nrecebe o número de pontos a avaliar (inteiro positivo)\nrecebe os 3 coeficientes (reais)\nescreve na consola o valor do polinómio nos pontos\ndevolve o valor do polinómio no ponto limite superior\n\n\nA tabela produzida deve ter o seguinte aspeto (se a=0.0, b=1.0, c=0.0, limInf=0.0, limSup=1.0, numPontos=5):\n   ponto    resultado do polinómio no ponto\nf(0.000000) = 0.000000 \nf(0.250000) = 0.250000 \nf(0.500000) = 0.500000 \nf(0.750000) = 0.750000 \nf(1.000000) = 1.000000 \nPossível procedimento: 1. Descobrir a distância entre os pontos a avaliar. 2. Inicializar o ponto a avaliar no limite inferior. 3. Calcular o polinómio no ponto. 4. Incrementar o ponto com a distância entre pontos. 5. Repetir 3-4 até chegar ao limite superior.\nNotas: - Além da função poli2_intervalo, implementa a função poli2_ponto que recebe os coeficientes do polinómio, o ponto x a avaliar e devolve o resultado desse polinómio no ponto recebido (ver exercício King 9.6) - Valores introduzidos pelo utilziador (coeficiente, limite inferior, superior, e nº de pontos) são pedidos na função main. - Um dos primeiros cálculos será a distância entre 2 pontos, e.g. no exemplo acima a distância entre pontos é de 0.25.\n\n\nAFA 8.4. polinómio grau n\n\nEscreve uma função que avalia um polinómio de grau N num determinado ponto.\nA função\n\nchama-se poliN_ponto\nrecebe apenas o ponto onde o polinómio será avaliado\npede ao utilizador o valor dos coeficientes, começando no grau menos elevado (0)\npára de pedir coeficientes quando um dos coeficientes é seguido da letra f (ver King 6.1.)\ndevolve o valor do polinómio no ponto recebido\n\n\nNotas: - o ponto a ser avaliado é recebido na main - o resultado do polinómio deve ser escrito para a consola na main, com 4 casas decimais\nExemplo:\nPonto: 1.0\nCoeficiente do grau 0: 1.0\nCoeficiente do grau 1: 0\nCoeficiente do grau 2: 0\nCoeficiente do grau 3: 2f\nResultado: 1.00\n\n\nAFA 8.5. Lab1 - Part 1 Calendário\n\nImplementa uma função que recebe o número de dias de um mês e o dia da semana do primeiro dia do mês e escreve um calendário na consola.\nO dia da semana é dado como um inteiro:\n\n0=domingo, 1=segunda-feira, 2=terça-feira,…\n\nPara um mês com 31 dias a começar a uma terça-feira, o calendário tem o seguinte formato.\n----------\n D  2  3  4  5  6  S\n       1  2  3  4  5\n 6  7  8  9 10 11 12\n13 14 15 16 17 18 19\n20 21 22 23 24 25 26\n27 28 29 30 31\n----------\nA função tem o seguinte cabeçalho:\n\nvoid escrever_calendario_mes(unsigned char n_dias, unsigned char dia_semana_inicio)\n\n\n\n\nAFA 8.6. Lab1 - Part 2.1 Calendário de data\n\nEscreve uma função que recebe um ano e um mês, e escreve na consola o calendário desse mês, usando a função da Parte 1.\nAssume que o mês de fevereiro tem sempre 28 dias.\nAssume que o mês começa sempre a uma terça-feira.\nA função tem o seguinte cabeçalho:\n\nvoid escrever_calendario_data(unsigned int ano, unsigned char mes)\n\nSe não resolveste a Parte 1, chama a função escrever_calendario_mes como se tivesse sido correctamente implementada. Nota que não vais conseguir executar o código, mas a pontuação será dada.\n\nAjudas: - Código para o número de dias em cada mês: c    int dias_no_mes;    switch(mes){      case 1:      case 3:      case 5:      case 7:      case 8:      case 10:      case 12:        dias_no_mes = 31; break;      case 4:      case 6:      case 9:      case 11:        dias_no_mes = 30; break;      case 2:        dias_no_mes = 28; break;      default:        dias_no_mes = 0;    }\n\n\nAFA 8.7. Lab 1 - Part 2.2 - dia da semana\n\nEscreve uma função que recebe uma data e devolve o dia da semana dessa data, como um inteiro.\nA função tem o seguinte cabeçalho:\n\nunsigned char dia_da_semana(unsigned int ano, unsigned char mes, unsigned char dia)\n\nO lógica desta função já nos foi dado e é o seguinte:\nif (mes &lt; 3) {\n        mes += 12;\n        ano -= 1;\n    }\n\nseculo = ano / 100;\nanoNoSeculo = ano % 100;\n\ndiaDaSemana = dia + 13*(mes+1)/5 + anoNoSeculo + anoNoSeculo/4 + seculo/4 + 5*seculo;\ndiaDaSemana %= 7;\n\n// converter para que o domingo=0, segunda=1, ...\ndiaDaSemana = (diaDaSemana + 6) % 7;\nModifica a função da parte 2.1. para que agora, o dia de início do mês seja calculado com esta função.\n\n\n\nAFA 8.8. Lab 1 - Part 2.3 - Ano bissexto\n\nEscreve uma função para calcular se um ano é bissexto.\nUm ano é bissexto se for (múltiplo de 4 E múltiplo de 100) OU (múltiplo de 400).\nO cabeçalho da função é o seguinte:\n\nunsigned char ano_bissexto(unsigned int ano)\n\nModifica a função da Parte 2.1. para que, se o mês for fevereiro, o número de dias do mês é correctamente calculado."
  },
  {
    "objectID": "exercicios.html#exercícios-array-king",
    "href": "exercicios.html#exercícios-array-king",
    "title": "Programação",
    "section": "Exercícios Array King",
    "text": "Exercícios Array King\n\nKing 8.1. digitos repetidos\n\nImplementa um programa que recebe um inteiro do utilizador e indica quais são os digitos repetidos.\nNo final o programa indica quais são os digitos repetidos, por ordem crescente.\n\nExemplo:\nNumero inteiro: 939577\nRepetidos: 7 9\n\n--\n\nNumero inteiro: 9339577\nRepetidos: 3 7 9\n\n\nKing 8.2. histograma digitos\nModifica o programa King 8.1. para devolver quantas vezes cada digito aparece num dado número.\nNumero inteiro: 41271092\nDigitos:    0   1   2   3   4   5   6   7   8   9\nContagem:   1   2   2   0   1   0   0   1   0   1\n\n\nKing 8.7. matriz 5x5\n\nEscreve um programa que recebe uma matriz de 5x5, linha a linha, e escreve no final o total de cada linha e de cada coluna.\nGuarda a matriz num array bidimensional.\n\nExemplo:\nLinha 1: 8 3 9 0 10\nLinha 2: 3 5 17 1 1\nLinha 3: 2 8 6 23 1\nLinha 4: 15 7 3 2 9\nLinha 5: 6 14 2 6 0\n\nTotais linhas: 30 27 40 36 28\nTotais colunas: 34 37 37 32 21\n\n\nKing 8.8. notas testes alunos\n\nModifica o programa King 8.7. para que cada linha corresponda para as 5 notas de testes de um aluno\nO programa indica a nota final (soma) do aluno, assim como a média de cada teste.\nO programa indica ainda, para cada teste, qual foi a nota mínima, máxima e média.\n\n\n\nKing 8.9. random walk\n\nEscreve um programa que gera um passeio aleatório num array 10x10.\nInicialmente todas as posições do array têm o carater ‘.’\nO programa não pode voltar para uma posição já visitada anteriormente.\nCada vez que o programa visita uma posição, essa posição fica com o valor A,B,C… pela ordem de visita.\nÉ necessário verificar se a posição de destino selecionada está dentro da matriz.\nSe por acaso todas as direções possíveis estiverem bloqueadas (ocupadas ou fora da matriz), o programa acaba.\nO passeio acaba na letra Z.\nO programa mostra a matriz apenas no final do passeio.\n\nExemplo normal:\nA . . . . . . . . .\nB C D . . . . . . .\n. F E . . . . . . .\nH G . . . . . . . .\nI . . . . . . . . .\nJ . . . . . . . Z .\nK . . R S T U V Y .\nL M P Q . . . W X .\n. N O . . . . . . .\n. . . . . . . . . .\nExemplo de terminação prematura (acabou no Y):\nA B G H I . . . . .\n. C F . J K . . . .\n. D E . M L . . . .\n. . . . N O . . . .\n. . W X Y P Q . . .\n. . V U T S R . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\nNotas: - para gerar números aleatórios, usar a função rand (ver exemplo abaixo)\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main () {\n   int i, n;\n   time_t t;\n   \n   n = 5;\n   \n   /* Intializes random number generator */\n   srand((unsigned) time(&t));\n\n   /* Print 5 random numbers from 0 to 49 */\n   for( i = 0 ; i &lt; n ; i++ ) {\n      printf(\"%d\\n\", rand() % 50);\n   }\n   \n   return(0);\n}\n\n\nKing 9.1. selection sort\n\nEscreve um programa que recebe um conjunto de inteiros do utilizador e, no final, mostra esses números ordenados.\nO programa recebe os números um a um até que um dos números tenha um ‘f’ após o último digito, e.g. 42f.\nO programa guarda os números num array.\nAssuma que o número máximo de inteiros a receber é 200.\nO programa ordena os números do array com a função selection_sort.\nA função selection_sort recebe um vector e ordena-o. Para isso, faz o seguinte:\n\nProcura no array o maior elemento e passa-o a última posição.\nProcura no array o segundo maior elemento e passa-o para a penúltima posição.\n…\nRepetir n-1 vezes, em que n é o tamanho do vetor.\nO uso de recursão é especialmente adequado.\n\nOs inteiros são pedidos na main.\n\n\n\nKing 9.3. modificado, random walk\n\nModifica o problema King 8.9 para que seja implementado com 3 funções:\n\nvoid fill_array(char walk[10][10], char f) recebe a matriz e preenche em todas as posições da matriz o carater f.\nrandom_walk_generator(char walk[10][10]) recebe a matriz e gera uma nova random walk com a lógica do King 8.9.\nprint_array(char walk[10][10]) recebe a matriz e escreve-a na consola.\n\nNa função main, apenas deve ser criada a matriz e o programa implementa as funcionalidades pretendidas chamando estas funções.\n\n\n\nKing 9.5. magic square\n\n\nEscreve um programa que escreve uma matriz n x n:\n\ncom todos os números de 1 até n^2\nem que a soma de todas as linhas, colunas e diagonais são iguais\nn tem de ser um inteiro ímpar entre 1 e 99\n\nO utilizador especifica a dimensão da matriz, indicando o valor n.\nImplementa a lógica na função generate_magic_square, que recebe um vetor de tamanho variável.\nPara construir a matriz:\n\ncomeçar por escrever 1 no meio da primeira linha\nescrever os valores seguintes na linha acima e na coluna seguinte\nse a linha acima estiver fora da matriz, deve-se dar a volta, e.g. -1 -&gt; n-1\nse a coluna à direita estiver fora da matriz, deve-se dar a volta, e.g. n -&gt; 0\nse a posição já estiver ocupada, deve-se colocar o número na posição abaixo da última posição preenchida.\n\nEscreve uma função print_magic_square que recebe a matriz e apresenta o resultado na consola.\nDeve também indicar qual é o valor da soma das linhas, colunas e diagonais, que é o mesmo valor.\n\nExemplo:\nIntroduza um inteiro ímpar entre 1 e 99: 5\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9"
  },
  {
    "objectID": "exercicios.html#exercícios-array-afa",
    "href": "exercicios.html#exercícios-array-afa",
    "title": "Programação",
    "section": "Exercícios Array AFA",
    "text": "Exercícios Array AFA\n\nAFA 9.1. polinómio\n\nEscreve uma função poliN que recebe um vetor coef de reais que pode ter qualquer tamanho (deve também receber outro parâmetro n com o tamanho real do vector) e um real x.\nA função avalia um polinómio de grau n-1 no ponto x.\nOs coeficientes do polinómio estão no vetor recebido.\nPode usar a função pow (da biblioteca math.h) para calcular as potências (ou usar a solução do exercício AFA 8.1.).\ncoef[0] corresponde ao coeficiente de menor grau, coef[1] corresponde ao coeficiente do 2º menor grau, …\nPara um polinómio de grau 3:\n\ncoef[0] + coef[1] * x + coef[2] * x^2\nExemplo de utilização da função pow:\n#include &lt;math.h&gt;\n\nint main(){\n  printf(\"2^2 = %lf\", pow(2.0, 2.0));\n}\n\n\nAFA 9.2. IRS generalizado\n\nReimplementa o exercício King 9.2. para funcionar para qualquer número de escalões e com quaisquer limites dos escalões.\nA função recebe um vetor de reais (escaloes) com n elementos, correspondentes aos limites dos escalões.\nExistem no total n-1 escalões.\nescaloes[0] é o limite inferior do primeiro escalão, escalores[1] é o limite superior do primeiro escalão e o inferior do segundo, etc.\nA função recebe ainda um vetor de reais (taxas) com n-1 elementos que contém a taxa a aplicar em cada escalão: taxas[0] é a taxa a aplicar no rendimento do primeiro escalão, taxas[1] é a taxa a aplicar no rendimento do segundo escalão, etc.\n\nDicas: - a lógica para um determinado escalão é sempre igual, mudando apenas os limites do escalão e a taxa a aplicar; - implementa uma função auxiliar para calcular o imposto num determinado escalão; - usa vetores de tamanho variável;\n\n\nAFA 9.3. Ordenar array 2\n\nImplementa uma função que recebe um vector de inteiros de qualquer tamanho e um char.\nO char indica se o vetor deve ser ordenado de forma crescente ou decrescente.\nA função ordena o vector da forma indicada pelo char.\nUsa a implementação do King 9.1\n\nPodes criar outra função para ordenar de forma decrescente e a função deste exercício chama a função do AFA 9.3 (crescente) ou a função para ordenar de forma decrescente, conforme o que seja indicado pelo char.\n\n\n\n\nAFA 9.4. Ordenar indices array\n\n\nImplementa uma função que recebe:\n\num vector de inteiros vals de qualquer tamanho\num vector de inteiros positivos indeces do mesmo tamanho do vals\n\nA função:\n\ninicializa o vetor indeces com os indices de vals (0,1,2,3…)\nmuda a ordem de indeces de forma a refletir uma ordenação crescente do conteúdo de vals\n\n\nExemplo:\nInput:\n   vals:   42  1  9  87\nindeces:    ?  ?  ?   ?\n\nDepois de inicializar indices:\n   vals:   42  1  9  87   (não foi alterado)\nindeces:    0  1  2   3\n\nDepois de ordenar:\n   vals:   42  1  9  87   (não foi alterado)\nindeces:    1  2  0   3\n\n\nAFA 9.5. Redes neuronais: Perceptron\n\nEscreve uma função que implementa um perceptron, que é um conceito da área de inteligência artificial.\nO perceptron recebe um vetor de inteiros x (o input do perceptron) e um vetor de reais w (os pesos de cada input e o bias).\nO vetor x tem tamanho n e o vetor w tem tamanho n+1.\nO perceptron calcula o produto escalar de x e w e devolve 1 se o resultado for positivo e 0 se for negativo ou zero.\nO último elemento do vetor w é o bias.\nO bias é um valor que é adicionado ao produto escalar.\nA fórmula do output do perceptron é a seguinte:\n\n\n\\begin{equation}\n  output = \\begin{cases}\n    1 & \\text{se } (\\sum_{i=1}^{n} x_i \\times w_i) + b &gt; 0 \\\\\n    0 & \\text{caso contrário}\n  \\end{cases}\n\\end{equation}\n\n\n\n\nDiagrama do Perceptron\n\n\n\nO cabeçalho da função é o seguinte:\n\nint perceptron(int n, int x[n], double w[n+1]);\n\nTesta a função com pesos e inputs diferentes.\n\n\n\nAFA 9.6. Redes neuronais: combinar perceptrons\n\nOs perceptrons podem ser combinados para formar redes neuronais mais complexas.\n\n\n\n\nDiagrama de uma rede neuronal\n\n\n\nNo diagrama acima, cada nó da primeira coluna é um dos inputs da rede x_1, x_2, ..., x_n.\nCada nó da segunda, terceira e quarta colunas é um perceptron que recebe os inputs da primeira coluna e devolve um output.\nO output de cada perceptron é o input dos perceptrons da coluna seguinte.\nEscreve uma função que recebe um vetor de reais x (o input da rede) e uma matriz de reais w (os pesos de cada perceptron e o bias).\nO vetor x tem tamanho n e a matriz w tem m linhas e n+1 colunas.\nCada linha da matriz w corresponde aos pesos de um perceptron, portanto a matriz tem m perceptrons.\nA função recebe ainda um vector de reais correspondente aos outputs de cada perceptron.\nO cabeçalho da função é o seguinte:\nvoid camada_perceptron(int n, int m, double x[n], double w[m][n+1], double output[m]);\nA função calcula o output de cada perceptron e guarda-o no vetor output.\nO output de cada perceptron é calculado da mesma forma que no exercício anterior.\nPor exemplo, para um input de 3 elementos e uma camada de 4 perceptrons, a função recebe um vetor x de tamanho 3, uma matriz w de tamanho 4x4 e um vetor output de tamanho 4. O output de cada perceptron seria calculado da seguinte forma:\noutput[0] = perceptron(n, x, w[0]);\noutput[1] = perceptron(n, x, w[1]);\noutput[2] = perceptron(n, x, w[2]);\noutput[3] = perceptron(n, x, w[3]);\nEscreve a função para que funcione para qualquer tamanho de input e qualquer número de perceptrons.\n\n\n\nAFA 9.7. Redes neuronais: rede completa\n\nEscreve um programa completo que implemente uma rede neuronal com 3 elementos de input, uma camada de 4 perceptrons e uma camada final de 1 perceptron.\nCria os vectores necessários para acomodar os inputs e outputs de cada camada.\nCria as matrizes necessárias para acomodar os pesos de cada camada.\nUsa valores arbitrários para os pesos e inputs e testa o programa.\nUsa a função camada_perceptron do exercício anterior para implementar a rede neuronal."
  },
  {
    "objectID": "exercicios.html#exercícios-strings-king",
    "href": "exercicios.html#exercícios-strings-king",
    "title": "Programação",
    "section": "10 Exercícios Strings King",
    "text": "10 Exercícios Strings King\n\nKing 13.1 palavras ordem alfabética\n\nEscreve um programa que recebe uma série de palavras.\nO programa pára de pedir palavras quando receber uma palavra de 4 letras.\nAssume-se que nenhuma palavra tem mais de 20 letras.\nNo final o programa indica a primeira e última palavras, se as palavras recebidas tivessem ordenadas por ordem alfabética.\n\nPalavra: peixe\nPalavra: rinoceronte\nPalavra: laranja\nPalavra: livro\nPalavra: ananas\nPalavra: gato\n\nPrimeira: ananas\nÚltima: rinoceronte\n\nDica: - Usa a função strcmp da biblioteca string.h, que recebe 2 strings (s1 e s2) e devolve 0 se s1 e s2 forem iguais, devolve um valor negativo se o primeiro caracter diferente de s1 for inferior ao primeiro carater diferente de s2, ou um valor positivo se o primeiro carater diferente de s1 for superior ao primeiro carater diferente de s2.\n\n\nKing 13.4 inverter frase, modificado\n\nEscreve um programa que recebe uma frase do utilizador.\nO programa escreve as palavras na ordem inversa às que as recebeu.\n\nFrase:\nexercicio demasiado facil\n\nfacil demasiado exercicio\n\n\nKing 13.5 executar string de soma, modificado\n\nEscreve um programa que recebe uma frase do utilizador do tipo “soma 8 24 62”\nAssume que soma é a única operação.\nPara implementar o programa, implementa uma função que recebe uma string com uma lista de números e devolve a soma desses números.\nA main pede uma string com fgets e usa esta função para calcular a soma.\nDicas:\n\nA função strtok da biblioteca string.h divide uma string de acordo com um separador\n\nrecebe a string a separar e a string que contém o separador\ndepois da primeira chamada de strtok, o primeiro argumento deve ser NULL\nstrtok devolve uma string com a próxima “palavra” (token) separada pelo separador indicado, ou NULL se não houverem mais tokens.\n\nA função atof da biblioteca stdlib.h recebe uma string (com um número) e devolve um número real.\n\nExemplo strtok\n\neste programa divide a string str nas suas palavras constituintes (separadas por um espaço) e escreve essas palavras, uma a uma, em linhas separadas.\nrepara que só a primeira chamada de strtok é que contém a string a processar, as restantes usam NULL nesse argumento.\nrepara que verificamos se a string devolvida é NULL para verificar quando existem algum valor de interesse.\ncódigo: ````c #include &lt;stdio.h&gt; #include &lt;string.h&gt;\nint main() { char str[] = “The quick brown fox”; char* token = strtok(str, ” “);\nwhile (token != NULL) {\n    printf(\"%s\\n\", token);\n    token = strtok(NULL, \" \");\n}\n\nreturn 0;\n} ```\n\nExemplo atof `c   #include &lt;stdlib.h&gt;   int main(){     printf(\"num=%lf\", atof(\"3.14\"));   }\n\n\n\nKing 13.11 tamanho media das palavras, modificado\n\nCom base no exercício King 7.13, escreve um programa que pede frases ao utilizados.\nO programa indica qual é o tamanho médio das palavras de cada frase recebida.\nO programa pára de pedir frases quando receber uma frase apenas com a palavra “parar”.\nDeve implementar uma função que recebe uma string e devolve o tamanaho médio das palavras dessa string."
  },
  {
    "objectID": "exercicios.html#exercícios-strings-afa",
    "href": "exercicios.html#exercícios-strings-afa",
    "title": "Programação",
    "section": "10 Exercícios Strings AFA",
    "text": "10 Exercícios Strings AFA\n\nAFA 10.1. Cifras de césar\n\nRefaz o exercício AFA 7.4. mas usando strings.\nEscreve uma função que recebe um char e uma cifra (int) e devolve esse char cifrado.\nEscreve uma função que recebe uma string com uma mensagem.\n\nA função converte essa mensagem numa mensagem cifrada, usando a função acima.\nA função reescreve a mensagem cifrada sobre a mensagem original (mesma string)\n\nA função main é a única que interage com o utilizador.\n\nPede uma frase ao utilizador, guardando-a numa string.\nEssa string é passada para a função que a vai cifrar.\nNo final, escrever na consola a mensagem cifrada."
  },
  {
    "objectID": "exercicios.html#king-2",
    "href": "exercicios.html#king-2",
    "title": "Programação",
    "section": "King",
    "text": "King"
  },
  {
    "objectID": "exercicios.html#afa",
    "href": "exercicios.html#afa",
    "title": "Programação",
    "section": "AFA",
    "text": "AFA\n\nAFA 12.1 timedelta\n\nImplementa uma função calcular_dif_datahora que recebe 2 marcas temporais (data e hora) e devolve a diferença temporal.\nA marca temporal é uma estrutura DataHora com os campos:\n\nano, mes, dia\nhora, minuto, segundo\n\nA marca temporal é uma estrutura DataHoraDelta com os campos:\n\ndias, horas, minutos, segundos\n\nVai ter de implementar a lógica para saber se um ano é bissexto (ver AFA 8.6.)\n\n\n\nAFA 12.2 aritmética DataHora\n\nImplementa uma função soma_DataHora que recebe uma DataHora (ver AFA 12.1) e um DataHoraDelta.\nA função devolve uma nova DataHora, que resulta da soma entre a DataHora recebida e a DataHoraDelta.\nImaplementa uma função sub_DataHora que faz o mesmo, mas o resultado é a subtração e não a soma."
  },
  {
    "objectID": "exercicios.html#exercícios-ficheiros-king",
    "href": "exercicios.html#exercícios-ficheiros-king",
    "title": "Programação",
    "section": "13 Exercícios Ficheiros King",
    "text": "13 Exercícios Ficheiros King"
  },
  {
    "objectID": "exercicios.html#exercícios-ficheiros-afa",
    "href": "exercicios.html#exercícios-ficheiros-afa",
    "title": "Programação",
    "section": "13 Exercícios Ficheiros AFA",
    "text": "13 Exercícios Ficheiros AFA\n\nA 13.1 Jogadores\n\nEscreva um programa que a partir dum ficheiro chamado “jogadores.txt”, guarde a informação dos jogadores num vetor de registos e escreva um simples número real que indique qual a média de golos dos jogadores.\nO ficheiro “jogadores.txt” tem um conteúdo semelhante ao seguinte:\n  Joao 5 Leixoes \n  Tarquineo 6 Benfica \n  Pedro 3 Sporting \n  Luis 8 Belenenses \n  Miguel 2 Leixoes \n  Joao 1 Sporting \n  Manuel 5 Academica \n  Camoes 5 Porto \n  Fernando 10 Benfica \n  Joaquim 7 Boavista \n  Gervasio 7 Belenenses \nSe não tiver o ficheiro “jogadores.txt”, comece por criar esse ficheiro com o conteúdo apresentado acima.\n\n\n\nA 13.2\n\nO seguinte ficheiro de texto - “alice.txt” – contém uma tradução para português do Brasil de uma das mais famosas obras da literatura em Inglês do século XIX: “Alice no País das Maravilhas”. Pedimos-lhe para escrever um programa para fazer algumas contagens no ficheiro “alice.txt”. Escreva o programa pouco e pouco, introduzindo uma contagem de cada vez:\n\nO número de linhas do ficheiro;\nO número de linhas vazias do ficheiro;\nO número de linhas do ficheiro, onde ocorre a palavra “Alice”.\n\nResolva este problema sem carregar o ficheiro num vetor. Percorra o ficheiro lendo uma linha de cada vez usando a função fgets. Enquanto faz isso, vá atualizando alguns contadores, que foram inicializados a zero.\nOrganize o seu programa por forma a percorrer o ficheiro apenas uma vez. Isto faz com que o programa não possa ser decomposto em muitas funções. Portanto, escreva uma função chamada “processar_ficheiro” que recebe o nome do ficheiro, faz as contagens e escreve os resultados.\nPara testar se a palavra “Alice” ocorre numa linha, pode usar a função char *strstr ( char  *str1, char  *str2)\n\nfunção da biblioteca string.h\nEsta função devolve NULL caso str2 não se encontre em str1;\n\n\n\n\nA 13.3\nEscreva um programa que leia todas as linhas de um ficheiro e diga quantas palavras existem em cada linha do ficheiro.\n\n\nA 13.4\nEscreva um programa que leia todas as linhas de um ficheiro “ler.txt” e escreva no ficheiro “escrever.txt” por ordem inversa todas as linhas do primeiro ficheiro.\n\n\nA 13.5\n\nEscreva um programa que inverta as palavras de cada linha de um ficheiro “inverter.txt”.\nExemplo:\n\nFicheiro\nA hora de almoco e as 12h00.\nA hora de jantar e as 19h00.\nOutput\n.00h21 as e ocomla ed aroh A\n.00h91 sa e ratnaj ed aroh A\n\n\n\n\nA 13.6 grep\n\nEscreva uma função grep que recebe o nome de um ficheiro de texto e uma string e imprime na consola todas as linhas que contêm a string.\nComeça por escrever num ficheiro de texto o primeiro e último nome dos alunos da turma (pelo menos 5-10). Podes partilhar o ficheiro com o resto da turma.\nNeste exemplo, a string é “a”\nSoares, 1189\nFontainha, 1172\nFernandes, 1198\nPedrosa, 1179\nBranco, 1184\nCebola, 1171\nRamalho, 1190\nSantos, 1201\nSalgado, 1174\n\n\n\nA 13.7 grep -i\n\nCom base em A 13.6 grep, crie outra função grep_ignora que ignora a capitalização da string.\nNeste exemplo a string é “r”.\nRodrigues, 1195\nSoares, 1189\nFernandes, 1198\nPedrosa, 1179\nBranco, 1184\nRamalho, 1190\n\n\n\nA 13.8 grep -c\n\nCom base em A 13.6 grep, crie outra função grep_conta que imprime apenas o número de linhas em que a string foi encontrada.\nNeste caso, a capitalização da string interessa.\nNeste exemplo a string é “r”.\n5\n\n\n\nA 13.9 grep -i, modificada\n\nMelhore a função grep_ignora, dando a opção para parar a procura após encontrar a string N vezes.\nSe N=0, então não há limite, e.g. procurar “al” no ficheiro “alunos.txt” com N=2.\nMariana Relvão Carvalho\nInês Carvalho\n\n\n\nA 13.10 grep -c, múltiplos ficheiros\n\nCrie uma função grep_conta_varios dando a opção para para receber vários ficheiros e realizar a procura em cada um deles.\nDeve ser adicionado um prefixo com o nome do ficheiro em cada linha impressa na consola.\nA função recebe um vector de strings e uma string.\nCada string no vector tem um nome de ficheiro e um tamanho máximo definido numa constante.\nA outra string é a “palavra” (pode ser uma frase) a procurar.\nPara cada ficheiro, deve ser chamada a função grep_conta.\nE.g. procurar “al” nos ficheiros\nalunos.txt: 8\nalunos1718.txt: 2\nE.g. procurar “fon” nos ficheiros alunos.txt e alunos1718.txt\nalunos.txt: 1\nalunos1718.txt: 1\n\n\n\nA 13.11 grep -i, vários ficheiros\n\nCrie uma função grep_ignora_varios dando a opção para para receber vários ficheiros e realizar a procura em cada um deles.\nDeve ser adicionado um prefixo com o nome do ficheiro em cada linha impressa na consola.\nA função recebe um vector de strings, uma string e um inteiro.\nCada string no vector tem um nome de ficheiro.\nA outra string é a “palavra” (pode ser uma frase) a procurar.\nO inteiro é o número a partir do qual não se deve contar mais (o N no exercicio anterior).\nPara cada ficheiro, deve ser chamada a função grep_ignora melhorada.\nExemplo para procurar a string “al” nos ficheiros alunos.txt e alunos1718.txt, com N=2:\nalunos.txt: Mariana Relvão Carvalho\nalunos.txt: Inês Carvalho\nalunos1718.txt: 1174 Salgado\nalunos1718.txt: 1190 Ramalho\n\n\n\nA 13.12 ficheiro binário, alunos\n\nConsidera a seguinte estrutura\ntypedef struct {\n  char nome[100];\n  char morada[300];\n  int id_num;\n  float media;\n} Aluno;\nO ficheiro alunos.bin contém vários Aluno.\nEscreve um programa que indica o nome do aluno com a média mais alta."
  },
  {
    "objectID": "exercicios.html#exercícios-memória-king",
    "href": "exercicios.html#exercícios-memória-king",
    "title": "Programação",
    "section": "14 Exercícios Memória King",
    "text": "14 Exercícios Memória King"
  },
  {
    "objectID": "exercicios.html#exercícios-memória-afa",
    "href": "exercicios.html#exercícios-memória-afa",
    "title": "Programação",
    "section": "14 Exercícios Memória AFA",
    "text": "14 Exercícios Memória AFA\n\nAFA 14.1. Image padding\n\nNo domínio da visão computacional, é comum termos de adicionar pixeis à volta de uma imagem.\nImplementa uma função que recebe uma imagem (vector de unsigned char com 3 dimensões) com uma determinada altura h (1ª dimensão) e largura w (2ª dimensão) e o número de pixeis de padding.\nA 3ª dimensão é o número de canais de cor, que será 3.\nA função cria um novo vector (alocado dinâmicamente) com o mesmo tamanho da imagem recebida, mas com a primeira e segunda dimensões incrementadas com o número de pixeis de padding.\nPosteriormente, a função copia a imagem original para a nova imagem com padding.\nO espaço de padding deve estar inicializado com zeros.\nA função retorna a imagem com padding.\n\n\n\nAFA 14.2. Computer Vision - augmentations 1 - occlusion\n\nNo domínio da visão computacional, é comum aumentar o número de imagens de um dataset com as imagens originais, mas com uma parte da imagem escondida.\nO teu objetivo será criar uma função que recebe uma imagem (vector de unsigned char com 3 dimensões) e vai criar uma cópia da imagem original, mas com partes da imagem escondida.\nA função recebe a imagem original, assim como as suas dimensões e o tamanho do quadrado que vai esconder parte da imagem (int)."
  },
  {
    "objectID": "exercicios.html#exercícios-estruturas-de-dados-dinâmicas-aula",
    "href": "exercicios.html#exercícios-estruturas-de-dados-dinâmicas-aula",
    "title": "Programação",
    "section": "15 Exercícios Estruturas de Dados Dinâmicas Aula",
    "text": "15 Exercícios Estruturas de Dados Dinâmicas Aula\n\nAula 15.1. deleteNode\n\nConsidera o seguinte programa, onde está implementada uma lista ligada de inteiros.\nO programa tem uma função addNode que adiciona um novo nó à lista.\nImplementa uma função deleteLastNode que remove o último nó da lista.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\n\ntypedef struct {\n  Node * head;\n  int size;\n} LinkedList;\n\nvoid addNode(LinkedList * list, int data) {\n  // criar novo Node\n  Node *new_node = malloc(sizeof(Node));\n  new_node-&gt;data = data;\n  new_node-&gt;next = NULL;\n\n  Node *current = list-&gt;head;\n  Node *prev = NULL;\n\n  // procurar fim da lista\n  while (current != NULL) {\n    prev = current;\n    current = current-&gt;next;\n  }\n  // se prev for NULL, então lista está vazia\n  if (prev == NULL) {\n    list-&gt;head = new_node;\n  } else {\n    prev-&gt;next = new_node;\n  }\n\n  list-&gt;size++;\n}\n\nvoid deleteLastNode(LinkedList * list){\n\n}\n\nint main(void) {\n  LinkedList lista = {NULL, 0};\n\n  addNode(&lista, 1);\n  addNode(&lista, 2);\n  addNode(&lista, 3);\n\n  //\n  printf(\"tamanho da list = %d\\n\", lista.size);\n\n  deleteLastNode(&lista);\n  deleteLastNode(&lista);\n\n  printf(\"tamanho da list = %d\\n\", lista.size);\n\n\n  // imprimir lista\n  Node *c = lista.head;\n  while (c != NULL){\n    printf(\"%d\\n\", c-&gt;data);\n    c = c-&gt;next;\n  }\n\n  return 0;\n}"
  },
  {
    "objectID": "exercicios.html#exercícios-estruturas-de-dados-dinâmicas-king",
    "href": "exercicios.html#exercícios-estruturas-de-dados-dinâmicas-king",
    "title": "Programação",
    "section": "15 Exercícios Estruturas de Dados Dinâmicas King",
    "text": "15 Exercícios Estruturas de Dados Dinâmicas King"
  },
  {
    "objectID": "exercicios.html#exercícios-estruturas-de-dados-dinâmicas-afa",
    "href": "exercicios.html#exercícios-estruturas-de-dados-dinâmicas-afa",
    "title": "Programação",
    "section": "15 Exercícios Estruturas de Dados Dinâmicas AFA",
    "text": "15 Exercícios Estruturas de Dados Dinâmicas AFA\n\nAFA 15.1 receber lista de números reais\n\nImplementa uma lista ligada de números reais.\nEscreve uma função que recebe uma lista ligada e um número real.\n\nA função cria um novo nó com o número real recebido e adiciona-o à lista recebida.\n\nNa main, pede 5 números reais ao utilizador e guarda-os na lista lidada.\nEscreve uma função que escreve na consola o conteúdo de todos os elementos da lista ligada.\nNa main, usa esta função para escrever na consola os elementos introduzidos pelo utilizador.\nModifica a main para que o número de elementos pedidos ao utilizador não esteja pré-definido.\n\nO programa vai pedindo valores ao utilizador enquanto os quiser inserir.\nPara sinalizar que se inseriu o último valor, o utilizador irá escrever um “f” após o último número, e.g. 3.14f.\n\n\n\n\nAFA 15.2 listlen\n\nCom base no AFA 15.1, adiciona escreve uma função que recebe uma lista ligada de números reais e devolve o número de elementos dessa lista.\n\n\n\nAFA 15.3 soma e média\n\nCom base no AFA 15.1, adiciona escrve 2 funções que recebem uma lista ligada de números reais e devolvem um valor:\n\nA função soma recebe uma lista ligada e devolve a soma de todos os elementos existentes na lista.\nA função media recebe uma lista ligada e devolve a média de todos os elementos existentes na lista.\n\n\n\n\nAFA 15.4. filtro\n\nCom base no AFA 15.1, adiciona uma função que recebe uma lista ligada e 2 valores lower e upper.\nA função irá remover da lista todos os elementos que estão abaixo do valor lower e os que estão acima de upper.\n\n\n\nAFA 15.5. círculos concêntricos - implementação de lista ligada\n\nNo desenvolvimento de um sistema de aterragem automática com base em visão, uma das tarefas foi a deteção dos círculos de um marcador, com base em visão computacional.\nConsidera a seguinte implementação de uma lista ligada de círculos.\ntypedef struct circle {\n  int x;\n  int y;\n  int radius;\n  struct circle *next;\n} Circle;\n\ntypedef struct {\n  Circle * head;\n  int size;\n} CircleList;\nCria uma função addCircle que recebe uma lista ligada de círculos e os dados de um novo círculo.\nA função cria um novo círculo com os dados recebidos e adiciona-o à lista ligada.\n\nexemplo:\n\nlista ligada: c1 -&gt; c2 -&gt; c3 -&gt; c4\nnovo círculo: c5\nlista ligada: c1 -&gt; c2 -&gt; c3 -&gt; c4 -&gt; c5\n\n\nUsa o seguinte vector tridimensional de floats com os centros e raios como base dos dados para preencher a lista ligada:\nfloat circles[5][3] = {\n  { 10, 10, 5 },\n  { 10.1, 10.1, 15},\n  { 9.9, 10.1, 10},\n\n  { 20, 20, 10 },\n  { 19.9, 20.2, 15},\n  { 19.8, 20.1, 2},\n\n  { 5, 5.2, 5 },\n  { 5.3, 4.8, 10 },\n  { 4.9, 4.9, 15 },\n};\nImplementa uma função printCircleList que recebe uma lista ligada de círculos e escreve na consola os dados de todos os círculos da lista.\nNa main, cria uma nova lista ligada e adiciona os círculos do vector circles à lista ligada, usando a função addCircle.\nNo final da main, usa a função printCircleList para escrever na consola os dados de todos os círculos da lista ligada.\n\n\n\nAFA 15.6. círculos concêntricos - família de círculos\n\nCom base no AFA 15.5, adiciona uma função newCircleFamily que recebe uma lista ligada de círculos, as coordenadas de um centro e um desvio máximo.\nA função devolve uma nova lista ligada com todos os círculos da lista recebida que estão dentro do desvio máximo em relação ao círculo recebido. Cada círculo adicionado é retirado da lista original.\n\nexemplo:\n\nlista ligada: c1 -&gt; c2 -&gt; c3 -&gt; c4\ncentro: c2\ndesvio máximo: 2\nlista ligada: c1 -&gt; c3\nnova lista ligada: c2 -&gt; c4\n\n\nNa main, verifica o correto funcionamento da função escolhendo as coordenadas do centro de um dos círculos conhecidos e um desvio máximo adequado. Depois usa a função printCircleList para escrever na consola os dados de todos os círculos da nova lista ligada (com a família de círculos).\nConfirma também que a lista ligada original ficou corretamente atualizada (sem os círculos da nova lista ligada).\n\n\n\nAFA 15.7. círculos concêntricos - famílias de círculos\n\nCom base no AFA 15.6, cria um vector de listas ligadas de círculos. Cada uma destas listas deve ser correctamente inicializada como estando vazia (head = NULL, size = 0).\nCada lista ligada do vector representa uma família de círculos.\nCria uma função que recebe o vector de listas ligadas de círculos (com o seu tamanho) e a lista ligada com os círculos detetados.\nA função preenche o vector de listas ligadas de círculos atualizado e devolve o número de famílias criadas.\n\nexemplo:\n\nlista ligada de círculos detetados: c1 -&gt; c2 -&gt; c3 -&gt; c4 -&gt; c5 -&gt; c6\nvector de listas ligadas de círculos:\n\nfamília 1: c1 -&gt; c5 -&gt; c6\nfamília 2: c2 -&gt; c4\nfamília 3: c3\n\n\n\nNa main, verifica o correto funcionamento da função imprimindo na consola cada uma das famílias de círculos."
  },
  {
    "objectID": "exercicios.html#section",
    "href": "exercicios.html#section",
    "title": "Programação",
    "section": "22/23",
    "text": "22/23\n\nLab 1\n\n\nLab 2\n\n\nLab 3\n\n\nLab 4"
  },
  {
    "objectID": "exercicios.html#section-1",
    "href": "exercicios.html#section-1",
    "title": "Programação",
    "section": "15",
    "text": "15\n\nAFA 15.1\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct node {\n  float value;\n  struct node *next;\n} Node;\n\ntypedef struct {\n  Node * head;\n  int size;\n} List;\n\n// adiciona no final da lista\nvoid add(List *list, float value) {\n  Node *newNode = (Node *) malloc(sizeof(Node));\n  newNode-&gt;value = value;\n  newNode-&gt;next = NULL;\n\n  if (list-&gt;head == NULL) {\n    list-&gt;head = newNode;\n  } else {\n    Node *current = list-&gt;head;\n    while (current-&gt;next != NULL) {\n      current = current-&gt;next;\n    }\n    current-&gt;next = newNode;\n  }\n  list-&gt;size++;\n}\n\nvoid printList(List *list) {\n  Node *current = list-&gt;head;\n  while (current != NULL) {\n    printf(\"%f\\n\", current-&gt;value);\n    current = current-&gt;next;\n  }\n}\n\nint main() {\n  List list;\n  list.head = NULL;\n  list.size = 0;\n\n  float value;\n  char c;\n  do {\n    scanf(\"%f%c\", &value, &c);\n    add(&list, value);\n  } while (c != 'f');\n\n  printList(&list);\n\n  return 0;\n}\n\n\nAFA 15.2 listlen\nint listlen(List *list) {\n  int count = 0;\n  Node *current = list-&gt;head;\n  while (current != NULL) {\n    count++;\n    current = current-&gt;next;\n  }\n  return count;\n}\n\n\nAFA 15.3 soma e média\n\nfloat soma(List *list) {\n  float sum = 0;\n  Node *current = list-&gt;head;\n  while (current != NULL) {\n    sum += current-&gt;value;\n    current = current-&gt;next;\n  }\n  return sum;\n}\n\nfloat media(List *list) {\n  return soma(list) / listlen(list);\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programação",
    "section": "",
    "text": "Links úteis\n\nReplit PROG\nTeams PROG\nFicheiros SharePoint\nSetup VSCode locally\n\n\n\nAulas\n\nApresentação da UC\n\n\nSlides\n\n\nC Fundamentals\n\n\nSlides\n\n\nLeitura e escrita formatada\n\n\nSlides\n\n\nExpressões\n\n\nSlides\n\n\nTestes e Condições\n\n\nSlides\n\n\nCiclos\n\n\nVideos\nVideos\n\nIntro - 1min, Loom\nwhile - 7min, Loom\ndo while - 4min, Loom\nfor - 6min, Loom\nfor demo - 3min, Loom\nfor demo 2 - 5min, Loom\nbreak, continue - 7min, Loom\nciclos infinitos - 3min, Loom\n\n\n\nTipos básicos do C\n\n\nSlides\n\n\nFunções\n\n\nSlides, PDF\nVideos\n\nIntro - 3min\nCaracteristicas - 3min\nExemplos, mais caracteristicas - 6min\nParâmetros - 9min\n\nIntro teórica - 2min\nDemo - 4min\nTipos - 1min\nErros de compilador - 1min\nReturn - 1min\n\nProtótipos - 2min\nDemo - 4min\nVariáveis globais - 4min\nExercício variáveis globais - 4min\n\n\n\nArrays\n\n\nSlides, PDF\nSlides, extra\nVideos\n\nIntro, criar, mudar - 5min\nArrays e funções - 5min\nDemo exercício salários - 14min\n\n00:00 explicar enunciado\n01:10 inicio da solução\n02:28 função pedir salarios\n04:05 função para mostrar salários\n07:25 função para somar salários\n9:30 função para a média dos salários\n11:56 utilizador indica quantos salários quer introduzir\n\nArrays multi-dimensionais - 4min\nDemo Arrays multi-dimensionais - 10min\n\n0:00 explicação do enunciado\n0:56 inicio do resolução\n\nErros comuns, VLAs - 5min\n\n\n\nStrings\n\n\nVideos\nSlides, PDF\nVideos\n\nIntro - 1min, Loom, Sharepoint\nCriar, inicializar, literal - 5min Loom, Sharepoint\nLer, escrever - 5min, Loom, Sharepoint\nFunções, string.h, Loom, Sharepoint\nDemos\n\n\nDemo - strlen, Loom, Sharepoint\nDemo - strcpy, Loom, Sharepoint\nDemo - strcat, Loom, Sharepoint\nDemo - strcmp, Loom, Sharepoint\n\n\n\nApontadores\n\n\nSlides, PDF\nVideos\n\nIntro, declaração, endereço e desreferenciar - 4min, Loom, Sharepoint\nExemplos - 6min, Loom, Sharepoint\nOperações - 5min, Loom, Sharepoint\nLoom, Apontadores e arrays - 4min, Sharepoint\nApontadores de apontadores - 4min, Loom, Sharepoint\nFunções - passagem por valor vs. referência - 3min, Loom, Sharepoint\nExercício - passagem por valor vs. referência - 2min, Loom, Sharepoint\n\n\n\nStruct\n\n\nSlides, PDF\nVideos\n\nIntro, motivação | 1.5min\nDeclarar, aceder | 4min\nComparação, estruturas dentro de estruturas, funções | 4min\ntypedef | 2min\nestruturas e apontadores | 4min\nDemo 1 | 10min\nDemo 1 | correção de criar_aluno | 3min\nDemo 1a | vector de Aluno | 4min\nDemo 1b\nDemo 1c\nDemo 1d\nDemo 1f\nDemo 1g\n\n\n\nFicheiros\n\n\nSlides, PDF\nVideos\n\nIntro\nFicheiros geral\nFicheiros de texto\nTexto demo\nFicheiros binários\n\nErrata: eu digo que o valor de retorno de fread e fwrite é o número de bytes. Na verdade é o número de items lidos. Só é o número de bytes se o tamanho do item for 1 byte.\n\nBinários demo\n\n\n\nMemória\n\n\nSlides, PDF\nVideos\n\nIntro, Loom, SharePoint\nmalloc, calloc, free, Loom, SharePoint\n\n\n\nEstruturas de Dados Dinâmicas\n\n\nSlides\nDemo lista ligada simples\n\nParte 1 [18min], Loom, Sharepoint\nParte 2 [10min], Loom, Sharepoint\n\n\n\nExtra\nExercícios\n\n\n\n\nLabs 22/23\n\nLab 1\nLab 2\nLab 3\nLab 4\n\n\n\n\nProjectos 22/23\n\nSIGIF\nSIGIT\nSIGA"
  },
  {
    "objectID": "markdown/15_data_structs.html#estruturas-estáticas",
    "href": "markdown/15_data_structs.html#estruturas-estáticas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Estruturas estáticas",
    "text": "Estruturas estáticas\nEstruturas de dados que vimos:\n\narray\nstring (=array)\nstruct\n\n\nEstas estruturas são estáticas, i.e. o seu tamanho é fixo e definido no início.\nint mat[10][10];\nchar frase[200];\nstruct aluno {\n    char nome[50];\n    int nip;\n}"
  },
  {
    "objectID": "markdown/15_data_structs.html#alocação-dinâmica-de-memória",
    "href": "markdown/15_data_structs.html#alocação-dinâmica-de-memória",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Alocação dinâmica de memória",
    "text": "Alocação dinâmica de memória\nCom alocação dinâmica de memória, aprendemos a criar estruturas de dados com um tamanho definido durante a execução do programa.\n// allocate array, vec_size=size of vector\nint * vect = calloc(vec_size, sizeof(int));\n\n// allocate bidimensional array\n// dim1_size = #lines, dim2_size = #cols\nint ** mat = calloc(dim1_size, sizeof(int*));\nfor(int i=0; i&lt;dim1_size; i++)\n    mat[i] = calloc(dim2_size, sizeof(int));"
  },
  {
    "objectID": "markdown/15_data_structs.html#e-as-estruturas-dinâmicas",
    "href": "markdown/15_data_structs.html#e-as-estruturas-dinâmicas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "E as estruturas dinâmicas?",
    "text": "E as estruturas dinâmicas?\nEstas crescem e diminuem conforme adicionamos ou removemos dados.\nAlém disso, a forma de organização e ligação entre os dados permite otimizar o tempo de várias operações ou o espaço ocupado."
  },
  {
    "objectID": "markdown/15_data_structs.html#estruturas-de-dados-dinâmicas",
    "href": "markdown/15_data_structs.html#estruturas-de-dados-dinâmicas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Estruturas de dados dinâmicas",
    "text": "Estruturas de dados dinâmicas\n\nLista ligada simples\nLista duplamente ligada\nFila (queue)\nPilha (stack)\nentre muitas outras…"
  },
  {
    "objectID": "markdown/15_data_structs.html#lista-ligada-simples",
    "href": "markdown/15_data_structs.html#lista-ligada-simples",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\nUm conjunto de elementos ligados não pela sua posição na memória (array), mas por referências explicitas entre elementos."
  },
  {
    "objectID": "markdown/15_data_structs.html#lista-ligada-simples-1",
    "href": "markdown/15_data_structs.html#lista-ligada-simples-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\n\nDiagrama de lista ligada simples\nHEAD aponta para o elemento inicial da lista.\nCada elemento aponta para o elemento seguinte (apontador)."
  },
  {
    "objectID": "markdown/15_data_structs.html#algumas-caracteristicas-12",
    "href": "markdown/15_data_structs.html#algumas-caracteristicas-12",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas caracteristicas 1/2",
    "text": "Algumas caracteristicas 1/2\n\n\nO último elemento aponta sempre para NULL.\n\nSe a lista estiver vazia, HEAD aponta para NULL.\n\nSó podemos percorrer a lista numa direção\nse quisermos o elemento na posição X, temos de percorrer todos os elementos nas posições [0,X["
  },
  {
    "objectID": "markdown/15_data_structs.html#algumas-caracteristicas-22",
    "href": "markdown/15_data_structs.html#algumas-caracteristicas-22",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas caracteristicas 2/2",
    "text": "Algumas caracteristicas 2/2\n\n\nsempre que removemos um elemento da lista, não esquecer de libertar a memória.\nSempre que removemos um elemento\n\nlibertar e memória associada.\nmudar a referência da lista que apontava para esse elemento"
  },
  {
    "objectID": "markdown/15_data_structs.html#lista-ligada-simples-2",
    "href": "markdown/15_data_structs.html#lista-ligada-simples-2",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\nOs elementos de uma lista ligada também são frequentemente denominados por nós.\n\nUm nó pode ser implementado com struct.\nstruct node {\n    int data;\n    struct node * next;\n}\n\n\n\nDiagrama de um nó de lista ligada simples."
  },
  {
    "objectID": "markdown/15_data_structs.html#exemplo",
    "href": "markdown/15_data_structs.html#exemplo",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Exemplo",
    "text": "Exemplo\n\nCriar lista e primeiro nó\n\nstruct node * head;\n\n\nhead = malloc(sizeof(struct node));\nhead-&gt;data = 42;\nhead-&gt;next = NULL;\n\n\nCriar segundo nó\n\nstruct node * b = malloc(sizeof(struct node));\nb-&gt;data = 87;\nb-&gt;next = NULL;\n\n\n\nAdicionar segundo nó à lista\n\n// adicionar b à lista\nhead-&gt;next = b;"
  },
  {
    "objectID": "markdown/15_data_structs.html#algumas-operações-em-listas-ligadas",
    "href": "markdown/15_data_structs.html#algumas-operações-em-listas-ligadas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas operações em listas ligadas",
    "text": "Algumas operações em listas ligadas\n\ninserir novo elemento em determinada posição\neliminar elemento em determinada posição\ntirar elemento de determinada posição\nprocurar nó por valor\ncontar número de nós"
  },
  {
    "objectID": "markdown/15_data_structs.html#demo-implementação",
    "href": "markdown/15_data_structs.html#demo-implementação",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Demo implementação",
    "text": "Demo implementação\n\nGravação em aula\n\nParte 1 [18min], Loom, Sharepoint\nParte 2 [10min], Loom, Sharepoint"
  },
  {
    "objectID": "markdown/15_data_structs.html#lista-duplamente-ligada",
    "href": "markdown/15_data_structs.html#lista-duplamente-ligada",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista duplamente ligada",
    "text": "Lista duplamente ligada\nEm tudo igual à lista ligada simples, mas cada nó aponta para o elemento anterior e para o seguinte.\n\n\n\n\nDiagram de um nó\n\n\n\n\n\n\n\nDiagrama de como os nós se ligam"
  },
  {
    "objectID": "markdown/15_data_structs.html#fila",
    "href": "markdown/15_data_structs.html#fila",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Fila",
    "text": "Fila\n(queue)\n\nParecida com uma lista ligada, mas os elementos são sempre adicionados no fim e retirados do início.\nO primeiro elemento a entrar é o primeiro elemento a sair (FIFO - first in first out)"
  },
  {
    "objectID": "markdown/15_data_structs.html#fila-1",
    "href": "markdown/15_data_structs.html#fila-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Fila",
    "text": "Fila\n\n\n\n\n\nAdicionar um nó\n\n\n\n\n\n\nRemover um nó"
  },
  {
    "objectID": "markdown/15_data_structs.html#pilha",
    "href": "markdown/15_data_structs.html#pilha",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Pilha",
    "text": "Pilha\n(stack)\n\nParecida com uma lista ligada, mas os elementos são sempre adicionados no fim e retirados do fim, ou adicionados no início e retirados do início.\nO último elemento a entrar é o primeiro elemento a sair (LIFO - last in first out)"
  },
  {
    "objectID": "markdown/15_data_structs.html#pilha-1",
    "href": "markdown/15_data_structs.html#pilha-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Pilha",
    "text": "Pilha\n\n\n\n\n\nAdicionar um nó\n\n\n\n\n\n\nRemover um nó"
  },
  {
    "objectID": "markdown/7_basic_types.html#tipos-básicos-do-c",
    "href": "markdown/7_basic_types.html#tipos-básicos-do-c",
    "title": "Tipos básicos do C",
    "section": "Tipos básicos do C",
    "text": "Tipos básicos do C"
  },
  {
    "objectID": "markdown/7_basic_types.html#inteiros",
    "href": "markdown/7_basic_types.html#inteiros",
    "title": "Tipos básicos do C",
    "section": "Inteiros",
    "text": "Inteiros"
  },
  {
    "objectID": "markdown/7_basic_types.html#inteiros-1",
    "href": "markdown/7_basic_types.html#inteiros-1",
    "title": "Tipos básicos do C",
    "section": "Inteiros",
    "text": "Inteiros\nConstantes\nAté agora definimos constantes de inteiros no formato decimal simples, i.e. usando 10 digitos distintos.\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  int v = 42;  // 42 é constante de inteiro\n}"
  },
  {
    "objectID": "markdown/7_basic_types.html#reais",
    "href": "markdown/7_basic_types.html#reais",
    "title": "Tipos básicos do C",
    "section": "Reais",
    "text": "Reais\nfloat\ndouble\nlong double\n–\n\nO long double não aparece porque os intervalos variam bastante de máquina para máquina."
  },
  {
    "objectID": "markdown/7_basic_types.html#texto",
    "href": "markdown/7_basic_types.html#texto",
    "title": "Tipos básicos do C",
    "section": "Texto",
    "text": "Texto\nchar"
  },
  {
    "objectID": "markdown/7_basic_types.html#conversão-de-tipos",
    "href": "markdown/7_basic_types.html#conversão-de-tipos",
    "title": "Tipos básicos do C",
    "section": "Conversão de tipos",
    "text": "Conversão de tipos\n\nNo C, é possível converter de uns tipos para outros.\nNa verdade, nós já usámos esta funcionalidade sem saber, porque existem conversões que são automáticas e implicitas.\nOutras têm de ser explicitamente declaradas."
  },
  {
    "objectID": "markdown/7_basic_types.html#definições-de-tipos",
    "href": "markdown/7_basic_types.html#definições-de-tipos",
    "title": "Tipos básicos do C",
    "section": "Definições de tipos",
    "text": "Definições de tipos\nO C permite a definição de novos tipos com o comando typedef.\ntypedef int Altura;\n\ntypedef é seguido do nome original do tipo\ne depois do novo nome que queremos usar"
  },
  {
    "objectID": "markdown/7_basic_types.html#sizeof",
    "href": "markdown/7_basic_types.html#sizeof",
    "title": "Tipos básicos do C",
    "section": "sizeof",
    "text": "sizeof\nA função sizeof recebe um valor ou um tipo e indica qual é o tamanho, em bytes, que esse tipo ocupa em memória.\nchar c;\nprintf(\"size of int = %lu bytes\\n\", sizeof(int));  // 4\nprintf(\"size of char = %lu bytes\\n\", sizeof(3.14));  // 8 -&gt; double\nprintf(\"size of char = %lu bytes\\n\", sizeof(c));  // 1"
  },
  {
    "objectID": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html",
    "href": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html",
    "title": "Navegação",
    "section": "",
    "text": "Implementa uma função que recebe 2 pontos, (x_1, y_1) e (x_2, y_2), e calcula a magnitude do vector formado por esses dois pontos.\nA função tem o seguinte cabeçalho:\ndouble vec_mag(double x1, double y1, double x2, double y2)\nA magnitude de um vector é dada por \\sqrt((x_2 - x_1)^2 + (y_2 - y_1)^2)\nPode usar as seguintes funções da biblioteca math.h\n\nsqrt calcula a raiz quadrada do argumento\n\ndouble sqrt(double x);\n\npow, devolve a potência da base elevada ao expoente\n\ndouble pow(double x, double y);\n\nEscreve um programa que recebe coordenadas em tempo real.\n\nEstas coordenadas são fornecidas pelas seguintes funções, já implementadas na biblioteca lab1.h:\ndouble get_x();\ndouble get_y();\ndouble get_timestamp();\nint gps_update();\nA função get_x devolve a coordenada no eixo x, em metros;\nA função get_y devolve a coordenada no eixo y, em metros;\nA função get_timestamp devolve uma marca temporal em segundos.\nA função gps_update atualiza o módulo de localização para a leitura seguinte - esta função deve sempre ser chamada entre 2 leituras consecutivas, e devolve -1 se não houverem novas leituras, e.g.\nx = get_x();\ny = get_y();\nt = get_timestamp();\ngps_update();\nnovo_x = get_x();\nnovo_y = get_y();\nnovo_t = get_timestamp();\n\nImplementa um programa que recebe continuamente novas localizações enquanto estas existirem e escreve na consola a marca temporal, x e y de cada coordenada, e.g.\ntimestamp, x, y\n24743, -0.68, 0.72\n24760, -52.44, -19.25\n24776, -124.91, 284.46\n24792, -183.57, 530.38\n24809, -235.90, 758.32\n24825, -283.43, 1053.49\n24842, -341.43, 1274.74\n24859, -430.48, 1479.85\n\n\n\n\n\nNo ciclo anterior, calcula a velocidade actual em m/s\nA velocidade atual é a magnitude do vetor formado pelos pontos da última e penúltimas coordenadas, a dividir pelo tempo que passou entre essas 2 leituras (isto é, a diferença entre as duas últimas marcas temporais em segundos)\nEscreve na consola, para cada coordenada recebida, a velocidade actual.\nNa primeira coordenada não é possível calcular a velocidade.\nRecebe primeira uma coordenada e começa a calcular a velocidade a partir da segunda.\nImplementa esta funcionalidade na main.\n\n\n\n\n\nNo ciclo anterior, escreve na consola a distância em kilometros entre a posição actual e o destino.\nA coordenada destino é dada pelas variáveis globais target_x e target_y\nA distância é a magnitude do vector formado entre a coordenada actual e coordenada destino.\nLembra-te que as coordenadas estão em metros, é necessária a conversão ou das coordenadas ou da distância para kilometros.\n\n\n\n\n\nEscreve na consola o erro angular entre o rumo actual e o rumo directo ao destino.\nO rumo atual é o ângulo do vetor formado pelos pontos da última e penúltimas coordnadas\nPara calcular o erro angular, deve-se primeiro calcular o ângulo do vetor formado pelos pontos da última coordenada e a coordenada destino. Depois é necessário verificar a diferença entre esse ângulo e o rumo atual.\nUsa a função vec_ang para calcular o ângulo do vector\n\na função vec_ang recebe 1 vetor (na forma de 2 pontos, tal como vec_mag) e devolve o seu ângulo"
  },
  {
    "objectID": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-1---magnitude-de-vector---20",
    "href": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-1---magnitude-de-vector---20",
    "title": "Navegação",
    "section": "",
    "text": "Implementa uma função que recebe 2 pontos, (x_1, y_1) e (x_2, y_2), e calcula a magnitude do vector formado por esses dois pontos.\nA função tem o seguinte cabeçalho:\ndouble vec_mag(double x1, double y1, double x2, double y2)\nA magnitude de um vector é dada por \\sqrt((x_2 - x_1)^2 + (y_2 - y_1)^2)\nPode usar as seguintes funções da biblioteca math.h\n\nsqrt calcula a raiz quadrada do argumento\n\ndouble sqrt(double x);\n\npow, devolve a potência da base elevada ao expoente\n\ndouble pow(double x, double y);\n\nEscreve um programa que recebe coordenadas em tempo real.\n\nEstas coordenadas são fornecidas pelas seguintes funções, já implementadas na biblioteca lab1.h:\ndouble get_x();\ndouble get_y();\ndouble get_timestamp();\nint gps_update();\nA função get_x devolve a coordenada no eixo x, em metros;\nA função get_y devolve a coordenada no eixo y, em metros;\nA função get_timestamp devolve uma marca temporal em segundos.\nA função gps_update atualiza o módulo de localização para a leitura seguinte - esta função deve sempre ser chamada entre 2 leituras consecutivas, e devolve -1 se não houverem novas leituras, e.g.\nx = get_x();\ny = get_y();\nt = get_timestamp();\ngps_update();\nnovo_x = get_x();\nnovo_y = get_y();\nnovo_t = get_timestamp();\n\nImplementa um programa que recebe continuamente novas localizações enquanto estas existirem e escreve na consola a marca temporal, x e y de cada coordenada, e.g.\ntimestamp, x, y\n24743, -0.68, 0.72\n24760, -52.44, -19.25\n24776, -124.91, 284.46\n24792, -183.57, 530.38\n24809, -235.90, 758.32\n24825, -283.43, 1053.49\n24842, -341.43, 1274.74\n24859, -430.48, 1479.85"
  },
  {
    "objectID": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-3---calcula-velocidade-actual---20",
    "href": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-3---calcula-velocidade-actual---20",
    "title": "Navegação",
    "section": "",
    "text": "No ciclo anterior, calcula a velocidade actual em m/s\nA velocidade atual é a magnitude do vetor formado pelos pontos da última e penúltimas coordenadas, a dividir pelo tempo que passou entre essas 2 leituras (isto é, a diferença entre as duas últimas marcas temporais em segundos)\nEscreve na consola, para cada coordenada recebida, a velocidade actual.\nNa primeira coordenada não é possível calcular a velocidade.\nRecebe primeira uma coordenada e começa a calcular a velocidade a partir da segunda.\nImplementa esta funcionalidade na main."
  },
  {
    "objectID": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-4---distância-ao-destino---10",
    "href": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-4---distância-ao-destino---10",
    "title": "Navegação",
    "section": "",
    "text": "No ciclo anterior, escreve na consola a distância em kilometros entre a posição actual e o destino.\nA coordenada destino é dada pelas variáveis globais target_x e target_y\nA distância é a magnitude do vector formado entre a coordenada actual e coordenada destino.\nLembra-te que as coordenadas estão em metros, é necessária a conversão ou das coordenadas ou da distância para kilometros."
  },
  {
    "objectID": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-5---erro-angular---10",
    "href": "markdown/labs/2223/lab1_funcoes/lab1_navigation.html#parte-5---erro-angular---10",
    "title": "Navegação",
    "section": "",
    "text": "Escreve na consola o erro angular entre o rumo actual e o rumo directo ao destino.\nO rumo atual é o ângulo do vetor formado pelos pontos da última e penúltimas coordnadas\nPara calcular o erro angular, deve-se primeiro calcular o ângulo do vetor formado pelos pontos da última coordenada e a coordenada destino. Depois é necessário verificar a diferença entre esse ângulo e o rumo atual.\nUsa a função vec_ang para calcular o ângulo do vector\n\na função vec_ang recebe 1 vetor (na forma de 2 pontos, tal como vec_mag) e devolve o seu ângulo"
  },
  {
    "objectID": "markdown/labs/2223/lab2_array/lab2_stats.html",
    "href": "markdown/labs/2223/lab2_array/lab2_stats.html",
    "title": "Laboratório 2 - Medidas estatisticas",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resoluçã dos laboratório é individual.\nNo final, submeter a solução no replit.\n\n\n\n\n\nEscreve uma função que recebe um vector de reais e devolve a média.\n\n\n\n\n\nEscreve uma função que recebe um vector de reais.\nA função devolve o desvio padrão dos valores do vector.\nO desvio padrão é dado por \\sqrt{\\frac{\\sum(x_i - \\mu)^2}{N}}\n\nN é o tamanho do vector\nx_i são os valores do vector\n\\mu é a média do vector\n\nPode usar a função da parte 1 para calcular a média.\n\n\nSe não fez a parte 1, use a função como se a tivesse resolvido, chamando a seguinte função:\nmedia(10, vec) calcularia a média de um vector chamado vec de tamanho 10.\n\n\nPode usar as seguintes funções da biblioteca math.h\n\nsqrt calcula a raiz quadrada do argumento\n\ndouble sqrt(double x);\n\npow, devolve a potência da base x elevada ao expoente y\n\ndouble pow(double x, double y);\n\n\n\n\n\nEscreve um programa que pede ao utilizador quantos valores reais quer introduzir.\nO programa cria um vector cujo tamanho é o número de valores que o utilizador quer introduzir.\nPosteriormente, pede ao utilizador esses valores e grava-os.\nNo final, o programa usa as funções da parte 1 e 2 para calcular a média e o desvio padrão e mostra-os na consola.\nSe não fez as partes 1 e/ou 2, use as funções como se as tivesse resolvido, chamando as seguintes funções como se tivessem implementadas:\n\nmedia(10, vec) calcularia a média de um vector chamado vec de tamanho 10.\nstd(10, vec) calcularia o desvio padrão de um vector chamado vec de tamanho 10."
  },
  {
    "objectID": "markdown/labs/2223/lab2_array/lab2_stats.html#notas",
    "href": "markdown/labs/2223/lab2_array/lab2_stats.html#notas",
    "title": "Laboratório 2 - Medidas estatisticas",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resoluçã dos laboratório é individual.\nNo final, submeter a solução no replit."
  },
  {
    "objectID": "markdown/labs/2223/lab2_array/lab2_stats.html#parte-1-20",
    "href": "markdown/labs/2223/lab2_array/lab2_stats.html#parte-1-20",
    "title": "Laboratório 2 - Medidas estatisticas",
    "section": "",
    "text": "Escreve uma função que recebe um vector de reais e devolve a média."
  },
  {
    "objectID": "markdown/labs/2223/lab2_array/lab2_stats.html#parte-2-35",
    "href": "markdown/labs/2223/lab2_array/lab2_stats.html#parte-2-35",
    "title": "Laboratório 2 - Medidas estatisticas",
    "section": "",
    "text": "Escreve uma função que recebe um vector de reais.\nA função devolve o desvio padrão dos valores do vector.\nO desvio padrão é dado por \\sqrt{\\frac{\\sum(x_i - \\mu)^2}{N}}\n\nN é o tamanho do vector\nx_i são os valores do vector\n\\mu é a média do vector\n\nPode usar a função da parte 1 para calcular a média.\n\n\nSe não fez a parte 1, use a função como se a tivesse resolvido, chamando a seguinte função:\nmedia(10, vec) calcularia a média de um vector chamado vec de tamanho 10.\n\n\nPode usar as seguintes funções da biblioteca math.h\n\nsqrt calcula a raiz quadrada do argumento\n\ndouble sqrt(double x);\n\npow, devolve a potência da base x elevada ao expoente y\n\ndouble pow(double x, double y);"
  },
  {
    "objectID": "markdown/labs/2223/lab2_array/lab2_stats.html#parte-3-45",
    "href": "markdown/labs/2223/lab2_array/lab2_stats.html#parte-3-45",
    "title": "Laboratório 2 - Medidas estatisticas",
    "section": "",
    "text": "Escreve um programa que pede ao utilizador quantos valores reais quer introduzir.\nO programa cria um vector cujo tamanho é o número de valores que o utilizador quer introduzir.\nPosteriormente, pede ao utilizador esses valores e grava-os.\nNo final, o programa usa as funções da parte 1 e 2 para calcular a média e o desvio padrão e mostra-os na consola.\nSe não fez as partes 1 e/ou 2, use as funções como se as tivesse resolvido, chamando as seguintes funções como se tivessem implementadas:\n\nmedia(10, vec) calcularia a média de um vector chamado vec de tamanho 10.\nstd(10, vec) calcularia o desvio padrão de um vector chamado vec de tamanho 10."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3.html",
    "href": "markdown/labs/2223/lab3_file_struct/lab3.html",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no replit.\n\n\n\n\n\nPara a resolução deste laboratório considera a seguinte struct\ntypedef struct {\n  int id;\n  char cidade[50];\n  char nome[50];\n} Estudante;\nCopia a definição deste tipo para a tua solução.\n\n\n\n\n\nEscreve uma função que recebe o nome de um ficheiro binário, um vetor de Estudante e número máximo de Estudante a ler do ficheiro.\nImplementa a função os dados de Estudante existentes no ficheiro binário. Nunca podem ser lidos mais que o número máximo recebido como argumento da função.\nA função devolve o número de estudantes (int) efetivamente lido.\n\n\n\n\n\nEscreve uma função que recebe:\n\num vetor de Estudante\nnúmero de elementos do vetor que está preenchido (usar vetor de tamanho variável nos argumentos).\numa string com o nome de uma cidade\n\nA função cria um ficheiro de texto com o nome da cidade recebida, terminado por “.txt”, e.g. “Lisboa.txt”.\n\nPodes usar a função strcat da biblioteca string.h para concatenar 2 strings, e.g.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n  char str1[100] = \"Hello \";\n  char str2[100] = \"world!\";\n  char result[100];\n\n  strcpy(result, str1);\n  strcat(result, str2);  // tem a str1 seguida da str2\n\n  printf(\"%s\", result);\n  return 0;\n}\nA função escreve no ficheiro de texto os dados de todos os alunos que pertencem à cidade recebida, um por linha, no formato id nome, e.g.\n1743 Silva\n1755 Ramos\n1733 Veríssimo\nA função devolve o número de estudantes (int) guardados no ficheiro.\n\n\n\n\n\nEscreve a função main que cria um vetor de 200 Estudante.\nAdiciona à função main o seguinte vetor de cidades a procurar.\nchar cidades[5][50] = {\n  \"Lisboa\",\n  \"Porto\",\n  \"Coimbra\",\n  \"Braga\",\n  \"Funchal\"\n};\nO programa usa a função da parte 1 para ler os dados dos estudantes contidos no ficheiro binário estudantes.bd e guardá-los no vetor estudantes. O número máximo de estudantes a ler é o tamanho do vetor.\n\nFicheiro acessível neste link.\n\nPara cada cidade no vetor cidades, o programa cria um ficheiro de texto com os alunos pertencentes a essa cidade com a função da parte 2. Nota que tens de passar o número de elementos que efetivamente existem no vetor (que pode ser diferente do tamanho total do vetor)."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3.html#notas",
    "href": "markdown/labs/2223/lab3_file_struct/lab3.html#notas",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no replit."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3.html#setup",
    "href": "markdown/labs/2223/lab3_file_struct/lab3.html#setup",
    "title": "Programação",
    "section": "",
    "text": "Para a resolução deste laboratório considera a seguinte struct\ntypedef struct {\n  int id;\n  char cidade[50];\n  char nome[50];\n} Estudante;\nCopia a definição deste tipo para a tua solução."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3.html#parte-1---ler-base-de-dados-20",
    "href": "markdown/labs/2223/lab3_file_struct/lab3.html#parte-1---ler-base-de-dados-20",
    "title": "Programação",
    "section": "",
    "text": "Escreve uma função que recebe o nome de um ficheiro binário, um vetor de Estudante e número máximo de Estudante a ler do ficheiro.\nImplementa a função os dados de Estudante existentes no ficheiro binário. Nunca podem ser lidos mais que o número máximo recebido como argumento da função.\nA função devolve o número de estudantes (int) efetivamente lido."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3.html#parte-2---filtro-por-localidade-50",
    "href": "markdown/labs/2223/lab3_file_struct/lab3.html#parte-2---filtro-por-localidade-50",
    "title": "Programação",
    "section": "",
    "text": "Escreve uma função que recebe:\n\num vetor de Estudante\nnúmero de elementos do vetor que está preenchido (usar vetor de tamanho variável nos argumentos).\numa string com o nome de uma cidade\n\nA função cria um ficheiro de texto com o nome da cidade recebida, terminado por “.txt”, e.g. “Lisboa.txt”.\n\nPodes usar a função strcat da biblioteca string.h para concatenar 2 strings, e.g.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n  char str1[100] = \"Hello \";\n  char str2[100] = \"world!\";\n  char result[100];\n\n  strcpy(result, str1);\n  strcat(result, str2);  // tem a str1 seguida da str2\n\n  printf(\"%s\", result);\n  return 0;\n}\nA função escreve no ficheiro de texto os dados de todos os alunos que pertencem à cidade recebida, um por linha, no formato id nome, e.g.\n1743 Silva\n1755 Ramos\n1733 Veríssimo\nA função devolve o número de estudantes (int) guardados no ficheiro."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3.html#parte-3---integração-30",
    "href": "markdown/labs/2223/lab3_file_struct/lab3.html#parte-3---integração-30",
    "title": "Programação",
    "section": "",
    "text": "Escreve a função main que cria um vetor de 200 Estudante.\nAdiciona à função main o seguinte vetor de cidades a procurar.\nchar cidades[5][50] = {\n  \"Lisboa\",\n  \"Porto\",\n  \"Coimbra\",\n  \"Braga\",\n  \"Funchal\"\n};\nO programa usa a função da parte 1 para ler os dados dos estudantes contidos no ficheiro binário estudantes.bd e guardá-los no vetor estudantes. O número máximo de estudantes a ler é o tamanho do vetor.\n\nFicheiro acessível neste link.\n\nPara cada cidade no vetor cidades, o programa cria um ficheiro de texto com os alunos pertencentes a essa cidade com a função da parte 2. Nota que tens de passar o número de elementos que efetivamente existem no vetor (que pode ser diferente do tamanho total do vetor)."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3v2.html",
    "href": "markdown/labs/2223/lab3_file_struct/lab3v2.html",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no Replit.\n\n\n\n\n\nPara a resolução deste laboratório considera a seguinte struct de um Carro:\ntypedef struct {\n  char marca[50];\n  int ano;\n  float km;\n} Carro;\nCopia a definição deste tipo para a tua solução.\nNo Replit, cria um ficheiro de texto chamado carros.txt com o seguinte conteúdo:\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\n\n\n\n\n\nEscreve uma função que recebe o nome de um ficheiro de texto, um vetor de Carro chamado carros e número máximo de Carro a ler do ficheiro.\nA função lê os dados do ficheiro de texto e guarda-os no vetor carros.\nA função devolve o número de carros (int) lidos (que pode ser menor, mas nunca superior, ao número máximo de carros a ler).\n\n\n\n\n\nEscreve uma função que recebe:\n\num vetor de Carro\nnúmero de elementos do vetor que está preenchido (usar vetor de tamanho variável nos argumentos).\numa string com o nome de uma marca\n\nA função cria um ficheiro binário com o nome da marca recebida, terminado por “.bin”, e.g. “BMW.bin”.\n\nPodes usar a função strcat da biblioteca string.h para concatenar 2 strings, e.g.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n  char str1[100] = \"Hello \";\n  char str2[100] = \"world!\";\n  char result[100];\n\n  strcpy(result, str1);\n  strcat(result, str2);  // tem a str1 seguida da str2\n\n  printf(\"%s\", result);\n  return 0;\n}\nA função escreve no ficheiro binários os dados de todos os carros que da marca recebida.\nA função devolve o número de carros (int) guardados no ficheiro.\n\n\n\n\n\nEscreve a função main que cria um vetor de 200 Carro.\nAdiciona à função main o seguinte vetor de marcas.\nchar marcas[2][50] = {\n  \"BMW\",\n  \"Fiat\",\n};\nO programa usa a função da parte 1 para ler os dados dos carros contidos no ficheiro carros.txt e guardá-los no vetor criado. O número máximo de carros a ler é o tamanho do vetor.\nPara cada marca no vetor marcas, o programa cria um ficheiro binário com os carros que têm essa marca com a função da parte 2. Nota que tens de passar o número de elementos que efetivamente existem no vetor (que pode ser diferente do tamanho total do vetor)."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3v2.html#notas",
    "href": "markdown/labs/2223/lab3_file_struct/lab3v2.html#notas",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no Replit."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3v2.html#setup",
    "href": "markdown/labs/2223/lab3_file_struct/lab3v2.html#setup",
    "title": "Programação",
    "section": "",
    "text": "Para a resolução deste laboratório considera a seguinte struct de um Carro:\ntypedef struct {\n  char marca[50];\n  int ano;\n  float km;\n} Carro;\nCopia a definição deste tipo para a tua solução.\nNo Replit, cria um ficheiro de texto chamado carros.txt com o seguinte conteúdo:\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0\nBMW 2018 30000.0\nFiat 2010 10000.0\nMercedes 2015 20000.0"
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3v2.html#parte-1---importar-de-ficheiro-de-texto-35",
    "href": "markdown/labs/2223/lab3_file_struct/lab3v2.html#parte-1---importar-de-ficheiro-de-texto-35",
    "title": "Programação",
    "section": "",
    "text": "Escreve uma função que recebe o nome de um ficheiro de texto, um vetor de Carro chamado carros e número máximo de Carro a ler do ficheiro.\nA função lê os dados do ficheiro de texto e guarda-os no vetor carros.\nA função devolve o número de carros (int) lidos (que pode ser menor, mas nunca superior, ao número máximo de carros a ler)."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3v2.html#parte-2---filtro-por-marca-35",
    "href": "markdown/labs/2223/lab3_file_struct/lab3v2.html#parte-2---filtro-por-marca-35",
    "title": "Programação",
    "section": "",
    "text": "Escreve uma função que recebe:\n\num vetor de Carro\nnúmero de elementos do vetor que está preenchido (usar vetor de tamanho variável nos argumentos).\numa string com o nome de uma marca\n\nA função cria um ficheiro binário com o nome da marca recebida, terminado por “.bin”, e.g. “BMW.bin”.\n\nPodes usar a função strcat da biblioteca string.h para concatenar 2 strings, e.g.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n  char str1[100] = \"Hello \";\n  char str2[100] = \"world!\";\n  char result[100];\n\n  strcpy(result, str1);\n  strcat(result, str2);  // tem a str1 seguida da str2\n\n  printf(\"%s\", result);\n  return 0;\n}\nA função escreve no ficheiro binários os dados de todos os carros que da marca recebida.\nA função devolve o número de carros (int) guardados no ficheiro."
  },
  {
    "objectID": "markdown/labs/2223/lab3_file_struct/lab3v2.html#parte-3---integração-30",
    "href": "markdown/labs/2223/lab3_file_struct/lab3v2.html#parte-3---integração-30",
    "title": "Programação",
    "section": "",
    "text": "Escreve a função main que cria um vetor de 200 Carro.\nAdiciona à função main o seguinte vetor de marcas.\nchar marcas[2][50] = {\n  \"BMW\",\n  \"Fiat\",\n};\nO programa usa a função da parte 1 para ler os dados dos carros contidos no ficheiro carros.txt e guardá-los no vetor criado. O número máximo de carros a ler é o tamanho do vetor.\nPara cada marca no vetor marcas, o programa cria um ficheiro binário com os carros que têm essa marca com a função da parte 2. Nota que tens de passar o número de elementos que efetivamente existem no vetor (que pode ser diferente do tamanho total do vetor)."
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no replit.\n\n\n\n\n\nImplementa a função addEstudante que recebe uma lista ligada de Estudante e um Estudante para adicionar.\nA função cria um novo nó na lista com os dados do Estudante recebido.\nNota: se não conseguires implementar esta função, tenta implementar a mesma funcionalidade diretamente na main.\n\n\n\n\n\nImplementa a função printEstudantes que recebe uma lista ligada de Estudante e escreve na consola todos os elementos da lista.\nUsa a função printEstudante para escrever na consola cada um dos elementos da lista.\n\n\n\n\n\nEscreve a função main de modo a que:\n\no programa receba um vetor de n estudantes com dados aleatórios\n\nusa a função createEstudantes para este efeito\n\ncrie uma lista ligada de Estudante\nadicione cada um dos estudantes do vetor à lista ligada (addEstudante)\nliberte a memória do vetor\nescreva na consola todos os elementos da lista ligada (printEstudantes)\n\n\n\n\n\n\nModifica a função main de modo a que, no final:\n\nelimina da lista ligada todos os estudantes com média inferior a 17\n\npara cada estudante removido, escrever na consola removido estudante &lt;nome&gt; com media &lt;media_final&gt;\n\nescreve na consola os alunos do quadro de honra (média &gt;= 17) (printEstudantes)\n\n\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * ESTRUTURAS *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\ntypedef struct {\n    int id;\n    char nome[50];\n    float media_final;\n} Estudante;\n\n\n\n// linked list node of type Estudante\ntypedef struct node {\n    Estudante estudante;\n    struct node *next;\n} Node;\n\n\n// function to print a Estudante pointer\nvoid printEstudante(Estudante *estudante) {\n    printf(\"ID: %d\\n\", estudante-&gt;id);\n    printf(\"Nome: %s\\n\", estudante-&gt;nome);\n    printf(\"Media Final: %.2f\\n\", estudante-&gt;media_final);\n}\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * MOCK DATA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n\n// array of 20 porguese first names\nchar *nomes_proprios[] = {\n    \"Maria\",\n    \"Joao\",\n    \"Ana\",\n    \"Pedro\",\n    \"Carla\",\n    \"Jose\",\n    \"Margarida\",\n    \"Miguel\",\n    \"Sofia\",\n    \"Ricardo\",\n    \"Ines\",\n    \"Paulo\",\n    \"Beatriz\",\n    \"Tiago\",\n    \"Catarina\",\n    \"Andre\",\n    \"Filipa\",\n    \"Bruno\",\n    \"Diana\",\n    \"Rui\"\n};\n\n// array of 20 portuguese last names\nchar *apelidos[] = {\n    \"Silva\",\n    \"Santos\",\n    \"Rodrigues\",\n    \"Costa\",\n    \"Oliveira\",\n    \"Martins\",\n    \"Ferreira\",\n    \"Pereira\",\n    \"Carvalho\",\n    \"Marques\",\n    \"Gomes\",\n    \"Sousa\",\n    \"Fernandes\",\n    \"Goncalves\",\n    \"Ribeiro\",\n    \"Leal\",\n    \"Faria\",\n    \"Henriques\",\n    \"Neves\",\n    \"Oliveira\"\n};\n\n\n\n\n\nEstudante *createEstudantes(unsigned int n) {\n    Estudante *estudantes = malloc(n * sizeof(Estudante));\n    for (int i = 0; i &lt; n; i++) {\n        estudantes[i].id = 1400 + i;\n        int rand_nome = rand() % 20;\n        int rand_apelido = rand() % 20;\n        sprintf(estudantes[i].nome, \"%s %s\", nomes_proprios[rand_nome], apelidos[rand_apelido]);\n        estudantes[i].media_final = 5 + rand() % 16;\n    }\n    return estudantes;\n}\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * LISTA LIGADA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n// function to add estudante to list\nvoid addEstudante(Node **head, Estudante estudante) {\n}\n\n\n// function to print a linked list of Estudante\nvoid printEstudantes(Node *head) {\n}\n\n\nint main(){\n    // podes alterar este valor para testar com arrays de tamanhos diferentes\n    int n_estudantes = 10;\n\n    // receber array de Estudantes aleatórios, com a função createEstudantes\n    \n\n    // criar lista ligada\n    \n\n    // adicionar todos os Estudante do array à lista ligada\n    \n\n    // libertar array de Estudante da memória\n\n    // escrever na consola todos os Estudante da lista ligada\n\n    // eliminar da lista ligada todos os Estudante com media_final &lt; 17\n    //     para cada estudante removido, escrever na consola \"removido estudante &lt;nome&gt; com media &lt;media_final&gt;\"\n\n\n    // imprimir quadro de honra (todos os alunos com média final &gt;= 17, i.e. os alunos que ficaram na lista ligada)\n    printf(\"\\nQuadro de Honra:\\n\");\n    // ...\n\n\n}\n\n\n\nSe ajudar, podes criar outra estrutura de dados para ter a cabeça da lista ligada e modificar as funções para receber uma lsita desse tipo, e.g.\n\ntypedef struct {\n    Node * head;\n} Lista;\n\nvoid addEstudante(Lista * lista, Estudante estudante) {\n\n}\n\n\n// function to print a linked list of Estudante\nvoid printEstudantes(Lista * lista) {\n}"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#notas",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#notas",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no replit."
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-1---adicionar-um-nó-a-lista-ligada-30",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-1---adicionar-um-nó-a-lista-ligada-30",
    "title": "Programação",
    "section": "",
    "text": "Implementa a função addEstudante que recebe uma lista ligada de Estudante e um Estudante para adicionar.\nA função cria um novo nó na lista com os dados do Estudante recebido.\nNota: se não conseguires implementar esta função, tenta implementar a mesma funcionalidade diretamente na main."
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-2---escrever-todos-os-elementos-de-lista-ligada-20",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-2---escrever-todos-os-elementos-de-lista-ligada-20",
    "title": "Programação",
    "section": "",
    "text": "Implementa a função printEstudantes que recebe uma lista ligada de Estudante e escreve na consola todos os elementos da lista.\nUsa a função printEstudante para escrever na consola cada um dos elementos da lista."
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-3---integração-30",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-3---integração-30",
    "title": "Programação",
    "section": "",
    "text": "Escreve a função main de modo a que:\n\no programa receba um vetor de n estudantes com dados aleatórios\n\nusa a função createEstudantes para este efeito\n\ncrie uma lista ligada de Estudante\nadicione cada um dos estudantes do vetor à lista ligada (addEstudante)\nliberte a memória do vetor\nescreva na consola todos os elementos da lista ligada (printEstudantes)"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-4---filtro-20",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#parte-4---filtro-20",
    "title": "Programação",
    "section": "",
    "text": "Modifica a função main de modo a que, no final:\n\nelimina da lista ligada todos os estudantes com média inferior a 17\n\npara cada estudante removido, escrever na consola removido estudante &lt;nome&gt; com media &lt;media_final&gt;\n\nescreve na consola os alunos do quadro de honra (média &gt;= 17) (printEstudantes)"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#código-inicial",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#código-inicial",
    "title": "Programação",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * ESTRUTURAS *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\ntypedef struct {\n    int id;\n    char nome[50];\n    float media_final;\n} Estudante;\n\n\n\n// linked list node of type Estudante\ntypedef struct node {\n    Estudante estudante;\n    struct node *next;\n} Node;\n\n\n// function to print a Estudante pointer\nvoid printEstudante(Estudante *estudante) {\n    printf(\"ID: %d\\n\", estudante-&gt;id);\n    printf(\"Nome: %s\\n\", estudante-&gt;nome);\n    printf(\"Media Final: %.2f\\n\", estudante-&gt;media_final);\n}\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * MOCK DATA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n\n// array of 20 porguese first names\nchar *nomes_proprios[] = {\n    \"Maria\",\n    \"Joao\",\n    \"Ana\",\n    \"Pedro\",\n    \"Carla\",\n    \"Jose\",\n    \"Margarida\",\n    \"Miguel\",\n    \"Sofia\",\n    \"Ricardo\",\n    \"Ines\",\n    \"Paulo\",\n    \"Beatriz\",\n    \"Tiago\",\n    \"Catarina\",\n    \"Andre\",\n    \"Filipa\",\n    \"Bruno\",\n    \"Diana\",\n    \"Rui\"\n};\n\n// array of 20 portuguese last names\nchar *apelidos[] = {\n    \"Silva\",\n    \"Santos\",\n    \"Rodrigues\",\n    \"Costa\",\n    \"Oliveira\",\n    \"Martins\",\n    \"Ferreira\",\n    \"Pereira\",\n    \"Carvalho\",\n    \"Marques\",\n    \"Gomes\",\n    \"Sousa\",\n    \"Fernandes\",\n    \"Goncalves\",\n    \"Ribeiro\",\n    \"Leal\",\n    \"Faria\",\n    \"Henriques\",\n    \"Neves\",\n    \"Oliveira\"\n};\n\n\n\n\n\nEstudante *createEstudantes(unsigned int n) {\n    Estudante *estudantes = malloc(n * sizeof(Estudante));\n    for (int i = 0; i &lt; n; i++) {\n        estudantes[i].id = 1400 + i;\n        int rand_nome = rand() % 20;\n        int rand_apelido = rand() % 20;\n        sprintf(estudantes[i].nome, \"%s %s\", nomes_proprios[rand_nome], apelidos[rand_apelido]);\n        estudantes[i].media_final = 5 + rand() % 16;\n    }\n    return estudantes;\n}\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * LISTA LIGADA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n// function to add estudante to list\nvoid addEstudante(Node **head, Estudante estudante) {\n}\n\n\n// function to print a linked list of Estudante\nvoid printEstudantes(Node *head) {\n}\n\n\nint main(){\n    // podes alterar este valor para testar com arrays de tamanhos diferentes\n    int n_estudantes = 10;\n\n    // receber array de Estudantes aleatórios, com a função createEstudantes\n    \n\n    // criar lista ligada\n    \n\n    // adicionar todos os Estudante do array à lista ligada\n    \n\n    // libertar array de Estudante da memória\n\n    // escrever na consola todos os Estudante da lista ligada\n\n    // eliminar da lista ligada todos os Estudante com media_final &lt; 17\n    //     para cada estudante removido, escrever na consola \"removido estudante &lt;nome&gt; com media &lt;media_final&gt;\"\n\n\n    // imprimir quadro de honra (todos os alunos com média final &gt;= 17, i.e. os alunos que ficaram na lista ligada)\n    printf(\"\\nQuadro de Honra:\\n\");\n    // ...\n\n\n}"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#ajuda",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4.html#ajuda",
    "title": "Programação",
    "section": "",
    "text": "Se ajudar, podes criar outra estrutura de dados para ter a cabeça da lista ligada e modificar as funções para receber uma lsita desse tipo, e.g.\n\ntypedef struct {\n    Node * head;\n} Lista;\n\nvoid addEstudante(Lista * lista, Estudante estudante) {\n\n}\n\n\n// function to print a linked list of Estudante\nvoid printEstudantes(Lista * lista) {\n}"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no replit.\n\n\n\n\n\nImplementa a função addAeronave que recebe uma lista ligada de Aeronave e um Aeronave para adicionar.\nA função cria um novo nó na lista com os dados do Aeronave recebido.\nNota: se não conseguires implementar esta função, tenta implementar a mesma funcionalidade diretamente na main.\n\n\n\n\n\nImplementa a função printAeronaves que recebe uma lista ligada de Aeronave e escreve na consola todos os elementos da lista.\nUsa a função printAeronave para escrever na consola cada um dos elementos da lista.\n\n\n\n\n\nEscreve a função main de modo a que:\n\no programa receba um vetor de n aeronaves com dados aleatórios\n\nusa a função createAeronaves para este efeito\n\ncrie uma lista ligada de Aeronave\nadicione cada um das aeronaves do vetor à lista ligada (addAeronave)\nliberte a memória do vetor\nescreva na consola todos os elementos da lista ligada (printAeronaves)\n\n\n\n\n\n\nModifica a função main de modo a que, no final:\n\nelimina da lista ligada todos as aeronaves com ano de fabrico superior a 2000\n\npara cada aeronave removido, escreve na consola “removida aeronave com número de cauda ”\n\nescreve na consola todas as aeronaves com ano inferior ou igual a 2000 (printAeronaves)\n\n\n\n\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * ESTRUTURAS *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n\n// struct para Aeronave\ntypedef struct {\n    char fabricante[20];\n    int n_cauda;\n    int ano_fabrico;\n} Aeronave;\n\n// linked list node of type Aeronave\ntypedef struct node {\n    Aeronave aeroanve;\n    struct node *next;\n} Node;\n\n// function to print a Aeronave pointer\nvoid printAeronave(Aeronave *aeronave) {\n    printf(\"Aeronave: %s, %d, %d\\n\", aeronave-&gt;fabricante, aeronave-&gt;n_cauda, aeronave-&gt;ano_fabrico);\n}\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * MOCK DATA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n// array of 20 aircraft makers\nchar *fabricantes[] = {\n    \"Boeing\",\n    \"Airbus\",\n    \"Embraer\",\n    \"Bombardier\",\n    \"Cessna\",\n    \"Dassault\",\n    \"Gulfstream\",\n    \"Pilatus\",\n    \"Beechcraft\",\n    \"Lockheed\",\n    \"Saab\",\n    \"Sukhoi\",\n    \"Antonov\",\n    \"Tupolev\",\n    \"Ilyushin\",\n    \"Yakovlev\",\n    \"Aero\",\n    \"Fokker\",\n    \"McDonnell Douglas\",\n    \"Lockheed Martin\",\n};\n\n\n\n// function createAeronaves receives an unsigned int n and returns a pointer to an array of n Aeronaves\nAeronave *createAeronaves(unsigned int n) {\n    Aeronave *aeronaves = malloc(n * sizeof(Aeronave));\n    for (int i = 0; i &lt; n; i++) {\n        int rand_fabricante = rand() % 20;\n        strcpy(aeronaves[i].fabricante, fabricantes[rand_fabricante]);\n        aeronaves[i].n_cauda = 1000 + i;\n        aeronaves[i].ano_fabrico = 1990 + rand() % 30;\n    }\n    return aeronaves;\n}\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * LISTA LIGADA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n// function to add aeronave to list\nvoid addAeronave(Node **head, Aeronave aeronave) {\n}\n\n\n// function to print a linked list of Aeronave\nvoid printAeronaves(Node *head) {\n}\n\n\nint main(){\n    // podes alterar este valor para testar com arrays de tamanhos diferentes\n    int n_aeronaves = 10;\n\n    // receber array de Aeronaves aleatórios, com a função createAeronaves\n    \n\n    // criar lista ligada\n    \n\n    // adicionar todos os Aeronave do array à lista ligada\n    \n\n    // libertar array de Aeronave da memória\n\n    // escrever na consola todos os Aeronave da lista ligada\n\n    // eliminar da lista ligada todos os Aeronave com ano de fabrico superior a 2000\n    //     para cada Aeronave removido, escrever na consola \"removida aeronave com número de cauda &lt;n_cauda&gt; do fabricante &lt;fabricante&gt;\"\n\n\n    // imprimir novamente a lista ligada com as aeronaves sobrantes\n\n\n}\n\n\n\nSe ajudar, podes criar outra estrutura de dados para ter a cabeça da lista ligada e modificar as funções para receber uma lsita desse tipo, e.g.\n\ntypedef struct {\n    Node * head;\n} Lista;\n\nvoid addAeronave(Lista * lista, Aeronave aeronave) {\n\n}\n\n\n// function to print a linked list of Aeronave\nvoid printAeronaves(Lista * lista) {\n}"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#notas",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#notas",
    "title": "Programação",
    "section": "",
    "text": "Apenas é permitido o uso do computador para\n\naceder ao replit.com (para resolução do laboratório)\naceder ao conteúdo das aulas e exercícios passados\naceder aos livros da bibliografia\n\nA resolução dos laboratório é individual.\nNo final, submeter a solução no replit."
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-1---adicionar-um-nó-a-lista-ligada-30",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-1---adicionar-um-nó-a-lista-ligada-30",
    "title": "Programação",
    "section": "",
    "text": "Implementa a função addAeronave que recebe uma lista ligada de Aeronave e um Aeronave para adicionar.\nA função cria um novo nó na lista com os dados do Aeronave recebido.\nNota: se não conseguires implementar esta função, tenta implementar a mesma funcionalidade diretamente na main."
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-2---escrever-todos-os-elementos-de-lista-ligada-20",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-2---escrever-todos-os-elementos-de-lista-ligada-20",
    "title": "Programação",
    "section": "",
    "text": "Implementa a função printAeronaves que recebe uma lista ligada de Aeronave e escreve na consola todos os elementos da lista.\nUsa a função printAeronave para escrever na consola cada um dos elementos da lista."
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-3---integração-30",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-3---integração-30",
    "title": "Programação",
    "section": "",
    "text": "Escreve a função main de modo a que:\n\no programa receba um vetor de n aeronaves com dados aleatórios\n\nusa a função createAeronaves para este efeito\n\ncrie uma lista ligada de Aeronave\nadicione cada um das aeronaves do vetor à lista ligada (addAeronave)\nliberte a memória do vetor\nescreva na consola todos os elementos da lista ligada (printAeronaves)"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-4---filtro-20",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#parte-4---filtro-20",
    "title": "Programação",
    "section": "",
    "text": "Modifica a função main de modo a que, no final:\n\nelimina da lista ligada todos as aeronaves com ano de fabrico superior a 2000\n\npara cada aeronave removido, escreve na consola “removida aeronave com número de cauda ”\n\nescreve na consola todas as aeronaves com ano inferior ou igual a 2000 (printAeronaves)"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#código-inicial",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#código-inicial",
    "title": "Programação",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * ESTRUTURAS *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n\n// struct para Aeronave\ntypedef struct {\n    char fabricante[20];\n    int n_cauda;\n    int ano_fabrico;\n} Aeronave;\n\n// linked list node of type Aeronave\ntypedef struct node {\n    Aeronave aeroanve;\n    struct node *next;\n} Node;\n\n// function to print a Aeronave pointer\nvoid printAeronave(Aeronave *aeronave) {\n    printf(\"Aeronave: %s, %d, %d\\n\", aeronave-&gt;fabricante, aeronave-&gt;n_cauda, aeronave-&gt;ano_fabrico);\n}\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * MOCK DATA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n// array of 20 aircraft makers\nchar *fabricantes[] = {\n    \"Boeing\",\n    \"Airbus\",\n    \"Embraer\",\n    \"Bombardier\",\n    \"Cessna\",\n    \"Dassault\",\n    \"Gulfstream\",\n    \"Pilatus\",\n    \"Beechcraft\",\n    \"Lockheed\",\n    \"Saab\",\n    \"Sukhoi\",\n    \"Antonov\",\n    \"Tupolev\",\n    \"Ilyushin\",\n    \"Yakovlev\",\n    \"Aero\",\n    \"Fokker\",\n    \"McDonnell Douglas\",\n    \"Lockheed Martin\",\n};\n\n\n\n// function createAeronaves receives an unsigned int n and returns a pointer to an array of n Aeronaves\nAeronave *createAeronaves(unsigned int n) {\n    Aeronave *aeronaves = malloc(n * sizeof(Aeronave));\n    for (int i = 0; i &lt; n; i++) {\n        int rand_fabricante = rand() % 20;\n        strcpy(aeronaves[i].fabricante, fabricantes[rand_fabricante]);\n        aeronaves[i].n_cauda = 1000 + i;\n        aeronaves[i].ano_fabrico = 1990 + rand() % 30;\n    }\n    return aeronaves;\n}\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * *\n    * LISTA LIGADA *\n* * * * * * * * * * * * * * * * * * * * * * * */\n\n// function to add aeronave to list\nvoid addAeronave(Node **head, Aeronave aeronave) {\n}\n\n\n// function to print a linked list of Aeronave\nvoid printAeronaves(Node *head) {\n}\n\n\nint main(){\n    // podes alterar este valor para testar com arrays de tamanhos diferentes\n    int n_aeronaves = 10;\n\n    // receber array de Aeronaves aleatórios, com a função createAeronaves\n    \n\n    // criar lista ligada\n    \n\n    // adicionar todos os Aeronave do array à lista ligada\n    \n\n    // libertar array de Aeronave da memória\n\n    // escrever na consola todos os Aeronave da lista ligada\n\n    // eliminar da lista ligada todos os Aeronave com ano de fabrico superior a 2000\n    //     para cada Aeronave removido, escrever na consola \"removida aeronave com número de cauda &lt;n_cauda&gt; do fabricante &lt;fabricante&gt;\"\n\n\n    // imprimir novamente a lista ligada com as aeronaves sobrantes\n\n\n}"
  },
  {
    "objectID": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#ajuda",
    "href": "markdown/labs/2223/lab4_dynamic_data_structures/lab4B.html#ajuda",
    "title": "Programação",
    "section": "",
    "text": "Se ajudar, podes criar outra estrutura de dados para ter a cabeça da lista ligada e modificar as funções para receber uma lsita desse tipo, e.g.\n\ntypedef struct {\n    Node * head;\n} Lista;\n\nvoid addAeronave(Lista * lista, Aeronave aeronave) {\n\n}\n\n\n// function to print a linked list of Aeronave\nvoid printAeronaves(Lista * lista) {\n}"
  },
  {
    "objectID": "markdown/projects/2223/enunciado_ativos.html",
    "href": "markdown/projects/2223/enunciado_ativos.html",
    "title": "Enunciado SIGA",
    "section": "",
    "text": "Introdução\nEstão responsáveis por desenvolver um programa protótipo para gestão de carteiras de investimento, denominado Sistema de Informação para a Gestão de Ativos (SIGA). Este sistema suportará os analistas e gestores de carteiras no seu trabalho, ao centralizar os dados dos ativos e carteiras dos clientes.\n\n\nEstrutura & Organização\n\nExistem Carteira, AtivoFinanceiro, ValorAtivo, AtivoCarteira\nCada Carteira está associada a uma série de AtivoCarteira\nCada AtivoCarteira está associada a um AtivoFinanceiro\nCada AtivoFinanceiro está associado a um ValorAtivo\nDados de AtivoFinanceiro\n\nid\ntipo (acção, bond, crypto, …)\nnome\n\nDados de ValorAtivo\n\nid do AtivoFinanceiro\ndata\nvalor\n\nDados de Carteira\n\nid da Carteira\ndescrição\nlista de AtivoCarteira\n\nDados de AtivoCarteira\n\nid de AtivoFinanceiro\nquantidade desse AtivoFinanceiro que está guardado em Carteira\n\nO programa guarda uma base de dados em formato binário com as carteiras, as quantidades de cada ativo em cada carteira e os valores atuais dos ativos financeiros.\nA lista de ativos financeiros disponível está num ficheiro de texto.\n\n\n\nFuncionalidades\n\nImportar dados de ficheiro de texto\n\nCarteira nova\nAtualização dos novos valores dos AtivoFinanceiro\n\nCompra/Venda de AtivoFinanceiro para determinada Carteira\n\nPrograma lista as carteiras existentes com id e nome\nPrograma mostra lista de ativos atuais em carteira e questiona se utilizador quer comprar ou vender mais unidades de algum desses ativos\n\nComprar/vender ativos atuais: utilizador seleciona o que quer, se quer vender ou comprar e quantidade\nComprar outros ativos: programa mostra lista de todos os ativos existentes, utilizador seleciona o que quer e quantidade a comprar.\n\n\nRelatórios\n\nDescrever uma determinada Carteira\n\nmostrar todos os AtivoCarteira\nmostrar valor total da Carteira actal\n\n\nEstatísticas\n\n5 AtivoFinanceiros com maior valor\nMédia do valor de AtivoFinanceiro por tipo\nGráfico com evolução do preço de um determinato AtivoFinanceiro (⚠️ para grupos de 4 elementos)\n\n\n\n\nFormato dos ficheiros de texto para importar\n\nFicheiro de texto para importar conjunto de Carteira\nCarteiraId 2\nCarteiraDescrição\nId de AtivoFinanceiro 1\nQuantidade de AtivoFinanceiro 1\nId de AtivoFinanceiro 2\nQuantidade de AtivoFinanceiro 2\n... (representativo de mais ativos financeiros)\nId de AtivoFinanceiro N\nQuantidade de AtivoFinanceiro N\n---\nCarteiraId 2\nCarteiraDescrição\nId de AtivoFinanceiro 1\nQuantidade de AtivoFinanceiro 1\nId de AtivoFinanceiro 2\nQuantidade de AtivoFinanceiro 2\n...\nId de AtivoFinanceiro N\nQuantidade de AtivoFinanceiro N\nFicheiro de texto para importar novos valores de AtivoFinanceiro (duração dada em minutos), i.e. lista de ValorAtivo\n\nem cada linha o formato é data[espaço]id de ativo[espaço]novo valor\nexemplo\n\n2023-05-17 1 13.13\n2023-05-17 2 34.12\n2023-05-17 3 42.12\nFicheiro de texto com lista de AtivoFinanceiro disponível.\n1,A,Tesla\n2,C,Bitcoin\n3,B,iShares iBoxx ETF\n\n\n\nNotas\n\nSe for conveniente, podes assumir que nunca existirão mais de 100 carteiras e que uma carteira nunca tem mais de 50 AtivoCarteira.\nPode ajudar manter a base de dados de ValorAtivo ordenada por data.\nNão usar qualquer biblioteca além das que foram introduzidas nas aulas sem aprovação do docente.\n\n\n\nEntrega do trabalho\n\nO trabalho deve implementar uma aplicação para o problema enunciado. Os ficheiros de código (.c e .h) assim como documentação auxiliar (.txt, .pdf) são submetidos pelo chefe do grupo no Moodle. Ficheiros a submeter:\n\ntodos os ficheiros .c e .h necessários para a compilação e execução do programa;\ntodos os ficheiros necessários para a execução do programa (e.g. ficheiros de configuração, devem ser do tipo .txt);\num manual de utilização MANUAL.pdf com uma descrição simples e curta de como utilizar o programa (é o documento que um utilizador iria ler para aprender a utilizar o programa);\num relatório REPORT.pdf simples e curto sobre como implementaram as diversas funcionalidades e as decisões que tomaram, e onde se clarifica a estrutura do código (e.g. o ficheiro comandos.c contém as funções que manipulam a lista de comandos, grava a lista em ficheiro; optámos por manter a base de dados dos voos ordenada porque…; a estratégia para exportar os relatórios para ficheiro foi….; etc.);\n\nCaso necessário, irão ocorrer discussões para defesa dos trabalhos.\n\n\n\nCritérios de avaliação\n\nA avaliação do trabalho será feita de acordo com os seguintes princípios:\n\nO programa deve estar estruturado em funções consideradas necessárias para a resolução do problema. O programa deve estar dividido em vários ficheiros quando for relevante.\nO programa pode e deve reutilizar código tanto quanto possível e for adequado.\nO programa deve executar todas as funcionalidades tal como pedido.\nDevem ser escolhidos nomes apropriados para os tipos de dados, operações, variáveis e constantes de modo a facilitar o entendimento do programa. A formatação do código é importante.\nO código deve ser comentado. Todas as funções devem ter um breve comentário sobre a sua função, imediatamente abaixo do cabeçalho.\nDevem ser utilizadas as estruturas de dados (e.g. vectores, registos) apropriadas para cada problema.\n\n\n\n\nGrelha de avaliação (preliminar)\n\n[6] Genérico\n\n[1] Manual de utilização\n[1] Relatório\n[2] Legibilidade/Comentários/Reutilização de código\n[2] Estrutura do programa\n\n[2] Importar\n\n[1] Importar carteiras\n[1] Importar valores\n\n[4] Comprar/vender\n\n[1] Comprar/vender ativos atuais\n[3] Comprar outros ativos\n\n[2] Relatórios\n\n[2] Descrever uma determinada Carteira\n\n[6] Estatísticas\n\n[2] 5 AtivoFinanceiros com maior valor\n[2] Média do valor de AtivoFinanceiro por tipo\n[2] Gráfico com evolução do preço de um determinato AtivoFinanceiro (⚠️ para grupos de 4 elementos)"
  },
  {
    "objectID": "markdown/projects/2223/enunciado_frota.html",
    "href": "markdown/projects/2223/enunciado_frota.html",
    "title": "Enunciado SIGIF",
    "section": "",
    "text": "Introdução\nA Força Aérea Portuguesa, com a sua missão de garantir a defesa do espaço aéreo nacional, tem à sua disposição várias aeronaves com características diversas. A correcta manutenção destas aeronaves é fundamental para o seu uso continuado em segurança. Para este efeito, existem vários engenheiros encarregues da gestão das frotas. Os dados necessários a esta função são bastantes e um sistema digital integrado é necessário. A sua missão é desenhar e implementar o Sistema de Informação para a Gestão Integrada de Frotas (SIGIF). O sistema recebe dados de todas as aeronaves de todas as frotas e o registo de todos os voos.\n\n\nEstrutura & Organização\n\nExistem Aeronaves e Voos\nCada Voo está associado a uma Aeronave\nDados da Aeronave\n\nnúmero de cauda\nesquadra\nfabricante & modelo\nnúmero de horas inicial\n\nDados de Voo\n\ndata\nnúmero de cauda\nduração\n\nO programa guarda uma base de dados em formato binário.\n\n\n\nFuncionalidades\n\nImportar dados de ficheiro de texto\n\nAeronaves\nVoos\n\nListas\n\nLista com todas as aeronaves\nLista com todas as aeronaves de determinada esquadra\nLista com todos os voos\nLista com todos os voos de determinada aeronave\nLista com todos os voos entre 2 datas\nQualquer uma destas listas pode ser exportada para um fiheiro de texto\n\nEstatísticas\n\nIndicar a esquadra com mais horas de voo\nIndicar as 5 aeronaves com mais horas de voo\nHistograma das horas de voo de toda a Força Aérea, por ano (⚠️ para grupos de 4 elementos)\n\n\n\n\nFormato dos ficheiros de texto para importar\n\nAeronaves\n15133 201 F-16 800\n15134 301 F-16 100\n1319 802 Chipmunk 2300\nVoos (duração dada em minutos)\n2023-05-17\n15133\n120\n= = = = =\n2023-05-18\n15133\n180\n= = = = =\n2023-05-19\n15134\n90\n= = = = =\n\n\n\nNotas\n\nCaso seja conveniente, podes assumir que nunca existirão mais de 500 aeronaves e 1000 voos em sistema.\nPode ajudar manter a base de dados dos voos ordenada por data.\nNão usar qualquer biblioteca além das que foram introduzidas nas aulas sem aprovação do docente.\n\n\n\nEntrega do trabalho\n\nO trabalho deve implementar uma aplicação para o problema enunciado. Os ficheiros de código (.c e .h) assim como documentação auxiliar (.txt, .pdf) são submetidos pelo chefe do grupo no Moodle. Ficheiros a submeter:\n\ntodos os ficheiros .c e .h necessários para a compilação e execução do programa;\ntodos os ficheiros necessários para a execução do programa (e.g. ficheiros de configuração, devem ser do tipo .txt);\num manual de utilização MANUAL.pdf com uma descrição simples e curta de como utilizar o programa (é o documento que um utilizador iria ler para aprender a utilizar o programa);\num relatório REPORT.pdf simples e curto sobre como implementaram as diversas funcionalidades e as decisões que tomaram, e onde se clarifica a estrutura do código (e.g. o ficheiro comandos.c contém as funções que manipulam a lista de comandos, grava a lista em ficheiro; optámos por manter a base de dados dos voos ordenada porque…; a estratégia para exportar os relatórios para ficheiro foi….; etc.);\n\nCaso necessário, irão ocorrer discussões para defesa dos trabalhos.\n\n\n\nCritérios de avaliação\n\nA avaliação do trabalho será feita de acordo com os seguintes princípios:\n\nO programa deve estar estruturado em funções consideradas necessárias para a resolução do problema. O programa deve estar dividido em vários ficheiros quando for relevante.\nO programa pode e deve reutilizar código tanto quanto possível e for adequado.\nO programa deve executar todas as funcionalidades tal como pedido.\nDevem ser escolhidos nomes apropriados para os tipos de dados, operações, variáveis e constantes de modo a facilitar o entendimento do programa. A formatação do código é importante.\nO código deve ser comentado. Todas as funções devem ter um breve comentário sobre a sua função, imediatamente abaixo do cabeçalho.\nDevem ser utilizadas as estruturas de dados (e.g. vectores, registos) apropriadas para cada problema.\n\n\n\n\nGrelha de avaliação (preliminar)\n\n[6] Genérico\n\n[1] Manual de utilização\n[1] Relatório\n[2] Legibilidade/Comentários/Reutilização de código\n[2] Estrutura do programa\n\n[2] Importar\n\n[1] Importar aeronaves\n[1] Importar voos\n\n[7] Listar\n\n[0.5] Listar aeronaves\n[1] Listar aeronaves de esquadra\n[0.5] Listar voos\n[1] Listar voos de aeronave\n[2] Listar voos entre datas\n[2] Exportar listas\n\n[5] Estatísticas\n\n[2] Esquadra com mais horas\n[2] 5 aeronaves com mais horas\n[1] Histograma"
  },
  {
    "objectID": "markdown/projects/2223/enunciado_tripulacao.html",
    "href": "markdown/projects/2223/enunciado_tripulacao.html",
    "title": "Enunciado SIGIT",
    "section": "",
    "text": "Introdução\nA Força Aérea Portuguesa, com a sua missão de garantir a defesa do espaço aéreo nacional, tem à sua responsabilidade um diverso leque de missões que são cumpridas por muitas tripulações distintas, de naturezas variadas. A correcta gestão das tripulações é crucial para otimizar os recursos existentes, garantir o cumprimentos da missão e salvaguardar a saúde e bem-estar dos nossos militares. O esforço para criar tripulações e manter um registo atualiado das disponibilidades e tempos mínimos de descanso dos tripulantes é significativo e um sistema digital integrado é necessário. A sua missão é desenhar e implementar o Sistema de Informação para a Gestão Integrada de Tripulações (SIGIT). O sistema contém os dados de todos os tripulantes e possíveis missões a realizar. O CA define as missões que devem ser executadas e em que datas. O SIGIT cria automaticamente, e de forma otimizada, as tripulações necessárias para o efeito.\n\n\nEstrutura & Organização\n\nExistem Tripulante, Missão, Voo, Função\nCada Tripulante está associado a uma Função\nCada Missão está associado a uma ou mais Função\nCada Voo está associado a uma missão e a um conjunto de Tripulante\nDados de Tripulante\n\nid\nestado (operacional ou inop)\nnome\nfunção\n\nDados de Missão\n\nid da missão\nnome da missão\nnúmero de tripulantes\nindicação das funções dos tripulantes\n\nDados de Voo\n\nid do voo\ndata\nid da Missão\nlista de ids dos tripulantes\n\nDados de Função\n\nid da função\nnome da função\n\nO programa guarda os tripulantes e voos numa base de dados binária.\nO programa guarda a lista de funções e missões em 2 ficheiros de texto de configuração\n\n\n\nFuncionalidades\n\nImportar dados de ficheiro de texto\n\nTripulantes\nVoos\n\nMarcar voos\n\nSIGIT mostra lista das missões disponíveis e utilizador escolhe.\nSIGIT pede uma data para o voo desejado.\nSIGIT cria tripulação para o voo automaticamente\nCondições\n\nUm tripulante não pode ser selecionado para 2 voos no mesmo dia.\nUm tripulante não pode ser selecionado para um voo se estiver inoperacional.\n\n\nListas\n\nLista com todos os voos\nLista com todos os voos entre 2 datas\nLista com todos os tripulantes\nQualquer uma destas listas pode ser exportada para um fiheiro de texto (⚠️ para grupos de 4 elementos)\nNotas:\n\nOs dados do voo incluem a sua missão, data e o nome e função de todos os tripulantes\nA lista de tripulantes inclui o nome, função e estado atual de cada tripulante\n\n\nMudar estado de tripulante\n\nRecebe id do tripulante\nComuta o estado desse tripulante para o contrário do que está\n\n\n\n\nFormato dos ficheiros\n\nTripulantes\n\ncada tripulante em cada linha\nid estado função nome\ne.g.\n\n135531 1 1 João Silva\n136535 0 5 Maria Santos\nVoo\n\ncada campo em cada linha\n\nid do voo\nid do tipo de missão\ndata\nids dos tripulantes, um por linha\n\ncada voo separado por “% % % % %”\nexemplo\n\n1\n2\n2023-05-17\n135658\n136797\n% % % % %\n2\n5\n2023-04-13\n135658\n% % % % %\nTipos de missão\n\ncada campo em cada linha\n\nid do tipo de missão\nnome do tipo de missão\nnúmero de tripulantes\nids das funções, um por linha\n\nexemplo\n\n1\nTransporte de Doentes\n4\n1\n2\n5\n6\n% % % % %\n2\nTransporte de Carga\n3\n1\n2\n4\n% % % % %\nFunções\n\ncada função numa linha\ncampos separados por espaço\nexemplo\n\n1 Piloto\n2 Co-Piloto\n3 Navegador\n4 Load Master\n5 Médico\n6 Enfermeiro\n\n\n\nNotas\n\nSe for conveniente, podes assumir que nunca existirão mais de 500 tripulantes e 1000 voos em sistema.\nPode ajudar manter a base de dados dos voos ordenada por data.\nNão usar qualquer biblioteca além das que foram introduzidas nas aulas sem aprovação do docente.\n\n\n\nEntrega do trabalho\n\nO trabalho deve implementar uma aplicação para o problema enunciado. Os ficheiros de código (.c e .h) assim como documentação auxiliar (.txt, .pdf) são submetidos pelo chefe do grupo no Moodle. Ficheiros a submeter:\n\ntodos os ficheiros .c e .h necessários para a compilação e execução do programa;\ntodos os ficheiros necessários para a execução do programa (e.g. ficheiros de configuração, devem ser do tipo .txt);\num manual de utilização MANUAL.pdf com uma descrição simples e curta de como utilizar o programa (é o documento que um utilizador iria ler para aprender a utilizar o programa);\num relatório REPORT.pdf simples e curto sobre como implementaram as diversas funcionalidades e as decisões que tomaram, e onde se clarifica a estrutura do código (e.g. o ficheiro comandos.c contém as funções que manipulam a lista de comandos, grava a lista em ficheiro; optámos por manter a base de dados dos voos ordenada porque…; a estratégia para exportar os relatórios para ficheiro foi….; etc.);\n\nCaso necessário, irão ocorrer discussões para defesa dos trabalhos.\n\n\n\nCritérios de avaliação\n\nA avaliação do trabalho será feita de acordo com os seguintes princípios:\n\nO programa deve estar estruturado em funções consideradas necessárias para a resolução do problema. O programa deve estar dividido em vários ficheiros quando for relevante.\nO programa pode e deve reutilizar código tanto quanto possível e for adequado.\nO programa deve executar todas as funcionalidades tal como pedido.\nDevem ser escolhidos nomes apropriados para os tipos de dados, operações, variáveis e constantes de modo a facilitar o entendimento do programa. A formatação do código é importante.\nO código deve ser comentado. Todas as funções devem ter um breve comentário sobre a sua função, imediatamente abaixo do cabeçalho.\nDevem ser utilizadas as estruturas de dados (e.g. vectores, registos) apropriadas para cada problema.\n\n\n\n\nGrelha de avaliação (preliminar)\n\n[6] Genérico\n\n[1] Manual de utilização\n[1] Relatório\n[2] Legibilidade/Comentários/Reutilização de código\n[2] Estrutura do programa\n\n[2] Importar\n\n[1] Importar tripulantes\n[1] Importar voos\n\n[4] Marcar voo\n[7] Listar\n\n[1] Listar todos os voos\n[2] Listar voos entre datas\n[1] Listar todos os tripulantes\n[2] Exportar listas\n\n[1] Mudar estado de tripulante"
  },
  {
    "objectID": "markdown/tests/exame.html",
    "href": "markdown/tests/exame.html",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Podem consultar qualquer material da bibliografia recomendada.\nPodem consultar as folhas cujo conteúdo foi pré-aprovado.\nNão podem usar qualquer recurso que não esteja autorizado.\nNão podem usar qualquer tipo de comunicação com o exterior (telemóveis, computadores, etc.).\nPodem resolver o teste a lápis, excepto as questões de escolha múltipla ou verdadeiro/falso.\nA resolução do teste é individual.\nNão podem sair da sala durante o teste.\nNas respostas de escolha múltipla ou verdadeiro/falso, verifiquem se algumas das opções de resposta está na página seguinte.\n\n\n\n\n\nComponente teórica 40%\n\n[8 valores] - Parte 1\n\nCada pergunta vale 1 valor\nRepostas erradas descontam 25% do seu valor\n\nPergunta com 1 resposta, resposta errada desconta 0.25 valores\nPergunta com 2 respostas, cada resposta errada desconta 0.125 valores\netc.\n\n\n[12 valores] - Parte 2\n\n[3 valores] - Problema 1\n[4 valores] - Problema 2\n[5 valores] - Problema 3\n\n\nComponente prática 60%\nNota final = 0.4 * componente teórica + 0.6 * componente prática"
  },
  {
    "objectID": "markdown/tests/exame.html#regras",
    "href": "markdown/tests/exame.html#regras",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Podem consultar qualquer material da bibliografia recomendada.\nPodem consultar as folhas cujo conteúdo foi pré-aprovado.\nNão podem usar qualquer recurso que não esteja autorizado.\nNão podem usar qualquer tipo de comunicação com o exterior (telemóveis, computadores, etc.).\nPodem resolver o teste a lápis, excepto as questões de escolha múltipla ou verdadeiro/falso.\nA resolução do teste é individual.\nNão podem sair da sala durante o teste.\nNas respostas de escolha múltipla ou verdadeiro/falso, verifiquem se algumas das opções de resposta está na página seguinte."
  },
  {
    "objectID": "markdown/tests/exame.html#cotação",
    "href": "markdown/tests/exame.html#cotação",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Componente teórica 40%\n\n[8 valores] - Parte 1\n\nCada pergunta vale 1 valor\nRepostas erradas descontam 25% do seu valor\n\nPergunta com 1 resposta, resposta errada desconta 0.25 valores\nPergunta com 2 respostas, cada resposta errada desconta 0.125 valores\netc.\n\n\n[12 valores] - Parte 2\n\n[3 valores] - Problema 1\n[4 valores] - Problema 2\n[5 valores] - Problema 3\n\n\nComponente prática 60%\nNota final = 0.4 * componente teórica + 0.6 * componente prática"
  },
  {
    "objectID": "markdown/tests/exame.html#parte-1",
    "href": "markdown/tests/exame.html#parte-1",
    "title": "Programação 22/23 S2",
    "section": "Parte 1",
    "text": "Parte 1\n\nPergunta 1\nQuais das seguintes formas são válidas para criar um vetor com 10 int (2 respostas):\n\nint vec[10];\nint vec = malloc(10*sizeof(int));\nint *vec = malloc(10);\nint *vec = malloc(10*sizeof(int));\nint vec[] = {0 * 10};\nint vec[] = {0} * 10;\n\n\n\n\nPergunta 2\nConsidera o seguinte programa:\nint main() {\n    int array[10], soma=0;\n    for (int i=0; i&lt;10; i++) *(array+i) = 2;\n    for (int i=0; i&lt;10; i++) soma += array[i];\n    return 0;\n}\nEscolhe a resposta correcta (1 resposta):\n\nO valor final de soma é 0.\nO valor final de soma é 10.\nNão é possível saber o valor de soma sem executar o programa.\nO programa não compila porque a variável soma não está inicializada.\nNenhuma das respostas anteriores.\n\n\n\n\nPergunta 3\nQuais das seguintes formas são válidas ler um int do ficheiro binário dados.bin e guardar o valor lido na variável x (1 resposta):\nint x;\n\n// opção A\nFILE *f = fopen(\"dados.bin\", \"r\");\nfscanf(f, \"%d\", &x);\n\n// opção B\nFILE *f = fopen(\"dados.bin\", \"r\");\nfread(&x, sizeof(int), 1, f);\n\n// opção C\nFILE *f = fopen(\"dados.bin\", \"rb\");\nfread(&x, sizeof(int), 1, f);\n\n// opção D\nFILE *f = fopen(\"dados.bin\", \"ab\");\nfread(&x, sizeof(int), 1, &f);\n\nOpção A\nOpção B\nOpção C\nOpção D\nNenhuma das respostas anteriores.\n\n\n\n\nPergunta 4\nNo final da execução do seguinte código, qual é o valor da variável x? (1 resposta)\nvoid funcao1(int * arg) {\n    *arg = 1;\n}\n\nvoid funcao42(int arg) {\n    arg = 42;\n}\n\nint main() {\n    int x = 2;\n    int *y = &x;\n\n    funcao1(y);\n    funcao42(*y);\n\n    return 0;\n}\n\n0\n1\n2\n42\nNenhuma das respostas anteriores.\n\n\n\n\nPergunta 5\nQual das seguintes estruturas é adequada para uma lista duplamente ligada: (1 resposta)\n\nstruct node { int value; struct node *next; };\nstruct node { int value; struct node *next; struct node *prev; };\nstruct node { int value; struct node *prev; };\nstruct node { int value; struct node *next; struct node *prev; struct node *next; };\nNenhuma das respostas anteriores.\n\n\n\n\nPergunta 6\nConsidera o seguinte programa:\nfor (int i = 0; i &lt; 10; i++) {\n    if (i % 2 == 0) printf(\"i=%d\\n\", i);\n}\n\nfor (int i = 0; i &lt; i+10; i+=2) {\n    printf(\"i=%d\\n\", i);\n}\nEscolhe a resposta correcta (1 resposta):\n\nOs dois ciclos fazem exactamente o mesmo.\nO primeiro ciclo imprime os números ímpares de 0 a 9, enquanto o segundo imprime os números pares de 0 a 10.\nO primeiro ciclo imprime os números pares de 0 a 10, enquanto o segundo imprime os números ímpares de 0 a 9.\nO primeiro ciclo é um ciclo infinito, enquanto o segundo imprime os números pares de 0 a 10.\nO segundo ciclo é um ciclo infinito, enquanto o primeiro imprime os números pares de 0 a 10.\nNenhuma das respostas anteriores.\n\n\n\n\nPergunta 7\nSe quisermos escrever uma função que devolve um vetor de inteiros, qual das seguintes opções é a correcta? (1 resposta)\n\nint * funcao() { int vec[10]; return vec; }\nint * funcao() { int *vec = malloc(10*sizeof(int)); return vec; }\nint * funcao() { int vec[10]; return &vec; }\nint * funcao() { int *vec = malloc(10*sizeof(int)); return &vec; }\nNenhuma das respostas anteriores.\n\n\n\n\nPergunta 8 - switch\nConsidera o seguinte programa:\nint main() {\n    int x = 5;\n    switch (x) {\n        case 1:\n            printf(\"1\\n\");\n        case 2:\n            printf(\"2\\n\");\n        case 3:\n            printf(\"3\\n\");\n        default:\n            printf(\"0\\n\");\n    }\n    return 0;\n}\nEscolhe a resposta correcta (1 resposta):\n\nO programa imprime 0.\nO programa imprime 1.\nO programa imprime 2.\nO programa imprime 3.\nO programa imprime 0, 1, 2 e 3.\nNenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/exame.html#parte-2",
    "href": "markdown/tests/exame.html#parte-2",
    "title": "Programação 22/23 S2",
    "section": "Parte 2",
    "text": "Parte 2\n\nProblema 1 [3 valores]\n\nConsidera o seguinte código.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_LINHAS 100\n#define MAX_COLUNAS 100\n\ntypedef struct {\n    int n_linhas, n_colunas;\n    float vals[MAX_LINHAS][MAX_COLUNAS];\n} Matriz;\n\nMatriz operation(Matriz m1) {\n    Matriz m2;\n    m2.n_linhas = m1.n_colunas;\n    m2.n_colunas = m1.n_linhas;\n    for (int i = 0; i &lt; m1.n_linhas; i++) {\n        for (int j = 0; j &lt; m1.n_colunas; j++) {\n            m2.vals[j][i] = m1.vals[i][j];\n        }\n    }\n    return m2;\n}\n\nvoid print_matrix(Matriz *m) {\n    for (int i = 0; i &lt; m-&gt;n_linhas; i++) {\n        for (int j = 0; j &lt; m-&gt;n_colunas; j++) {\n            printf(\"%f \", m-&gt;vals[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    Matriz m1 = {2, 3, {{1, 2, 3}, {4, 5, 6}}};\n    Matriz m2 = operation(m1);\n    print_matrix(&m2);\n    return 0;\n}\n\n[1.5 val] Indica o output do programa na consola.\n[1 val] Explica o que o programa está a fazer.\nQual é o tamanho máximo que uma matriz pode ter?\n\n\n\n\nProblema 2 - ordenar índices [4 valores]\n\nEscreve uma função que recebe um array de reais e o seu tamanho.\nA função cria um novo vetor de inteiros positivos inicializados com os índices do array de reais.\nA função devolve este vetor.\nA função ordena os índices de forma a que o array de reais fique ordenado de forma decrescente.\nExemplo:\n\nNo início\n\nvetor de reais (1.2, 3.4, 2.1, 0.5)\nvetor dos indícies (0, 1, 2, 3), depois de criado e inicializado\n\nNo final\n\nvetor de reais (1.2, 3.4, 2.1, 0.5), i.e. não é alterado\nvetor dos indícies (1, 2, 0, 3), i.e. indices ordenam o vetor de reais de forma decrescente\n\nValor de retorno é o vetor de índices ordenado (1, 2, 0, 3)\n\n\n\n\n\nProblema 3 - evolução de depósito a prazo e relatório [5 valores]\n\nEscreva um programa completo que calcula a evolução de um depósito a prazo.\nO programa deve ler do teclado o valor inicial do depósito, a taxa de juro anual, o ano incial e o último ano.\nO programa deve calcular o valor do depósito para cada ano e escrever o resultado num ficheiro de texto.\nO nome do ficheiro de texto também é recebido do utilizador.\nTodos os dados recebidos do utilizador são pedidos na main.\nA lógica do programa deve ser toda implementada numa função evolucao_deposito que recebe os inputs e escreve o output no formato indicado no ficheiro indicado\nExemplo:\n\nInput a pedir ao utilizador (os valores depois dos : são os valores introduzidos pelo utilizador, que podem ser diferentes dos do exemplo)\nInsira os seguintes dados\nValor inicial do depósito: 1000\nTaxa de juro anual: 5\nAno inicial: 2010\nAno final: 2015\nNome do ficheiro de output: deposito.txt\nOutput, ficheiro deposito.txt com o seguinte conteúdo:\n2010 1000.00\n2011 1050.00\n2012 1102.50\n2013 1157.62\n2014 1215.51\n2015 1276.28"
  },
  {
    "objectID": "markdown/tests/exame_oral.html",
    "href": "markdown/tests/exame_oral.html",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Laboratórios\n\nEscreva uma estrutura para uma lista duplamente ligada com 3 dados reais: timestamp (marca temporal em segundos), x e y (em metros), correspondendo a um ponto num plano cartesiano.\nEscreva uma função que recebe a cabeça de uma lista duplamente ligada (que tem como conteúdo as coordenadas com a respetiva marca temporal de uma detemrinada viagem), e devolve a duração da viagem em minutos.\nAltera a estrutura para ter mais um campo, a velocidade atual (em m/s).\nAltere a função para calcular a velocidade para cada ponto (nó da lista).\nAdicione outro campo à estrutura, a distância ao destino.\nAltere a função para receber mais um parâmetro, o destino, e calcular a distância ao destino para cada ponto (nó da lista).\n\nEscreva uma função auxiliar que recebe 2 pontos e calcula a distância entre eles. Pode usar as funções sqrt e pow da biblioteca math.h."
  },
  {
    "objectID": "markdown/tests/exame_recurso.html",
    "href": "markdown/tests/exame_recurso.html",
    "title": "Academia da Força Aérea",
    "section": "",
    "text": "Escreva uma estrutura para uma lista duplamente ligada com 3 dados reais: timestamp (marca temporal em segundos), x e y (em metros), correspondendo a um ponto num plano cartesiano.\nEscreva uma função que recebe a cabeça de uma lista duplamente ligada (que tem como conteúdo as coordenadas com a respetiva marca temporal de uma detemrinada viagem), e devolve a duração da viagem em minutos.\nAltere a estrutura para ter mais um campo, a velocidade atual (em m/s).\nAltere a função para calcular a velocidade para cada ponto (nó da lista).\nAdicione outro campo à estrutura, a distância ao destino.\nAltere a função para receber mais um parâmetro, o destino, e calcular a distância ao destino para cada ponto (nó da lista).\n\nEscreva uma função auxiliar que recebe 2 pontos e calcula a distância entre eles. Pode usar as funções sqrt e pow da biblioteca math.h."
  },
  {
    "objectID": "markdown/tests/exame_solucao.html",
    "href": "markdown/tests/exame_solucao.html",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Podem consultar qualquer material da bibliografia recomendada.\nPodem consultar as folhas cujo conteúdo foi pré-aprovado.\nNão podem usar qualquer recurso que não esteja autorizado.\nNão podem usar qualquer tipo de comunicação com o exterior (telemóveis, computadores, etc.).\nPodem resolver o teste a lápis, excepto as questões de escolha múltipla ou verdadeiro/falso.\nA resolução do teste é individual.\nNão podem sair da sala durante o teste.\nNas respostas de escolha múltipla ou verdadeiro/falso, verifiquem se algumas das opções de resposta está na página seguinte.\n\n\n\n\n\nComponente teórica 40%\n\n[8 valores] - Parte 1\n\nCada pergunta vale 1 valor\nRepostas erradas descontam 25% do seu valor\n\nPergunta com 1 resposta, resposta errada desconta 0.25 valores\nPergunta com 2 respostas, cada resposta errada desconta 0.125 valores\netc.\n\n\n[12 valores] - Parte 2\n\n[3 valores] - Problema 1\n[4 valores] - Problema 2\n[5 valores] - Problema 3\n\n\nComponente prática 60%\nNota final = 0.4 * componente teórica + 0.6 * componente prática"
  },
  {
    "objectID": "markdown/tests/exame_solucao.html#regras",
    "href": "markdown/tests/exame_solucao.html#regras",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Podem consultar qualquer material da bibliografia recomendada.\nPodem consultar as folhas cujo conteúdo foi pré-aprovado.\nNão podem usar qualquer recurso que não esteja autorizado.\nNão podem usar qualquer tipo de comunicação com o exterior (telemóveis, computadores, etc.).\nPodem resolver o teste a lápis, excepto as questões de escolha múltipla ou verdadeiro/falso.\nA resolução do teste é individual.\nNão podem sair da sala durante o teste.\nNas respostas de escolha múltipla ou verdadeiro/falso, verifiquem se algumas das opções de resposta está na página seguinte."
  },
  {
    "objectID": "markdown/tests/exame_solucao.html#cotação",
    "href": "markdown/tests/exame_solucao.html#cotação",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Componente teórica 40%\n\n[8 valores] - Parte 1\n\nCada pergunta vale 1 valor\nRepostas erradas descontam 25% do seu valor\n\nPergunta com 1 resposta, resposta errada desconta 0.25 valores\nPergunta com 2 respostas, cada resposta errada desconta 0.125 valores\netc.\n\n\n[12 valores] - Parte 2\n\n[3 valores] - Problema 1\n[4 valores] - Problema 2\n[5 valores] - Problema 3\n\n\nComponente prática 60%\nNota final = 0.4 * componente teórica + 0.6 * componente prática"
  },
  {
    "objectID": "markdown/tests/exame_solucao.html#parte-1",
    "href": "markdown/tests/exame_solucao.html#parte-1",
    "title": "Programação 22/23 S2",
    "section": "Parte 1",
    "text": "Parte 1\n\nPergunta 1\nQuais das seguintes formas são válidas para criar um vetor com 10 int (2 respostas):\n\nint vec[10];\nint vec = malloc(10*sizeof(int));\nint *vec = malloc(10);\nint *vec = malloc(10*sizeof(int));\nint vec[] = {0 * 10};\nint vec[] = {0} * 10;\n\nSolução: a, d\n\n\n\nPergunta 2\nConsidera o seguinte programa:\nint main() {\n    int array[10], soma=0;\n    for (int i=0; i&lt;10; i++) *(array+i) = 2;\n    for (int i=0; i&lt;10; i++) soma += array[i];\n    return 0;\n}\nEscolhe a resposta correcta (1 resposta):\n\nO valor final de soma é 0.\nO valor final de soma é 10.\nNão é possível saber o valor de soma sem executar o programa.\nO programa não compila porque a variável soma não está inicializada.\nNenhuma das respostas anteriores.\n\nSolução: e\n\n\n\nPergunta 3\nQuais das seguintes formas são válidas ler um int do ficheiro binário dados.bin e guardar o valor lido na variável x (1 resposta):\nint x;\n\n// opção A\nFILE *f = fopen(\"dados.bin\", \"r\");\nfscanf(f, \"%d\", &x);\n\n// opção B\nFILE *f = fopen(\"dados.bin\", \"r\");\nfread(&x, sizeof(int), 1, f);\n\n// opção C\nFILE *f = fopen(\"dados.bin\", \"rb\");\nfread(&x, sizeof(int), 1, f);\n\n// opção D\nFILE *f = fopen(\"dados.bin\", \"ab\");\nfread(&x, sizeof(int), 1, &f);\n\nOpção A\nOpção B\nOpção C\nOpção D\nNenhuma das respostas anteriores.\n\nSolução: c\n\n\n\nPergunta 4\nNo final da execução do seguinte código, qual é o valor da variável x? (1 resposta)\nvoid funcao1(int * arg) {\n    *arg = 1;\n}\n\nvoid funcao42(int arg) {\n    arg = 42;\n}\n\nint main() {\n    int x = 2;\n    int *y = &x;\n\n    funcao1(y);\n    funcao42(*y);\n\n    return 0;\n}\n\n0\n1\n2\n42\nNenhuma das respostas anteriores.\n\nSolução: b\n\n\n\nPergunta 5\nQual das seguintes estruturas é adequada para uma lista duplamente ligada: (1 resposta)\n\nstruct node { int value; struct node *next; };\nstruct node { int value; struct node *next; struct node *prev; };\nstruct node { int value; struct node *prev; };\nstruct node { int value; struct node *next; struct node *prev; struct node *next; };\nNenhuma das respostas anteriores.\n\nSolução: b\n\n\n\nPergunta 6\nConsidera o seguinte programa:\nfor (int i = 0; i &lt; 10; i++) {\n    if (i % 2 == 0) printf(\"i=%d\\n\", i);\n}\n\nfor (int i = 0; i &lt; i+10; i+=2) {\n    printf(\"i=%d\\n\", i);\n}\nEscolhe a resposta correcta (1 resposta):\n\nOs dois ciclos fazem exactamente o mesmo.\nO primeiro ciclo imprime os números ímpares de 0 a 9, enquanto o segundo imprime os números pares de 0 a 10.\nO primeiro ciclo imprime os números pares de 0 a 10, enquanto o segundo imprime os números ímpares de 0 a 9.\nO primeiro ciclo é um ciclo infinito, enquanto o segundo imprime os números pares de 0 a 10.\nO segundo ciclo é um ciclo infinito, enquanto o primeiro imprime os números pares de 0 a 10.\nNenhuma das respostas anteriores.\n\nSolução: e\n\n\n\nPergunta 7\nSe quisermos escrever uma função que devolve um vetor de inteiros, qual das seguintes opções é a correcta? (1 resposta)\n\nint * funcao() { int vec[10]; return vec; }\nint * funcao() { int *vec = malloc(10*sizeof(int)); return vec; }\nint * funcao() { int vec[10]; return &vec; }\nint * funcao() { int *vec = malloc(10*sizeof(int)); return &vec; }\nNenhuma das respostas anteriores.\n\nSolução: b\n\n\n\nPergunta 8 - switch\nConsidera o seguinte programa:\nint main() {\n    int x = 5;\n    switch (x) {\n        case 1:\n            printf(\"1\\n\");\n        case 2:\n            printf(\"2\\n\");\n        case 3:\n            printf(\"3\\n\");\n        default:\n            printf(\"0\\n\");\n    }\n    return 0;\n}\nEscolhe a resposta correcta (1 resposta):\n\nO programa imprime 0.\nO programa imprime 1.\nO programa imprime 2.\nO programa imprime 3.\nO programa imprime 0, 1, 2 e 3.\nNenhuma das respostas anteriores.\n\nSolução: a"
  },
  {
    "objectID": "markdown/tests/exame_solucao.html#parte-2",
    "href": "markdown/tests/exame_solucao.html#parte-2",
    "title": "Programação 22/23 S2",
    "section": "Parte 2",
    "text": "Parte 2\n\nProblema 1 [3 valores]\n\nConsidera o seguinte código.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_LINHAS 100\n#define MAX_COLUNAS 100\n\ntypedef struct {\n    int n_linhas, n_colunas;\n    float vals[MAX_LINHAS][MAX_COLUNAS];\n} Matriz;\n\nMatriz operation(Matriz m1) {\n    Matriz m2;\n    m2.n_linhas = m1.n_colunas;\n    m2.n_colunas = m1.n_linhas;\n    for (int i = 0; i &lt; m1.n_linhas; i++) {\n        for (int j = 0; j &lt; m1.n_colunas; j++) {\n            m2.vals[j][i] = m1.vals[i][j];\n        }\n    }\n    return m2;\n}\n\nvoid print_matrix(Matriz *m) {\n    for (int i = 0; i &lt; m-&gt;n_linhas; i++) {\n        for (int j = 0; j &lt; m-&gt;n_colunas; j++) {\n            printf(\"%f \", m-&gt;vals[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    Matriz m1 = {2, 3, {{1, 2, 3}, {4, 5, 6}}};\n    Matriz m2 = operation(m1);\n    print_matrix(&m2);\n    return 0;\n}\n\n[1.5 val] Indica o output do programa na consola.\n[1 val] Explica o que o programa está a fazer.\nQual é o tamanho máximo que uma matriz pode ter?\n\nSolução a. o output do programa é:\n```text\n1.000000 4.000000\n2.000000 5.000000\n3.000000 6.000000\n```\n\nO programa está a fazer a transposta de uma matriz. A função operation recebe uma matriz m1 e devolve uma nova matriz m2 com a transposta de m1. A função print_matrix imprime uma matriz no ecrã.\nO tamanho máximo que uma matriz pode ter é MAX_LINHAS linhas e MAX_COLUNAS colunas, que neste caso é 100 linhas e 100 colunas.\n\n\n\n\nProblema 2 - ordenar índices [4 valores]\n\nEscreve uma função que recebe um array de reais e o seu tamanho.\nA função cria um novo vetor de inteiros positivos inicializados com os índices do array de reais.\nA função devolve este vetor.\nA função ordena os índices de forma a que o array de reais fique ordenado de forma decrescente.\nExemplo:\n\nNo início\n\nvetor de reais (1.2, 3.4, 2.1, 0.5)\nvetor dos indícies (0, 1, 2, 3), depois de criado e inicializado\n\nNo final\n\nvetor de reais (1.2, 3.4, 2.1, 0.5), i.e. não é alterado\nvetor dos indícies (1, 2, 0, 3), i.e. indices ordenam o vetor de reais de forma decrescente\n\nValor de retorno é o vetor de índices ordenado (1, 2, 0, 3)\n\nSolução\n// troca valores\nvoid swap(int * a, int * b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\nint * ordenar_indices(float * array, int n) {\n    // criar vetor de indices\n    int * indices = malloc(n * sizeof(int));\n    // inicializar indices\n    for (int i = 0; i &lt; n; i++) indices[i] = i;\n    // ordenar indices\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = i+1; j &lt; n; j++) {\n            // se o valor do array no indice i for menor que o valor do array no indice j\n            if (array[indices[i]] &lt; array[indices[j]]) {\n                swap(&indices[i], &indices[j]);\n            }\n        }\n    }\n    return indices;\n}\n\n\n\n\nProblema 3 - evolução de depósito a prazo e relatório [5 valores]\n\nEscreva um programa completo que calcula a evolução de um depósito a prazo.\nO programa deve ler do teclado o valor inicial do depósito, a taxa de juro anual, o ano incial e o último ano.\nO programa deve calcular o valor do depósito para cada ano e escrever o resultado num ficheiro de texto.\nO nome do ficheiro de texto também é recebido do utilizador.\nTodos os dados recebidos do utilizador são pedidos na main.\nA lógica do programa deve ser toda implementada numa função evolucao_deposito que recebe os inputs e escreve o output no formato indicado no ficheiro indicado\nExemplo:\n\nInput a pedir ao utilizador (os valores depois dos : são os valores introduzidos pelo utilizador, que podem ser diferentes dos do exemplo)\nInsira os seguintes dados\nValor inicial do depósito: 1000\nTaxa de juro anual: 5\nAno inicial: 2010\nAno final: 2015\nNome do ficheiro de output: deposito.txt\nOutput, ficheiro deposito.txt com o seguinte conteúdo:\n2010 1000.00\n2011 1050.00\n2012 1102.50\n2013 1157.62\n2014 1215.51\n2015 1276.28\n\nSolução\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nvoid evolucao_deposito(float valor_inicial, float taxa_juro, int ano_inicial, int ano_final, char * nome_ficheiro) {\n    FILE * f = fopen(nome_ficheiro, \"w\");\n    float valor = valor_inicial;\n    for (int ano = ano_inicial; ano &lt;= ano_final; ano++) {\n        fprintf(f, \"%d %.2f\\n\", ano, valor);\n        valor = valor * (1 + taxa_juro/100);\n    }\n    fclose(f);\n}\n\nint main() {\n    float valor_inicial, taxa_juro;\n    int ano_inicial, ano_final;\n    char nome_ficheiro[100];\n    printf(\"Valor inicial: \");\n    scanf(\"%f\", &valor_inicial);\n    printf(\"Taxa de juro anual: \");\n    scanf(\"%f\", &taxa_juro);\n    printf(\"Primeiro ano: \");\n    scanf(\"%d\", &ano_inicial);\n    printf(\"Último ano: \");\n    scanf(\"%d\", &ano_final);\n    printf(\"Nome do ficheiro: \");\n    scanf(\"%s\", nome_ficheiro);\n    evolucao_deposito(valor_inicial, taxa_juro, ano_inicial, ano_final, nome_ficheiro);\n    return 0;\n}"
  },
  {
    "objectID": "markdown/tests/solucoes.html",
    "href": "markdown/tests/solucoes.html",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Pergunta 1 - C,D\nPergunta 2 - C\nPergunta 3 - C\nPergunta 4 - B\nPergunta 5 - B\nPergunta 6 - A, B\nPergunta 7 - A\nPergunta 8 - B"
  },
  {
    "objectID": "markdown/tests/solucoes.html#problema-1",
    "href": "markdown/tests/solucoes.html#problema-1",
    "title": "Programação 22/23 S2",
    "section": "Problema 1",
    "text": "Problema 1\n\nOutput\nMaria Marques\nJoao Carvalho\nAna Pereira\nPedro Ferreira\nCarla Martins\nExplicação\n\nO programa está a concatenar os 5 primeiros nomes próprios aos 5 últimos apelidos (por ordem inversa).\n\nQual é o tamanho máximo que um nome completo pode ter (sem contar com o \\0)?\n\n99, uma vez que os vetores têm um tamanho de 100 char, mas o \\0 ocupa uma das posições."
  },
  {
    "objectID": "markdown/tests/solucoes.html#problema-2",
    "href": "markdown/tests/solucoes.html#problema-2",
    "title": "Programação 22/23 S2",
    "section": "Problema 2",
    "text": "Problema 2\n\nEscreve uma função que recebe um array de reais e o seu tamanho e um array de inteiros correspondente aos índices do array de reais. A função deve ordenar os índices de forma a que o array de reais fique ordenado.\n\n\nvoid troca_pos (int *a, int *b){\n    int aux;\n    aux = *a;\n    *a = *b;\n    *b = aux;\n}\n\nvoid ordenaIndices (int *ind, float *array, int N){\n    int i, j, n=0;\n    for (i = 0; i &lt; N; i++){\n        for (j = i+1; j &lt; N; j++){\n            if (array[ind[i]] &gt; array[ind[j]]){\n                troca_pos(&ind[i], &ind[j]);\n                n++;\n            }\n        }\n    }\n    return n;\n}"
  },
  {
    "objectID": "markdown/tests/solucoes.html#problema-3",
    "href": "markdown/tests/solucoes.html#problema-3",
    "title": "Programação 22/23 S2",
    "section": "Problema 3",
    "text": "Problema 3\n\nEscreve uma função que recebe 3 matrizes.\nAs matrizes podem ser de qualquer tamanho.\nA matriz foi implementada da seguinte forma:\n#define MAX_LINHAS 100\n#define MAX_COLUNAS 100\n\ntypedef struct {\n    int n_linhas;\n    int n_colunas;\n    float vals[MAX_LINHAS][MAX_COLUNAS];\n} Matriz;\nA função irá efetuar a multiplicação das 2 matrizes, e devolver uma terceira matriz com o resultado.\nA função tem de verificar se as dimensões das matrizes são compatíveis. Se não forem, a função deve devolver uma matriz com o número de linhas e colunas igual a -1.\n\nSolução:\nMatriz multMat (Matriz m1, Matriz m2){\n    Matriz m3;\n    int i, j, k;\n    if (m1.n_colunas != m2.n_linhas){\n        m3.n_linhas = -1;\n        m3.n_colunas = -1;\n        return m3;\n    }\n    m3.n_linhas = m1.n_linhas;\n    m3.n_colunas = m2.n_colunas;\n    // percorrer todas as posições da matriz resultante\n    for (i = 0; i &lt; m3.n_linhas; i++){\n        for (j = 0; j &lt; m3.n_colunas; j++){\n            // calcular produto interno para cada elemento\n            float soma = 0;\n            for (k = 0; k &lt; m1.n_colunas; k++){\n                soma += m1.vals[i][k] * m2.vals[k][j];\n            }\n            m3.vals[i][j] = soma;\n        }\n    }\n    return m3;\n}"
  },
  {
    "objectID": "markdown/tests/teste.html",
    "href": "markdown/tests/teste.html",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Podem consultar o livro e apenas o livro.\nSe não tiver o livro em formato físico, pode consultar o livro em formato digital.\nNo caso de usar o livro em formato digital, o livro é a única janela que pode estar aberta no computador.\nNão podem usar o telemóvel.\nPode resolver o teste a lápis.\nA resolução do teste é individual.\nNão podem sair da sala durante o teste.\n\n\n\n\n\n[8 valores] - Parte 1\n\nCada pergunta vale 1 valor\nRepostas erradas descontam 25% do seu valor\n\nPergunta com 1 resposta, resposta errada desconta 0.25 valores\nPergunta com 2 respostas, cada resposta errada desconta 0.125 valores\netc.\n\n\n[12 valores] - Parte 2\n\n[3 valores] - Problema 1\n[5 valores] - Problema 2\n[4 valores] - Problema 3"
  },
  {
    "objectID": "markdown/tests/teste.html#regras",
    "href": "markdown/tests/teste.html#regras",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "Podem consultar o livro e apenas o livro.\nSe não tiver o livro em formato físico, pode consultar o livro em formato digital.\nNo caso de usar o livro em formato digital, o livro é a única janela que pode estar aberta no computador.\nNão podem usar o telemóvel.\nPode resolver o teste a lápis.\nA resolução do teste é individual.\nNão podem sair da sala durante o teste."
  },
  {
    "objectID": "markdown/tests/teste.html#cotação",
    "href": "markdown/tests/teste.html#cotação",
    "title": "Programação 22/23 S2",
    "section": "",
    "text": "[8 valores] - Parte 1\n\nCada pergunta vale 1 valor\nRepostas erradas descontam 25% do seu valor\n\nPergunta com 1 resposta, resposta errada desconta 0.25 valores\nPergunta com 2 respostas, cada resposta errada desconta 0.125 valores\netc.\n\n\n[12 valores] - Parte 2\n\n[3 valores] - Problema 1\n[5 valores] - Problema 2\n[4 valores] - Problema 3"
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-1",
    "href": "markdown/tests/teste.html#pergunta-1",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 1",
    "text": "Pergunta 1\nSe quisermos passar um array multidimensional com um número de elementos variável para uma função, quais das seguinte opções são válidas? (2 respostas)\n\nvoid funcao(int array[][], int n_linhas, int n_colunas);\nvoid funcao(int array[n_linhas][n_colunas], int n_linhas, int n_colunas);\nvoid funcao(int n_linhas, int n_colunas, int array[n_linhas][n_colunas]);\nvoid funcao(int array[][10], int n_linhas);\nvoid funcao(int array[10][], int n_linhas);\nNenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-2",
    "href": "markdown/tests/teste.html#pergunta-2",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 2",
    "text": "Pergunta 2\nvoid funcao(int val) {\n    val = 1;\n}\nP\nint main() {\n    int x = 2;\n    funcao(x);\n    return 0;\n}\nNo final da execução do seguinte código, qual é o valor da variável x? (1 resposta)\n\n0\n1\n2\n10\nNenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-3",
    "href": "markdown/tests/teste.html#pergunta-3",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 3",
    "text": "Pergunta 3\nConsidera o seguinte programa:\nint main() {\n    int soma;\n    int array[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    for (int i=0; i&lt;10; i++) {\n        soma += i;\n    }\n    return 0;\n}\nEscolhe a resposta correcta (1 resposta): a. O valor final de soma é 0. b. O valor final de soma é 10. c. Não é possível saber o valor de soma sem executar o programa. d. O programa não compila porque a variável soma não está inicializada. e. Nenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-4",
    "href": "markdown/tests/teste.html#pergunta-4",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 4",
    "text": "Pergunta 4\nConsidera o seguinte programa:\nfor (int i = 0; i &lt; 10; i++) {\n    printf(\"%d \", i);\n}\n\nfor (int i = 0; i &lt; 10;) {\n    printf(\"%d \", i++);\n}\nEscolhe a resposta correcta (1 resposta): a. O programa não compila porque a variável i é redeclarada. b. Os dois ciclos fazem exactamente o mesmo. c. O primeiro ciclo imprime os números de 0 a 9, enquanto o segundo imprime os números de 0 a 10. d. O programa não compila porque o segundo ciclo não tem pós-instrução. e. Nenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-5",
    "href": "markdown/tests/teste.html#pergunta-5",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 5",
    "text": "Pergunta 5\nNo final da execução do seguinte código, qual é o valor da variável x? (1 resposta)\nvoid funcao1(int * arg) {\n    *arg = 1;\n}\n\nvoid funcao42(int arg) {\n    arg = 42;\n}\n\nint main() {\n    int x = 2;\n    int *y = &x;\n\n    funcao1(&x);\n    funcao42(*y);\n\n    return 0;\n}\n\n0\n1\n2\n42\nNenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-6",
    "href": "markdown/tests/teste.html#pergunta-6",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 6",
    "text": "Pergunta 6\nQuais das seguintes formas de imprimir todos os elementos de int array[10] estão correctas? (2 respostas)\n\nfor(int i=0; i&lt;10; i++) printf(\"%d \", array[i]);\nfor(int i=0; i&lt;10; i++) printf(\"%d \", *(array+i));\nfor(int i=0; i&lt;10; i++) printf(\"%d \", &(array+i));\nfor(int i=0; i&lt;10; i++) printf(\"%d \", &array[i]);\nfor(int i=0; i&lt;=10; i++) printf(\"%d \", array[i]);\nNenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-7",
    "href": "markdown/tests/teste.html#pergunta-7",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 7",
    "text": "Pergunta 7\nConsidera o seguinte programa:\nint x = 0;\nfor (int i = 0; i &lt; 10; i++) {\n    if (i % 2 == 0) printf(\"x=%d\\n\", x);\n}\n\nint x = 0;\nint i;\nfor (i = 0; i &lt; 10; i+=2) {\n    printf(\"x=%d\\n\", x);\n}\nEscolhe a resposta correcta (1 resposta): a. Os dois ciclos fazem exactamente o mesmo. b. O primeiro ciclo imprime os números ímpares de 0 a 9, enquanto o segundo imprime os números pares de 0 a 10. c. O primeiro ciclo imprime os números pares de 0 a 10, enquanto o segundo imprime os números ímpares de 0 a 9. d. O programa não compila porque a variável i é redeclarada. e. Nenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#pergunta-8",
    "href": "markdown/tests/teste.html#pergunta-8",
    "title": "Programação 22/23 S2",
    "section": "Pergunta 8",
    "text": "Pergunta 8\nConsidera o seguinte programa:\ntypedef struct\n{\n    int x;\n    int y;\n    char c; // c=0 inativo, c=1 ativo\n} Ponto;\n\nvoid filter(Ponto * pontos, int n) {\n    for (int i = 0; i &lt; n; i++)\n        if (pontos[i].y &lt; pontos[i].x)\n            pontos[i].c = 0;\n\n}\nEscolhe a resposta correcta (1 resposta): a. A função filter não altera o array, porque é passado por valor e não por referência. b. A função filter muda o array de forma a que todos os pontos abaixo da diagonal principal y=x fiquem inactivos. c. A função filter muda o array de forma a que todos os pontos acima da diagonal principal y=x fiquem inactivos. d. A função não faz nada porque o ciclo não tem chavetas { }. e. Nenhuma das respostas anteriores."
  },
  {
    "objectID": "markdown/tests/teste.html#problema-1",
    "href": "markdown/tests/teste.html#problema-1",
    "title": "Programação 22/23 S2",
    "section": "Problema 1",
    "text": "Problema 1\n\nConsidera o seguinte código.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#define MAX_STRINGS 100\n\nchar *nomes_proprios[] = {\n    \"Maria\", \"Joao\", \"Ana\", \"Pedro\", \"Carla\", \"Jose\",\n    \"Margarida\", \"Miguel\", \"Sofia\", \"Ricardo\"\n};\n\nchar *apelidos[] = {\n    \"Silva\", \"Santos\", \"Rodrigues\", \"Costa\", \"Oliveira\",\n    \"Martins\", \"Ferreira\", \"Pereira\", \"Carvalho\", \"Marques\"\n};\n\nvoid create_full_names(int n_strings, char * nomes_proprios[10],\n    char * apelidos[10], char nomes_completos[n_strings][MAX_STRINGS]) {\n    for (int i = 0; i &lt; n_strings; i++) {\n        strcpy(nomes_completos[i], nomes_proprios[i]);\n        strcat(nomes_completos[i], \" \");\n        strcat(nomes_completos[i], apelidos[10 - i - 1]);\n    }\n}\n\nint main() {\n    int n = 5;\n    char nomes_completos[n][MAX_STRINGS];\n    create_full_names(n, nomes_proprios, apelidos, nomes_completos);\n    for (int i = 0; i &lt; n; i++)\n        printf(\"%s\\n\", nomes_completos[i]);\n    return 0;\n}\n\n[1 val] Indica o output do programa na consola.\n[1.5 val] Explica o que o programa está a fazer.\n[0.5 val] Qual é o tamanho máximo que um nome completo pode ter (sem contar com o \\0)?"
  },
  {
    "objectID": "markdown/tests/teste.html#problema-2",
    "href": "markdown/tests/teste.html#problema-2",
    "title": "Programação 22/23 S2",
    "section": "Problema 2",
    "text": "Problema 2\n\nEscreve uma função que recebe um array de reais e o seu tamanho e um array de inteiros correspondente aos índices do array de reais. A função deve ordenar os índices de forma a que o array de reais fique ordenado.\nExemplo:\n\n\nfloat array[] = {1.2, 3.4, 2.1, 0.5};\nint indices[] = {0, 1, 2, 3};\n\n// depois de chamar a função, o conteúdo dos dois arrays seria o seguinte:\n\nfloat array[] = {1.2, 3.4, 2.1, 0.5};\nint indices[] = {3, 0, 2, 1};"
  },
  {
    "objectID": "markdown/tests/teste.html#problema-3",
    "href": "markdown/tests/teste.html#problema-3",
    "title": "Programação 22/23 S2",
    "section": "Problema 3",
    "text": "Problema 3\n\nEscreve uma função que recebe 2 matrizes. As matrizes podem ser de qualquer tamanho.\nA matriz foi implementada da seguinte forma:\n#define MAX_LINHAS 100\n#define MAX_COLUNAS 100\n\ntypedef struct {\n    int n_linhas, n_colunas;\n    float vals[MAX_LINHAS][MAX_COLUNAS];\n} Matriz;\nA função efetua a multiplicação das 2 matrizes, e devolve uma terceira matriz com o resultado.\nA função tem de verificar se as dimensões das matrizes são compatíveis. Se não forem, a função deve devolver uma matriz com o número de linhas e colunas igual a -1.\nExemplo:\n\nMatriz m1 = {2, 3, {{1, 2, 3}, {4, 5, 6}}};\nMatriz m2 = {3, 2, {{1, 2}, {3, 4}, {5, 6}}};\n\nMatriz m3 = multiplica_matrizes(m1, m2);\n\n// m3.n_linhas = 2\n// m3.n_colunas = 2\n// m3.vals = {{22, 28}, {49, 64}}\nExemplo de matrizes duas matrizes de dimensões incompatíveis:\nMatriz m1 = {2, 3, {{1, 2, 3}, {4, 5, 6}}};\nMatriz m2 = {2, 3, {{1, 2, 3}, {4, 5, 6}}};\n\nMatriz m3 = multiplica_matrizes(m1, m2);\n\n// m3.n_linhas = -1\n// m3.n_colunas = -1"
  },
  {
    "objectID": "markdown/06_ciclos.html#ciclos",
    "href": "markdown/06_ciclos.html#ciclos",
    "title": "Programação",
    "section": "Ciclos",
    "text": "Ciclos\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/06_ciclos.html#ciclos-1",
    "href": "markdown/06_ciclos.html#ciclos-1",
    "title": "Programação",
    "section": "Ciclos",
    "text": "Ciclos\n\nVideos\nSlides, PDF\n\n–\n\nVideos\n\nIntro - 1min\nwhile - 7min\ndo while - 4min\nfor - 6min\nfor demo - 3min\nfor demo 2 - 5min\nbreak, continue - 7min\nciclos infinitos - 3min\n\n\n\n\nVideo 1/8 - Intro\n\n\n\n–\n\n\nVideo 2/8 - while\n\n\n\n–\n\n\nvideo 3/8 - do while\n\n\n\n–\n\n\nvideo 4/8 - for\n\n\n\n–\n\n\nvideo 5/8 - demo, for\n\n\n\n–\n\n\nvideo 5/8 - demo 2, for\n\n\n\n–\n\n\nvideo 7/8 - break, continue\n\n\n\n–\n\n\nvideo 8/8 - ciclos infinitos"
  },
  {
    "objectID": "markdown/08_funcoes.html#funções",
    "href": "markdown/08_funcoes.html#funções",
    "title": "Programação",
    "section": "Funções",
    "text": "Funções\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/08_funcoes.html#funções-1",
    "href": "markdown/08_funcoes.html#funções-1",
    "title": "Programação",
    "section": "Funções",
    "text": "Funções\n\nSlides, PDF\nVideos\n\n–\n\nFunções - videos 1/2\n\n\nIntro - 3min\nCaracteristicas - 3min\nExemplos, mais caracteristicas - 6min\nParâmetros - 9min\n\nIntro teórica - 2min\nDemo - 4min\nTipos - 1min\nErros de compilador - 1min\nReturn - 1min\n\n\n–\n\n\nFunções - videos 2/2\n\nProtótipos - 2min\nDemo - 4min\nVariáveis globais - 4min\nExercício variáveis globais - 4min"
  },
  {
    "objectID": "markdown/09_arrays.html#array",
    "href": "markdown/09_arrays.html#array",
    "title": "Programação",
    "section": "Array",
    "text": "Array\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/09_arrays.html#array-1",
    "href": "markdown/09_arrays.html#array-1",
    "title": "Programação",
    "section": "Array",
    "text": "Array\n\nVideos\nSlides, PDF\nSlides, extra\n\n–\n\n\nvideos 1/2\n\nIntro, criar, mudar - 5min\nArrays e funções - 5min\nDemo exercício salários - 14min\n\n00:00 explicar enunciado\n01:10 inicio da solução\n02:28 função pedir salarios\n04:05 função para mostrar salários\n07:25 função para somar salários\n9:30 função para a média dos salários\n11:56 utilizador indica quantos salários quer introduzir\n\n\n–\n\n\nvideos 2/2\n\nArrays multi-dimensionais - 4min\nDemo Arrays multi-dimensionais - 10min\n\n0:00 explicação do enunciado\n0:56 inicio do resolução\n\nErros comuns, VLAs - 5min\n\n\n\n\n\nErros comuns\n\nAceder a posições inexistentes do array\nC permite mas o comportamento não está definido.\n\nint vec[20];\nvec[25] = 4;\n\n\n\nArrays de tamanho variável (VLA)\n\nO que são?\nExemplos\nVLA e funções\nVLA multidimensional e funções\n\n–\n\n\nVLA - o que são?\n\nVariable Length Arrays (VLA)\nDisponíveis apenas para compiladores &gt;C99\nPermitem criar arrays cujo tamanho é definido durante a execução do programa\nEstes arrays não podem ser globais.\nAplicável a arrays multi-dimensionais.\n\n–\n\nVLA - exemplo 1\nunsigned int n;\nprintf(\"tamanho do vector:\");\nscanf(\"%u\", &n);\nint posicoes[n];\n–\n\n\nVLA - exemplo 2 - multi-dimensional\nunsigned int rows, cols;\nprintf(\"linhas e colunas da matriz:\");\nscanf(\"%u%u\", &rows, &cols);\nint matrix[rows][cols];\n–\n\n\nVLA e funções\nint func(int n, int vec[n]){\n   //...\n}\n–\n\n\nVLA multi-dimensional e funções\nint func(int rows, int cols, int mat[rows][cols]){\n   //...\n}\nDesta forma, deixa de ser necessário especificar o tamanho concreto das últimas N-1 dimensões."
  },
  {
    "objectID": "markdown/0_home.html#programação",
    "href": "markdown/0_home.html#programação",
    "title": "Labs",
    "section": "Programação",
    "text": "Programação\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n\n\n\natalhos da apresentação\nEsc    | mostra panaroma de todos os slides\nWASD   | navegar nos slides\nEspaço | slide seguinte\n← →    | slide anterior/seguinte"
  },
  {
    "objectID": "markdown/0_home.html#links-úteis",
    "href": "markdown/0_home.html#links-úteis",
    "title": "Labs",
    "section": "Links úteis",
    "text": "Links úteis\n\nReplit PROG\nTeams PROG\nFicheiros SharePoint"
  },
  {
    "objectID": "markdown/0_home.html#índice",
    "href": "markdown/0_home.html#índice",
    "title": "Labs",
    "section": "Índice",
    "text": "Índice\n\n\n\nApresentação da UC\n\n\nC Fundamentals\n\n\nLeitura e escrita formatada\n\n\nExpressões\n\n\nTestes e Condições\n\n\nCiclos\n\n\nTipos básicos do C\n\n\nFunções\n\n\nArrays\n\n\nStrings\n\n\nApontadores\n\n\nStruct\n\n\nFicheiros\n\n\nMemória\n\n\nDynamic Data Structures\n\n\nExtra\n\n\nExercícios\n\n\n\nPressionar a tecla Esc (Escape) para ver todos os slides.\n\n\n\nSetup VSCode locally"
  },
  {
    "objectID": "markdown/10_strings.html#string",
    "href": "markdown/10_strings.html#string",
    "title": "Programação",
    "section": "String",
    "text": "String\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/10_strings.html#string-1",
    "href": "markdown/10_strings.html#string-1",
    "title": "Programação",
    "section": "String",
    "text": "String\n\nVideos\nSlides, PDF\n\n–\n\n\nvideos sharepoint\n\nStrings Playlist\n\nIntro - 1min\nCriar, inicializar, literal - 5min\nLer, escrever - 5min\nFunções, string.h\nDemo - strlen\nDemo - strcpy\nDemo - strcat\nDemo - strcmp\n\n\n–\n\n\nvideos 1/2\n\n\nIntro - 1min\nCriar, inicializar, literal - 5min\nLer, escrever - 5min\nFunções, string.h\n\n–\n\n\nvideos 2/2\n\n\nDemos\n\nstrlen\nstrcpy\nstrcat\nstrcmp"
  },
  {
    "objectID": "markdown/11_pointer.html#apontadores",
    "href": "markdown/11_pointer.html#apontadores",
    "title": "Programação",
    "section": "Apontadores",
    "text": "Apontadores\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/11_pointer.html#apontadores-1",
    "href": "markdown/11_pointer.html#apontadores-1",
    "title": "Programação",
    "section": "Apontadores",
    "text": "Apontadores\n\nVideos TODO\nSlides, PDF\n\n–\n\n\nvideos sharepoint\n\nPlaylist\n\nIntro, declaração, endereço e desreferenciar - 4min\nExemplos - 6min\nOperações - 5min\nApontadores e arrays - 4min\nApontadores de apontadores - 4min\nFunções - passagem por valor vs. referência - 3min\nExercício - passagem por valor vs. referência - 2min\n\n\n–\n\n\n\nVideos Loom\n\nIntro, declaração, endereço e desreferenciar - 4min\nExemplos - 6min\nOperações - 5min\nApontadores e arrays - 4min\nApontadores de apontadores - 4min\nFunções - passagem por valor vs. referência - 3min\nExercício - passagem por valor vs. referência - 2min"
  },
  {
    "objectID": "markdown/12_struct.html#struct",
    "href": "markdown/12_struct.html#struct",
    "title": "Programação",
    "section": "Struct",
    "text": "Struct\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/12_struct.html#struct-1",
    "href": "markdown/12_struct.html#struct-1",
    "title": "Programação",
    "section": "Struct",
    "text": "Struct\n\nVideos TODO\nSlides, PDF\n\n–\n\n\nvideos 1/2\n\nIntro, motivação | 1.5min\nDeclarar, aceder | 4min\nComparação, estruturas dentro de estruturas, funções | 4min\ntypedef | 2min\nestruturas e apontadores | 4min\n\n–\n\n\nvideos 2/2\n\nDemo 1 | 10min\nDemo 1 | correção de criar_aluno | 3min\nDemo 1a | vector de Aluno | 4min\nDemo 1b\nDemo 1c\nDemo 1d\nDemo 1f\nDemo 1g\n\n–\n\n\nExercício 1\n\nEscreva um programa que guarde e mostre o registo de um aluno Aluno da cadeira de programação.\nUm aluno tem os seguintes parâmetros:\n\nnome (string)\nNIP (int)\nnotas (vector com 3 números reais para guardar as classificações das avaliações)\n\nEscreva uma função criar_aluno que pede os dados do aluno ao utilizador e devolve um registo de aluno com esses dados.\nEscreva uma função mostrar_aluno que recebe o apontador de um registo de aluno e imprime os seus valores na consola.\n\n–\n\n\nExercício 1a\n\nExpanda o programa anterior para mostrar os registos dos alunos da cadeira de Programação.\nCrie um vector de Aluno de tamanho MAX_ALUNOS e uma variável n_alunos que recebe do utilizador quantos alunos vai receber.\nPeça os dados de todos os alunos a receber e no final, escreva na consola os dados de todos os alunos.\n\n–\n\n\nExercício 1b\n\nModifique o programa anterior por forma a termos várias Unidades Curriculares (UC).\nCrie uma estrutura para uma UC, com os seguintes campos:\n\nnome (string, max 50 chars)\nabreviatura (vector 4 chars)\nn_creditos (int): número de créditos (ECTS)\nalunos (vector de apontadores para Aluno, max 100): lista de alunos inscritos\nn_inscritos (unsigned char): número de alunos inscritos\navals (vector de reais): notas finais dos alunos à UC\n\nAgora a estrutura Aluno já não precisa do campo notas, estes dados estão guardados nas UCs. Remova esse campo.\nAgora a lista de Aluno é a lista de todos os alunos.\nCrie um vector para a lista de UCs (tamanho de MAX_UC) na main.\nCrie a função criarUC:\n\nnão recebe argumentos\npede os dados de uma UC (nome, abreviatura, número de créditos) ao utilizador\ndevolver a UC criada\n\nCria a função mostrarUC\n\nrecebe um apontador de UC\nmostra os dados da UC, incluindo a lista dos alunos inscritos\n\nDicas:\n\npara facilitar o teste das funcionalidades, inicialize o vector de todos os alunos com dados no código\npara facilitar o teste das funcionalidades, inicialize o vetor de todas as UCs com algumas UCs já com alunos inscritos\n\n\n–\n\n\nExercício 1c\n\nImplementa a função media_UC que recebe um apontador de UC e calcula a média das notas dos alunos.\nAltera a função mostrarUC para mostrar a média da UC que recebe.\n\n–\n\n\nExercício 1d\n\nImplementa a função media_aluno\n\nrecebe\n\napontador de Aluno\nlista de todas as UCs\n\ndevolve\n\nvalor real com a média ponderada (ter em conta os ECTS de cada UC) de todas as UCs em que o aluno está inscrito\n\nesta função tem de percorrer todas as UCs e verificar se o aluno está inscrito nessa UC\n\n\n–\n\n\nExercício 1e\n\nImplementa a função media_total\n\nrecebe\n\nlista de todos os alunos\nlista de todas as UCs\n\ndevolve\n\nreal correspondente à média aritmética da média ponderada de todos os alunos\n\n\n\n–\n\n\nExercício 1f\n\nImplementa a função inscrever_UC\n\nrecebe apontador de UC\nlista de todos os alunos\n\nmostra lista de todos os alunos\nutilizador escolhe quais os alunos da lista a inscrever nesta UC\n\nescrever os índices e terminar lista com algum carater não numérico\nexemplo:\nLista de todos os alunos:\n        0 - 136787 - Asimov\n        1 - 136867 - Turing\n        2 - 122444 - Oppenheimer\n        3 - 133555 - Newton\nÍndices dos alunos que quer inscrever (separados por espaço):\n1 5 3 f\n\nadicionar os alunos escolhidos ao vetor alunos da UC\n\n–\n\n\nExercício 1g\n\nImplementa a função inscrever_aluno\n\nrecebe\n\napontador de Aluno\nlista de todas as UCs\n\nmostra lista de todas as UCs e permite escolher as UCs em que o aluno está inscrito\npara cada UC selecionada\n\nadicionar o aluno à lista de inscritos\n\nnão devolve nada"
  },
  {
    "objectID": "markdown/13_files.html#ficheiros",
    "href": "markdown/13_files.html#ficheiros",
    "title": "Programação",
    "section": "Ficheiros",
    "text": "Ficheiros\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/13_files.html#ficheiros-1",
    "href": "markdown/13_files.html#ficheiros-1",
    "title": "Programação",
    "section": "Ficheiros",
    "text": "Ficheiros\n\nVideos TODO\nSlides, PDF\n\n–\n\n\nvideos\n\nIntro\nFicheiros geral\nFicheiros de texto\nTexto demo\nFicheiros binários\n\nErrata: eu digo que o valor de retorno de fread e fwrite é o número de bytes. Na verdade é o número de items lidos. Só é o número de bytes se o tamanho dos items for 1 byte.\n\nBinários demo"
  },
  {
    "objectID": "markdown/14_memoria.html#memória",
    "href": "markdown/14_memoria.html#memória",
    "title": "Programação",
    "section": "Memória",
    "text": "Memória\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "markdown/14_memoria.html#memória-1",
    "href": "markdown/14_memoria.html#memória-1",
    "title": "Programação",
    "section": "Memória",
    "text": "Memória\n\nVideos\nSlides, PDF\n\n–\n\n\nvideos\n\nIntro, Loom, SharePoint\nmalloc, calloc, free, Loom, SharePoint"
  },
  {
    "objectID": "markdown/16_extra.html#extra",
    "href": "markdown/16_extra.html#extra",
    "title": "Programação",
    "section": "Extra",
    "text": "Extra\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–\n\n\nTópicos extra\n\nUnit testing"
  },
  {
    "objectID": "markdown/2_fundamentals.html#fundamentos-do-c",
    "href": "markdown/2_fundamentals.html#fundamentos-do-c",
    "title": "Programação",
    "section": "Fundamentos do C",
    "text": "Fundamentos do C\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n\nTópicos\n\nO primeiro programa\nComponentes de um programa\nComentários\nVariáveis\nI/O Receber Valores\nConstantes\nIdentificadores"
  },
  {
    "objectID": "markdown/2_fundamentals.html#o-primeiro-programa",
    "href": "markdown/2_fundamentals.html#o-primeiro-programa",
    "title": "Programação",
    "section": "O primeiro programa",
    "text": "O primeiro programa\n\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nO que está a acontecer? \nEste programa simples escreve no terminal a frase “Hello world!”, sem as “. \n–\n```c [1] #include &lt;stdio.h&gt;\nint main(){ printf(“Hello world!”); return 0; }\n\n\"Importa\" código externo ao nosso programa, permitindo chamar a\nfunção printf, que não está aqui definida.\n\n\n\n--\n\n\n```c [3,6]\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nÉ a função principal do programa. Os programas em C começam sempre nesta função. Todos os programas têm uma função main.\n–\n```c [4] #include &lt;stdio.h&gt;\nint main(){ printf(“Hello world!”); return 0; }\n\nÉ uma instrução que chama a função\n`printf` da biblioteca `stdio.h` (que faz parte do próprio C),\ndando-lhe como input o literal de _string_ `\"Hello world!\"`.\n\nA função \"imprime\" no terminal o input recebido.\n\nTodas as instruções no C acabam com `;`.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\n```c [5]\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nEspecifica o valor de retorno do nosso programa, neste caso 0.\n–\n\nEscrevi o código, e agora?\n–\n\npreprocessamento\n\nobedece a comandos que começam com # (diretivas) \nfunciona um pouco como um editor de texto, onde se adicionam ou modificam partes do código \n\ncompilação\n\ntransformar o código C numa linguagem que o computador perceba = linguagem máquina \n\nlinking\n\ncombina o output gerado pela compilação com outro código necessário à execução do programa (e.g. stdio.h para usar o printf) \n\n\n–\nQuando damos indicação ao nosso IDE para compilar e correr o código, estes 3 passos tipicamente acontecem de forma automática."
  },
  {
    "objectID": "markdown/2_fundamentals.html#componentes-de-um-programa",
    "href": "markdown/2_fundamentals.html#componentes-de-um-programa",
    "title": "Programação",
    "section": "Componentes de um programa",
    "text": "Componentes de um programa\n\n#diretivas\n\nint main(){\n    instruções;\n}\n–\n\nA diretiva include\n#include &lt;stdio.h&gt;\nEsta diretiva indica que o conteúdo da biblioteca stdio.h deve ser incluida no programa atual.\n–\n\n\nFunções\nFunções são procedimentos ou subrotinas que executam uma determinado conjunto de instruções.\nCada função é uma determinada receita para um determinado comportamento ou funcionalidade. \nIsto permite que o mesmo comportamento seja executado diversas vezes num programa sem o ter que implementar múltiplas vezes. \n–\n\n\nInstruções\nUma instrução é um comando que é executado quando o programa corre, e.g.\nprintf(\"Hello world!\");\n–\n\n\nI/O printf\nA capacidade de um programa comunicar com o mundo exterior é fundamental para que seja útil.\nNo nosso primeiro programa, essa comunicação foi feita com a função printf e o output foi apresentado num terminal.\n–\nAnteriormente foi referido que a função recebeu um literal de string, uma série sequencial de caracteres entre ““.\nAs “” não são incluidas no que aparece no terminal. Se quisermos incluir ” no nosso output, é necessário escrever \".\n–\nO printf não inclui automaticamente o fim de linha.\nPara garantir que o printf seguinte não apresenta o seu conteúdo na mesma linha do anterior, é necessário adicionar \\n.\nprintf(\"Hello world!\\n\");\nprintf(\"Good morning, Vietnam!\");"
  },
  {
    "objectID": "markdown/2_fundamentals.html#comentários",
    "href": "markdown/2_fundamentals.html#comentários",
    "title": "Programação",
    "section": "Comentários",
    "text": "Comentários\n\nO nosso primeiro programa não tem algo importante:\n\ndocumentação\n–\nOs programas devem ter várias informações sobre o programa em si, e.g. autor, propósito, etc.\n/* Nome: hello_world.c*/\n/* Autor: Diogo Silva*/\n/* Proposito: Mostrar \"Hello world!\" na consola.*/\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nNo C, escrevemos comentários entre /* */. Todo o texto entre estes símbolos é ignorado pelo comentário, i.e. não é interpretado como código. \n–\n/*\nNome: hello_world.c\nAutor: Diogo Silva\nProposito: Mostrar \"Hello world!\" na consola.\n*/\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nUm comentário pode compreender várias linhas.\n–\nTambém podemos escrever comentários de apenas uma linha com o símbolo //.\nTudo o que vem depois deste símbolo é interpretado como um comentário.\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\"); // escrever na consola\n    return 0;\n}\nA legibilidade do programa aumenta bastante quando existem comentários que descrevem de forma sumária porções do código."
  },
  {
    "objectID": "markdown/2_fundamentals.html#variáveis",
    "href": "markdown/2_fundamentals.html#variáveis",
    "title": "Programação",
    "section": "Variáveis",
    "text": "Variáveis\nA maior parte dos programas executa uma série de cálculos. \nPara isso, precisam de um mecanismo para guardar dados de forma temporária. \nÉ para isso que servem as variáveis. \n–\nAs variáveis são locais na memória onde é possível gravar algum dado, temporáriamente, durante a execução do programa.\n–\n\nVariáveis &gt; Tipos\nNo C, todas as variáveis têm um tipo associado.\nO C tem vários tipos de dados, mas para já usaremos apenas 2 tipos numéricos: \n\nint (inteiro)\nfloat (real, floating point)\n\n\n–\nUma analogia aos tipos são os domínios na matemática, e.g. int pode ser comparado ao dominio dos números naturais.\nAssociado a um tipo, existe:  - um conjunto de valores válidos (e.g. números inteiros positivos até 65.535)  - operações válidas nos valores desse tipo (+ - * /) \n–\nDiferentes tipos incluem diferentes conjuntos de valores válidos.\nO C tem vários int que incluem diferentes intervalos de valores possíveis e.g. típicamente, int inclui valores inteiros no intervalo [-65536, 65535].\n–\nO float inclui valores muito maiores que um int, e contempla valores reais, e.g. 3.14.\nOperações aritméticas em float podem ser mais lentas.\n–\n\n\nVariáveis &gt; declaração\nQuando queremos usar uma variável, esta tem de ser declarada.\nint altura; // em cm\nfloat massa; // em kg\naltura é uma variável do tipo int e massa é uma variável do tipo float.\n–\nTambém podemos declarar várias variáveis de um determinado tipo numa só linha.\nint altura, idade; // cm, meses\nfloat massa, lucro; // kg, €\n–\n\n\nVariáveis &gt; atribuição\nAs variáveis recebem valores através da instrução de atribuição =.\nint altura; // em cm\nfloat massa; // em kg\n\naltura = 180;\nmassa = 75.2;\naltura tem agora o valor 180 e massa tem o valor 75.2 \n180 e 75.2 são constantes. \n–\nDepois das variáveis terem um valor atribuido, podem ser usadas no cálculo de outros valores.\nint altura; // em cm\nfloat massa, imc; // em kg\n\naltura = 180;\nmassa = 75.2;\nimc = massa / (altura / 100.0); //indice massa corporal\n–\nAs variáveis só podem ser usadas depois de declaradas.\n```c [3] int altura; // em cm\nmassa = 75.2;\nfloat massa, imc; // em kg\naltura = 180;\nimc = massa / (altura / 100.0); //indice massa corporal\n\nEste código é inválido porque estamos a atribuir um valor à variável ``massa``, que ainda não foi declarada.\n\n--\n\n### Variáveis &gt; printf\n\nSe quisermos mostrar o valor de uma determinada variável, podemos usar novamente a função ``printf``.\n\n```c [6]\nint altura; // em cm\nfloat massa, imc; // em kg\n\naltura = 180;\nmassa = 75.2;\nprintf(\"Altura: %d\\n\", altura);\nO que significa o símbolo %d? \n–\n%d indica como é que o valor contido na variável altura deve ser interpretado.\nNeste caso, %d indica que deve ser interpretado como um valor inteiro int. \nO descritor escolhido deve ser coerente com o tipo da variável que se vai mostrar. \naltura é do tipo int, logo usamos o descritor %d. \n–\nImportante: o C não impede um “desalinhamento” entre tipo e descritor - é responsabildiade do programador garantir a coerência.\n–\n```c [6] int altura; // em cm float massa, imc; // em kg\naltura = 180; massa = 75.2; imc = massa / (altura / 100.0); //indice massa corporal printf(“Indice massa corporal: %f”, imc);\n\nO descritor `%f` é usado para valores do tipo `float`.\n\n--\n\n### Variáveis &gt; ``printf`` de expressões\n\nO cálculo do IMC na variável intermédia `imc` é desnecessário, uma vez que podemos inserir a expressão completa do cálculo na função ``printf``.\n\n```c [6]\nint altura; // em cm\nfloat massa, imc; // em kg\n\naltura = 180;\nmassa = 75.2;\nprintf(\"Indice massa corporal: %f\\n\", massa / (altura / 100.0));\n–\nO que é uma expressão?\nUma expressão é algo que produz um valor concreto. \nUma expressão produz sempre um valor com um valor concreto, mesmo quando variáveis de tipos diferentes são misturadas (conversão automática de tipos será abordada posteriormente.) \n–\nUm valor de um determinado tipo pode sempre ser substituido por uma expressão do mesmo tipo.\n–\n\n\nVariáveis &gt; inicialização\nAlgumas variáveis são automaticamente inicializadas com o valor de 0 quando são declaradas, mas a maior parte não é. \nUma variável que não tenha um valor por defeito e que não tenha sofrido nenhuma atribuição está não inicializada. \n–\nÉ importante perceber que o C permite que uma variável seja usada em cálculos, mesmo não tenha sido inicializada.\nint altura; // em cm\nfloat massa, imc; // em kg\n\nmassa = 75.2;\nimc = massa / (altura / 100.0); //indice massa corporal\nÉ responsabilidade do programador saber que o programa pode ter um comportamento inválido, porque a variável que não foi inicializada (que não teve nenhuma atribuição) pode conter qualquer valor. \n–\nAs variáveis podem ser inicializadas no momento da sua declaração.\nint altura=180; // em cm\nfloat massa=75.2, imc=0.0; // em kg\n``\n\n--\n\n### Exercício\n\nConversão de ºF para ºC.\n\n---\n\n&lt;!-- .slide: id=\"2_5_scanf\"--&gt;\n\n## I/O receber valores\n\nJá sabemos mostrar valores ao utilizador do programa, mas como receber dados?\n\nUsamos a função ``scanf``.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\nA função ``scanf`` funciona como o ``printf``, mas na direção oposta.\n\n```c\nscanf(\"%d\", &a);\nscanf(\"%f\", &b);\nIndicamos o formato dos dados que vamos receber e a variável onde os queremos guardar. \n–\nscanf(\"%d\", &a);  // receber altura do utilizador\nscanf(\"%f\", &b);  // receber altura do utilizador\nAssumindo que já foram declaradas, qual será o tipo das variáveis a e b?\nSabemos que %d funciona com valores int, logo a deverá ser do tipo int. \nNa mesma linha, b deverá ser um float. \n–\nE o que significa o & antes do nome das variáveis?\nscanf(\"%d\", &a);\nscanf(\"%f\", &b);\nÉ um operador que devolve o endereço de memória da variável. \nIremos explorar este operador em detalhe no futuro. Até lá, saibam apenas que usamos quase sempre o & antes do nome da variável. \n–\n\n\nExercício\nConversão de ºF para ºC.\nAlterar o exercício anterior para receber os valores do utilizador."
  },
  {
    "objectID": "markdown/2_fundamentals.html#constantes",
    "href": "markdown/2_fundamentals.html#constantes",
    "title": "Programação",
    "section": "Constantes",
    "text": "Constantes\n\n–\nO que faz este programa?\n#include &lt;stdio.h&gt;\n\nint main(){\n    float r;\n    printf(\"Insira o raio do circulo[cm]:\");\n    scanf(\"%f\", &r);\n\n    printf(\"Perimetro do circulo: %f\", 2 * 3.1415 * r);\n    printf(\"Area do circulo: %f\", 3.1415 * r * r);\n    return 0;\n}\nNeste programa o valor 3.1415, o valor do π repete-se. \nSeria útil se pudéssemos fazer referência a este valor com um identificador em todo o programa. \n–\nO C tem uma diretiva que nos permite fazer exatamente isso.\n#include &lt;stdio.h&gt;\n#define PI 3.1415\n\nint main(){\n    //...\n\n    printf(\"Perimetro do circulo: %f\", 2 * PI * r);\n    printf(\"Area do circulo: %f\", PI * r * r);\n    return 0;\n}\nA diretiva #define permite-nos definir constantes que, durante o préprocessamento, são substituidas pelo valor especificado. \n–\nPor convenção, os nomes das constantes são sempre em letras maíusculas e os nomes das variáveis são em minúsculas."
  },
  {
    "objectID": "markdown/2_fundamentals.html#identificadores",
    "href": "markdown/2_fundamentals.html#identificadores",
    "title": "Programação",
    "section": "Identificadores",
    "text": "Identificadores\nOs nomes que escolhemos para as nossas variáveis, funções, etc. designam-se por identificadores e existem regras que devem ser seguidas. \n–\nExemplos de identificadores válidos\ntimes10 proximo_numero _altura alturaMAX\nExemplos de identificadores inválidos\n10times proximo-numero\nO caracter - é inválido, mas _ é aceite. \n–\nOs identificadores são sensíveis a letras maísculas e minúsculas, e.g. alturaMAX e alturamax seriam 2 identificadores distintos num programa.\nExiste um conjunto de palavras-chave que não podem ser usadas. Estas correspondem a elementos intrínsecos ao C, como o nome dos tipos básicos e dos ciclos, e.g. int, while.\n–\nOutros exemplos:\nint float double char void long short typedef\nif else switch default\nwhile do for continue break \nstruct enum union\nO uso do nome de funções frequentemente usadas e pertencentes à biblioteca standard do C também é de evitar, e.g. printf, scanf, …"
  },
  {
    "objectID": "markdown/3_formated_io.html#leitura-e-escrita-formatada",
    "href": "markdown/3_formated_io.html#leitura-e-escrita-formatada",
    "title": "Programação",
    "section": "Leitura e escrita formatada",
    "text": "Leitura e escrita formatada\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n\n\n\n\nI/O formatado\nO printf e scanf são 2 das funções mais usadas quando programamos em C.\nAmbas as funções permitem escrever/ler um número arbitrário de valores: \nprintf(\"string\", expr1, ..., exprN);\nscanf(\"string\", &var1, ..., &varN);\n\nint altura, idade;\nfloat massa, imc;\nprintf(\"Insira a idade e massa separadas por um espaco:\");\nscanf(\"%d %f\", &altura, &massa);\nprintf(\"altura: %d\\nmassa:%f\\n\", altura, massa);\n\n–\nscanf(\"%d %f\", &altura, &massa);\nprintf(\"altura: %d\\nmassa:%f\\n\", altura, massa);\nQuando usamos múltiplos descritores nestas funções, a correspondência com as variáveis/expressões é feita por ordem sequencial: - linha 1: o primeiro %d corresponde à variável altura, %f corresponde à massa - linha 2: idem\n\n–\nOs compiladores de C não são obrigados a verificar que o número de descritores é coerente com o número de valores fornecidos.\nprintf(\"%d %d %d\\n\", i); /*** ERRADO ***/\nprintf(\"%d\\n\", i, j, x, y, k); /*** ERRADO ***/\n–\nOs compiladores de C não são obrigados a verificar que o descritor % usado é o apropriado para o tipo da expressão/variável.\nint natural;\nfloat real;\nprintf(\"%f %d\\n\", natural, realj); /*** ERRADO ***/\n\n\n\nprintf\nOs descritores %d, %f, … também podem ser denominados por especificações de conversão.\n–\n\n\nNúmero de digitos\n%d escreve o número inteiro que recebe, mas podemos definir um número de ditigos mínimo.\nc [] // output no comentário após as linhas // • significa um espaço printf(\"%d\\n\", 42);    // -&gt; 42 printf(\"%5d\\n\", 42);   // -&gt; •••42 (3 espaços antes do 2) printf(\"%05d\\n\", 422); // -&gt; 00042 (3 zeros antes do 2) \n\na linha 2 especifica que o que é escrito deve ter pelo menos 5 caracteres, se não tiver, são adicionados espaços antes do número até os perfazer;\na linha 3 indica o mesmo, para são usados 0s para preencher.\n\n\n–\n\n\ncasas decimais\nPodemos fazer o mesmo com os números reais.\nc [] printf(\"%f\\n\", 3.14159);     // -&gt; 3.141590 printf(\"%.2f\\n\", 3.14159);   // -&gt; 3.14 (2 casas decimais) printf(\"%.f\\n\", 3.14159);    // -&gt; 3 (0 casas decimais, arredonda)                              //também podia ser %.0f\nc [] printf(\"%5.2f\\n\", 3.14159);  // -&gt; •3.14 (2 casas decimais,                              // pelo menos 5 characteres no total,                              // adiciona 1 espaço antes) printf(\"%05.2f\\n\", 3.14159); // -&gt; 03.14 (adiciona 0s) \n```c [] printf(“%-5.2f”, 3.14159); // -&gt; 3.14• (2 casas decimais, // pelo menos 5 characteres no total, // adiciona 1 espaço depois)\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\n### regra geral\n\nTemos a fórmula\n&lt;span style=\"color:Salmon\"&gt;`%m.pX`&lt;/span&gt; ou \n&lt;span style=\"color:Salmon\"&gt;`%-m.pX`&lt;/span&gt;, onde\n&lt;span style=\"color:Salmon\"&gt;`m`&lt;/span&gt; e \n&lt;span style=\"color:Salmon\"&gt;`p`&lt;/span&gt; são números naturais positivos, mas opcionais.\n&lt;span style=\"color:Salmon\"&gt;`X`&lt;/span&gt; é uma letra válida para conversão, e.g. `d` ou `f`.\n\n\n&lt;span style=\"color:Salmon\"&gt;`m`&lt;/span&gt;\n é o número de caracteres mínimo que devem ser escritos, sendo adicionados, à esquerda, espaços, ou zeros se designarmos\n &lt;span style=\"color:Salmon\"&gt;`0m`&lt;/span&gt;.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n\n&lt;span style=\"color:Salmon\"&gt;`p`&lt;/span&gt;\né o número de casas decimais a usar.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\nQuando temos\n&lt;span style=\"color:Salmon\"&gt;`-m`&lt;/span&gt;, adicionamos os espaços à direita do número.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\n`p` nem sempre faz sentido, pois depende da letra `X` escolhida.\n\n--\n\n### tabela de especificações de conversão\n\n| letras | descrição |\n| ------ | --------- | \n| d      | inteiros, `p` não faz sentido, `m` é o número mínimo de caracteres a serem escritos |\n| e      | reais em notação científica, `p` é o número de casas decimais\n| f      | reais em \"decimal fixo\", sem expoente, `p` tem o mesmo significado |\n\n--\n\n### símbolos especiais\n\n| Símbolo | descrição |\n| --- | ---- |\n| \\n  | nova linha |\n| \\t | tabulação |\n| `\\\\` | permite inserir um \\ |\n| \\a | causa um alerta sonoro na maior parte dos computadores |\n\n---\n\n## ``scanf``\n\n### Como funciona?\n\n--\n\nNa sua essência, o `scanf` faz correspondência de padrões.\nTenta fazer a correspondência entre grupos de *input* com especificações de conversão.\n\nPara cada especificação de conversão, o `scanf` tenta encontrar um item do tipo apropriado no *input* recebido, parando quando recebe um caracter incompatível com esse tipo.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\nSe algum item não for lido com sucesso, o ``scanf`` retorna sem tentar fazer a correspondência entre as restantes especificações de conversão com o resto do *input*.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\nAo procurar pelo início de um número, todos os espaços em branco são ignorados, e.g. espaços, novas linhas, tabulações, ...\n\n--\n\n```c\nint i, j;\nfloat x, y;\nscanf(\"%d%d%f%f\", &i, &j, &x, &y);\nprintf(\"i=%d, j=%d\\nx=%f, y=%f\\n\", i, j, x, y);\nEste programa irá ler os seguintes números de igual forma:\nbash [2] Introduza 2 inteiros e 2 reais: 1 2 3 4 5 i=1, j=2 x=3.000000, y=4.000000\nbash [2-4] Introduza 2 inteiros e 2 reais: 3     4 5 6 i=3, j=4 x=5.000000, y=6.000000\n–\nPorquê é que isto acontece?\nO scanf lê todo o input como uma sequência de caracteres. Os espaços, enters, tabulações, etc. são todos caracteres.\n3\n    4\n5 6\né equivalente a\n3¤••••4¤5•6¤\nonde ¤ é uma nova linha e • é um espaço.\n–\nO scanf pára de ler quando encontra um enter (nova linha) após a correspondência da última especificação de conversão.\n⚠️Importante⚠️ Contudo, o último enter não é consumido do input e por isso será o primeiro caracter a ser lido na próxima chamada do scanf.\n–\nRegras de correspondência para inteiros %d: - procura pelo primeiro digito ou sinal de + ou - - lê digitos até encontrar o primeiro caracter não digito\n–\nRegras de correspondência para reais %f %e: - procura pelo sinal de + ou - (opcional) - lê uma série de digitos, que podem conter 1 . a indicar que depois vêm casas decimais - um expoente (opcional): consiste na letra e ou E seguida de um sinal e mais digitos, e.g. 1e-3 (=0.001), 1E3 (=10000).\n–\nQuando o scanf lê um caracter que não encaixa na especificação de conversão que está a ser processada, é novamente colocado no input para ser processado\n–\nLer apenas N digitos\nint d1, d2;\nprintf(\"Numero inteiro:\");\nscanf(\"%1d%2d\", &d1, &d2);  // utilizador escreve 242\nprintf(\"d1=%d\\n\", d1); // d1=2\nprintf(\"d2=%d\\n\", d2); // d2=42\n%Nd permite ler N digitos inteiros."
  },
  {
    "objectID": "markdown/3_formated_io.html#exercício",
    "href": "markdown/3_formated_io.html#exercício",
    "title": "Programação",
    "section": "Exercício",
    "text": "Exercício\nSoma de frações."
  },
  {
    "objectID": "markdown/4_expressions.html#expressões",
    "href": "markdown/4_expressions.html#expressões",
    "title": "Programação",
    "section": "Expressões",
    "text": "Expressões\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n\n\n\n\nO que são?\nExpressões devolvem sempre um valor concreto com um determinado tipo.\n    int raio = 2;\n    float area = 3.14 * raio * raio;\n\n\n\nOperações aritméticas\n1+2    // soma\n3.14-2 // subtração\n1*2.3  // multiplicação\n5/2    // divisão, devolve 2 -&gt; porquê?\n5%2    // resto da divisão\n\nint v = 2;\n-v     // torna valor negativo, operação unária\n–\nOperação unária? Operação que recebe apenas 1 operando.\nPor outro lado, as outras operações são binárias (2 operandos).\n–\n⚠️ Cuidado com a divisão! ⚠️\nO operador para a divisão, quando recebe 2 operandos inteiros, devolve sempre um valor inteiro (ignorando, sem arredondamento, a parte decimal)\n5/2 // devolve 2\nQuando misturamos um inteiro com um real, o inteiro é automaticamente convertido e o resultado será o valor preciso\n5.0/2 // devolve 2.5\n–\nO resto da divisão % requer 2 operandos inteiros.\nUsar 0 como o segundo operando da divisão / ou resto da divisão %, i.e. divisão por 0, gera comportamento não definido.\n\n\n\nPrecedência e associatividade\n\n1+2*-2\nÉ o tipo de expressão que não devem escrever. Devem usar () para melhorar legibilidade.\nMas se vissem esta expressão, qual seria o resultado? \n–\nAs operações no C têm uma precedência.\n\n\n\nPrecedência\nOperadores\n\n\n\n\nAlta\n+ - unários (e.g. -2)\n\n\n---\n* / %\n\n\nBaixa\n+ -\n\n\n\n1 + 2 * -2 == 1 + (2 * (-2))\n–\ni + j * k == i + (j * k)\n-i * -j == (-i) * (-j)\n–\nE quando uma expressão tem 2 operações com a mesma precedência?\ni - j + k\ni / j * k\n–\nTem-se em conta a associatividade.\ni - j + k == (i - j) + k\ni / j * k == (i / j) * k\n+ - * / % têm associtividade à esquerda, o que quer dizer que agrupam o que está antes do operador.\nOs operadores unários têm associatividade à direita.\n- -2 == - (-2)\n\n\n\nOperadores de atribuição\n\nJá conhecemos o operador de atribuição simples =.\nÉ o que designamos por uma operação com efeitos secundários, porque altera o estado dos operandos. \n–\na = 2 altera o estado da variável a porque o seu valor é agora 2.\nAdicionalmente, a = 2 é uma expressão válida que devolve o valor que foi atribuido à variável \nint a=10;\nprintf(\"a=%d\\n\", a=2); // escreve 2 na consola e altera o valor de a\n\n–\nTodas as operações de atribuição exigem que o operando da esquerda seja uma variável.\n–\nExistem outros que se combinam com operações aritméticas.\n\n\n\n\n\n\n\nExpressão\nDescrição\n\n\n\n\nvar+=3\nsoma 3 ao valor de var e atribui o resultado a var\n\n\nvar-=3\nsubtrai 3 ao valor de var e atribui o resultado a var\n\n\nvar/=3\nmultiplica 3 com o valor de var e atribui o resultado a var\n\n\nvar/=3\ndivide o valor de var por 3 e atribui o resultado a var\n\n\nvar%=3\nfaz o resto da divisão entre var e 3 e atribui o resultado a var\n\n\n\n–\nv*=3 não é equivalente a v = v * 3, embora na maior parte das utilizações o resultado seja o mesmo.\nPorquê? Observem a expressão v*=3+10\nNão é equivalente a v = v * 3 + 10. Esta expressão, deviso às regras de precedência a associatividade iria dar um resultado diferente.\nint a=3;\nprintf(\"a=%d\\n\", (a = a * 3 + 10)); // a=19\na=3;\nprintf(\"a=%d\\n\", a*=3+10); // a=39\n–\nNão confundir += com =+.\nA primeira operação acumula o valor à direita.\nA segunda atribui o valor que a variável já tem.\n–\nPosto isto, usem sempre ( ) para deixar claro qual é a ordem das operações.\n\n\n\nIncremento e decremento\n\nExiste uma instrução que é frequentemente usada no C (irão perceber porquê quando abordarmos ciclos):\ni = i + 1;\ni += 1;\n–\nExiste outra forma de escrever esta instrução, com o operador de incremento ++\ni = i + 1;\ni += 1;\ni++;\n–\nEste operador pode ser usado tanto antes de uma variável (pré-incremento) como depois (pós-incremneto).\nQual será a diferença?\nint i=10;\nprintf(\"%d\\n\", ++i); // ?\nprintf(\"%d\\n\", i);   // ?\ni=10;\nprintf(\"%d\\n\", i++); // ?\nprintf(\"%d\\n\", i);   // ?\n–\nint i=10;\nprintf(\"%d\\n\", ++i); // 11\nprintf(\"%d\\n\", i);   // 11\ni=10;\nprintf(\"%d\\n\", i++); // 10\nprintf(\"%d\\n\", i);   // 11\n–\nAlém do incremento ++, também temos disponível o decremento --, que funciona da mesma forma, mas subtrai em uma unidade.\n\n\n\nAvaliação de expressões\n\nResumo das operações que já vimos:\n\npostfix == pós-incremento\nprefix == pré-incremento\n–\nCom este conhecimento conseguimos avaliar expressões complicadas.\na= b += c++ - d + --e / -f\n\nEncontrar o operador com maior precedência.\nColocar ( ) à volta do operador e operandos.\n\nAplicar regras de precedência e associatividade.\n\nRepetir.\n\n–\na= b += c++ - d + --e / -f\nc++ e depois –e (precedência) \na= b += (c++) - d + (--e) / -f \noperador unário -f (precedência) \na= b += (c++) - d + (--e) / (-f) \ndivisão (precedência) \na= b += (c++) - d + ((--e) / (-f)) \n–\na= b += (c++) - d + ((--e) / (-f))\n- e + com a mesma precedência e com operando em comum d (precedência) \nagrupam da esquerda para a direita, logo - primeiro (associatividade) \na= b += ((c++) - d) + ((--e) / (-f)) \ne depois o + (precedência) \na= b += (((c++) - d) + ((--e) / (-f))) \n= e += com mesma precedência (precedência) \nagrupam da direita para a esquerda, logo += primeiro (associatividade) \na= (b += (((c++) - d) + ((--e) / (-f)))) \nsobra apenas o = (precedência) \n(a= (b += (((c++) - d) + ((--e) / (-f)))))"
  }
]