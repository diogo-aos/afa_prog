[
  {
    "objectID": "cheatsheet.html",
    "href": "cheatsheet.html",
    "title": "Programação",
    "section": "",
    "text": "Variáveis\nint a; // declarar variável inteira chamada a\nfloat b=3.14; // declarar variável real chamada b e inicializar com 3.14\nchar c1,c2='a'; // declarar variável char c1 e c2, e inicializar c2 com 'a'\n\n\nOperadores\n\nOperadores aritméticos, relacionais, lógicos e de atribuição\n\n\nOperador\nDescrição\nExemplo\nOperador\nDescrição\nExemplo\n\n\n\n\n+\nSoma\na + b\n==\nIgual\na == b\n\n\n-\nSubtração\na - b\n!=\nDiferente\na != b\n\n\n*\nMultiplicação\na * b\n&gt;\nMaior\na &gt; b\n\n\n/\nDivisão\na / b\n&lt;\nMenor\na &lt; b\n\n\n%\nResto da divisão\na % b\n&gt;=\nMaior ou igual\na &gt;= b\n\n\n++\nIncremento\na++\n&&\nE\na && b\n\n\n–\nDecremento\na–\n||\nOU\na || b\n\n\n=\nAtribuição\na = b\n!\nNÃO\n!a\n\n\n+=\nAtribuição com soma\na += b\n\n\n\n\n\n-=\nAtribuição com subtração\na -= b\n\n\n\n\n\n*=\nAtribuição com multiplicação\na *= b\n\n\n\n\n\n/=\nAtribuição com divisão\na /= b\n\n\n\n\n\n\n\n\nI/O Formatado\nscanf(\"%descritor\", &variavel); // lê um dado do tipo tipo_dado e armazena em variavel\nprintf(\"%descritor\", variavel); // escreve um dado do tipo tipo_dado e armazena em variavel\n\nDescritores de tipos de dados\n\n\nDescritor\nTipo de dado\n\n\n\n\n%d\nint\n\n\n%f\nfloat\n\n\n%c\nchar\n\n\n%s\nstring\n\n\n%lf\ndouble\n\n\n%u\nunsigned int\n\n\n%ld\nlong int\n\n\n%lu\nunsigned long int\n\n\n\n\n\nI/O Não Formatado\ngetchar(); // lê um char\nfgets(variavel, tamanho, stdin); // lê uma string\n\nputchar(variavel); // escreve um char\nputs(variavel); // escreve uma string\n\n\nEstruturas de controlo\n\nif\nif (condição) {\n    // bloco de código\n} else if (condição) {\n    // bloco de código\n} else {\n    // bloco de código\n}\nswitch\nswitch (variavel) {\n    case valor1:\n        // bloco de código\n        break;\n    case valor2:\n        // bloco de código\n        break;\n    default:\n        // bloco de código\n        break;\n}\nCiclos\nwhile (condição) { // enquanto condição for verdadeira\n    // bloco de código\n}\n\ndo { // executa o bloco de código pelo menos uma vez\n    // bloco de código\n} while (condição); // enquanto condição for verdadeira\n\nfor (inicialização; condição; incremento) {\n    // bloco de código\n}\n// inicialização é executada uma vez\n// condição é testada antes de cada iteração\n// pós-instrução é executada no final de cada iteração\n\n\n\nFunções\n\nDeclaração de função\ntipo_retorno nome_função (tipo_parametro1 nome_parametro1, tipo_parametro2 nome_parametro2) {\n    // bloco de código\n}\nChamada de função\nint a;\na = funcao(parametro1, parametro2); // se funcao devolvesse um int\n\n\n\nVetores\n\nDeclaração de vetor\nint vetor[10]; // declara vetor de inteiros com 10 posições\nAcesso a posição do vetor\nvetor[0] = 1; // acessa a primeira posição do vetor e atribui 1\nVetores e funções\nint vetor[10];\nfuncao(vetor); // passa o vetor como parâmetro\nvoid funcao(int vetor[]) { // recebe o vetor como parâmetro\n    // função não sabe o tamanho do vetor\n    // alterações ao vetor são persistentes\n}\n\n\n\nVetores multidimensionais\nint matriz[10][10]; // declara matriz de inteiros com 10 linhas e 10 colunas\nmatriz[0][0] = 1; // acessa a primeira linha e primeira coluna da matriz e atribui 1\nint b = matriz[0][0]; // acessa a primeira linha e primeira coluna da matriz e atribui a b\nint matriz[10][10][10]; //vetor tridimensional\nfuncao(matriz); // passa a matriz como parâmetro\nvoid funcao(int matriz[][10][10]) { // recebe a matriz como parâmetro\n    // obrigatório indicar o tamanho de todas as dimensões menos a primeira\n    // alterações à matriz são persistentes\n}\n\n// VLAs (Variable Length Arrays)\nvoid funcao(int x, int y, int z, int matriz[x][y][z]) {\n    // alterações à matriz são persistentes\n}\n\n\nStrings\n\nDeclaração de string\nchar string[10]; // declara string de 10 caracteres\n\nchar string[10] = \"ola\"; // declara e inicializa string\n\nchar string[10] = {'o', 'l', 'a', '\\0'}; // declara e inicializa string\nstring.h\n\n\nFunções úteis da string.h\n\n\n\n\n\n\nFunção\nDescrição\n\n\n\n\nstrlen(string)\nretorna o tamanho da string\n\n\nstrcpy(string1, string2)\ncopia string2 para string1\n\n\nstrcat(string1, string2)\nconcatena string2 a string1\n\n\nstrcmp(string1, string2)\ncompara string1 com string2, devolve 0 se forem iguais, &lt; 0 se string1 &lt; string2 e &gt; 0 se string1 &gt; string2\n\n\n\n\n\nApontadores\nint *p; // declara ponteiro para inteiro\n\nint a = 10;\np = &a; // ponteiro recebe o endereço de memória da variável a\nint a = 10;\nint *p;\np = &a;\nprintf(\"%d\", *p); // imprime o valor apontado por ponteiro\n\n\nAlocação dinâmica de memória\nint *p;\np = (int *) malloc(1 * sizeof(int)); // aloca memória para um inteiro\n\nfree(ponteiro); // libera a memória alocada para ponteiro\n\n\nEstruturas\n\nDeclaração de estrutura\nstruct nome_estrutura {\n    tipo1 nome1;\n    tipo2 nome2;\n};\nAcesso a campo da estrutura\n\nstruct nome_estrutura variavel;\nvariavel.nome1 = 1; // acessa o campo nome1 da variável variavel e atribui 1\nEstruturas e apontadores\nstruct nome_estrutura *ponteiro;\nponteiro = &variavel; // ponteiro recebe o endereço de memória da variável variavel\nponteiro-&gt;nome1 = 1; // acessa o campo nome1 da variável apontada por ponteiro e atribui 1\ntypedef\ntypedef struct nome_estrutura {\n    tipo1 nome1;\n    tipo2 nome2;\n} NomeEstrutura; // NomeEstrutura passa a ser um tipo\n\nNomeEstrutura variavel; // declara variável do tipo NomeEstrutura\n\nvoid funcao(NomeEstrutura x) {\n    // bloco de código\n}\n\nNomeEstrutura funcao2() {\n    temp = NomeEstrutura;\n    return temp;\n}\n\n\n\nFicheiros\n\nAbertura e fecho de ficheiro\nFILE *ficheiro;\nficheiro = fopen(\"nome_ficheiro\", \"modo_abertura\");\n// abre o ficheiro nome_ficheiro no modo modo_abertura\n// se devolver NULL, não foi possível abrir o ficheiro\n\nfclose(ficheiro); // fecha o ficheiro\nfcloseall(); // fecha todos os ficheiros abertos\nModos de abertura de ficheiro\n\nPara ficheiros binários, acrescentar b ao modo de abertura, e.g. “rb”, “wb”, “ab”, “rb+”, “wb+”, “ab+”.\n\n\n\nModos de abertura de ficheiro\n\n\nModo\nLeitura\nEscrita\nCriação\nPosicionamento\n\n\n\n\nr\nSim\nNão\nNão\nInício\n\n\nw\nNão\nSim\nSim\nInício\n\n\na\nNão\nSim\nSim\nFim\n\n\nr+\nSim\nSim\nNão\nInício\n\n\nw+\nSim\nSim\nSim\nInício\n\n\na+\nSim\nSim\nSim\nFim\n\n\n\n\nLeitura e escrita formatada ```c int a = 10; float b = 3.14; char c = ‘a’; // escreve no ficheiro os valores de a, b e c fprintf(ficheiro, “%d %f %c”, a, b, c); // lê do ficheiro os valores de a, b e c // devolve EOF se apanhar o fim do ficheiro fscanf(ficheiro, “%d %f %c”, &a, &b, &c);\nchar linha[100]; // lê uma linha do ficheiro (ou um máximo de 100 char) e guarda em linha // devolve NULL se apanhar o fim do ficheiro fgets(linha, 100, ficheiro);\nfgetc(ficheiro); // lê um char do ficheiro fputc(‘a’, ficheiro); // escreve um char no ficheiro fputs(“ola”, ficheiro); // escreve uma string no ficheiro ```\nLeitura e escrita ficheiros binários\nint a = 10;\nint n_lidos, n_escritos;\nFILE *ficheiro = fopen(\"nome_ficheiro\", \"wb\");\nn_escritos=fwrite(&a, sizeof(int), 1, ficheiro); // escreve no ficheiro o valor de a\nfclose(ficheiro);\n\nficheiro = fopen(\"nome_ficheiro\", \"rb\");\nn_lidos=fread(&a, sizeof(int), 1, ficheiro); // lê do ficheiro o valor de a\nfclose(ficheiro);\nPosicionamento no ficheiro\n// posiciona o cursor no ficheiro na posição 10\nfseek(ficheiro, 10, SEEK_SET);\n// posiciona o cursor no ficheiro 10 posições à frente da posição atual\nfseek(ficheiro, 10, SEEK_CUR);\n// posiciona o cursor no ficheiro 10 posições antes do fim do ficheiro\nfseek(ficheiro, -10, SEEK_END);\nftell(ficheiro); // devolve a posição atual do cursor no ficheiro\nrewind(ficheiro); // posiciona o cursor no início do ficheiro"
  },
  {
    "objectID": "exercises/exercicios.html",
    "href": "exercises/exercicios.html",
    "title": "Programação",
    "section": "",
    "text": "Os exercícios denominados “King …” são retirados do livro\n“C Programming: A Modern Approach, 2nd Edition” do K. N. King"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-io-formatado-king",
    "href": "exercises/exercicios.html#exercícios-io-formatado-king",
    "title": "Programação",
    "section": "Exercícios I/O Formatado King",
    "text": "Exercícios I/O Formatado King\n–\n\nKing 3.1. mudar formato de data\nEscreve um programa que aceita uma data do utilizador no formato “dd/mm/aaaa” e escreve na consola a mesma data no formato “aaaa-mm-dd”.\nInsira data: 01/02/2023\nEscreveu:    2023/02/01\n–\n\n\nKing 3.2. formatar input produtos\nEscreve um programa que formata os dados de um produto inseridos pelo utilizador.\nInsira o ID do produto: 583\nInsira o preço: 13.5\nInsira a data de aquisição (dd/mm/aaaa): 24/10/2010\n\nItem        Preço       Data da\n            Unitário    Compra\n583         €    13.5   2010/10/24\nNota: o ID do item e a data deve estar alinhados à esquerda; o preço unitário deve estar alinhado à direita. Dica: usa “ para alinhas as colunas.\n–\n\n\nKing 3.3. Ver livro\n–\n\n\nKing 3.4. Ver livro\n–\n\n\nKing 3.5. Ver livro\n–\n\n\nKing 3.6. frações\nEscreve um programa que recebe 2 frações do utilizador e escreve a sua soma. O programa recebe as duas frações de uma só vez, separadas por +.\nInsira as fracoes: 5/6+3/4\nSoma: 38/24"
  },
  {
    "objectID": "exercises/exercicios.html#king",
    "href": "exercises/exercicios.html#king",
    "title": "Programação",
    "section": "King",
    "text": "King\n–\n\nKing 4.1. inverter 2 digitos\nEscreve um programa que pede ao utilizar um número inteiro de 2 digitos e devolve esse número com os digitos invertidos. Exemplo de execução:\nInsira número inteiro: 42\nInvertido:             24\nOs 2 números devem estar alinhados.\nDica: %10 devolve o último digito de um número e /10 remove o último digito.\n–\n\n\nKing 4.2 inverter 3 digitos\nExtende o programa anterior (King 4.1.) para números de 3 digitos.\n–\n\n\nKing 4.3 inverter 3 digitos, variante\nReimplementa o programa do King 4.2 sem usar aritmética."
  },
  {
    "objectID": "exercises/exercicios.html#king-1",
    "href": "exercises/exercicios.html#king-1",
    "title": "Programação",
    "section": "King",
    "text": "King\n\nKing 5.1 quantos digitos\nEscreve um programa que recebe um número inteiro e indica quantos digitos esse número tem.\nAssume que o número nunca tem mais de 4 digitos.\nIntroduza numero inteiro (maximo 4 digitos): 42\n# digitos:                                   2\nAjuda: usa if para fazer essa verificação, e.g. se o número estiver entre 10 e 99, então tem 2 digitos.\n\n\nKing 5.2 conversão AM/PM\nEscreve um programa que recebe uma hora no formato de 0-24h e converte para o formato 0-12h.\nIntroduza hora no formato 24h: 23:32\nHora no formato 12h:           11:32 PM\n\nIntroduza hora no formato 24h: 10:32\nHora no formato 12h:           10:32 AM\n\n\n\nKing 5.3. Ver livro\n\n\nKing 5.4 escala Beaufort\nA escala de Beaufort indica uma descrição do vento com base na sua velocidade. Uma versão simplificada é a seguinte:\n\n\n\nSpeed (knots)\nDescription\n\n\n\n\n&lt;1\nCalm\n\n\n1-3\nLight air\n\n\n4-27\nBreeze\n\n\n28-47\nGale\n\n\n48-63\nStorm\n\n\n&gt;63\nHurricane\n\n\n\nEscreve um programa que recebe a velocidade do vento e indica a descrição correspondente.\n\n\nKing 5.5 escalões IRS\nO imposto cobrado sobre o rendimento é feito de forma progressiva por escalões (exemplo no slide seguinte). Versão simplificada dos escalões de 2023:\n\nEscreve um programa que recebe o rendimento anual bruto e indica o imposto total sobre o rendimento e o rendimento líquido final.\nImposto progressivo significa que o mesmo rendimento vai ser tributado em escalões diferentes, e.g.\nRendimento: 20000€\nTributaçao no escalão 1: 7116 * 14,5%\nTributaçao no escalão 2: (15216 - 7116) * 23%\nTributaçao no escalão 3: (20000 - 15216) * 28,5%\nTributaçao no escalão 4 e 5 não existe porque o\nrendimento não é alto o suficiente.\n\n\nKing 5.6 Ver livro\n\n\nKing 5.7 min e max de 4 números\nEscreve um programa que recebe 4 números inteiros e indica o número mais alto e o mais pequeno.\nEnter four integers: 21 43 10 35\nLargest: 43\nSmallest : 10\nUsa o mínimo de if possível.\nAjuda: 4 if são suficientes.\n\n\nKing 5.8 voo mais próximo Ver livro\n\n\nKing 5.9 data menor\nEscreve um programa que pede 2 datas ao utilizador e indica qual é a data que vem antes no calendário.\nData 1: 3/6/2007\nData 2: 3/6/2005\n3/6/2005 vem antes de 3/6/2007\n\n\nKing 5.10 nota para letra\nEscreve um programa que converte uma nota entre 0 e 100 para uma letra, segundo a seguinte correspondência: A = 90-100, B = 80-89, C = 70-79, D = 60-69, F = 0-59.\nA nota é lida do utilizador. Usa uma instrução switch para implementar o programa. O programa indica uma mensagem de erro se a nota for inferior a 0 ou superior a 100.\nNota: 84\nLetra: B\n\nNota: -1\nErro, nota deve estar entre 0 e 100.\nAjuda: usa o primeiro digito da nota para fazer a correspondência no switch.\n\n\nKing 5.11 número por extenso\nEscreve um programa que recebe um inteiro de 2 digitos e escreve o número por extenso. Implementa o programa sem if.\nNota: 42\nLetra: quarenta e dois"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-seleção-afa",
    "href": "exercises/exercicios.html#exercícios-seleção-afa",
    "title": "Programação",
    "section": "Exercícios Seleção AFA",
    "text": "Exercícios Seleção AFA\n\nAFA 5.1. Converte gramas para outras unidades\nEscreve um programa que converte entre unidades de massa. O programa primeiro pede o valor da massa em gramas. Depois mostra um menu com as opções de conversão. O utilizador recebe a unidade de destino e no final o programa mostra a massa convertida.\nIntroduza massa em gramas: 500\nQual e a unidade de conversao:\n1 - oz\n2 - lb\n3 - kg\nEscolha: 3\n500 g = 0.5000 kg\n\n\nAFA 5.2 Converter unidades de massa\nAltera o programa AFA 5.1 para se possa converter entre quaisquer 2 unidades. Para conseguir isto, o programa pede o valor da massa, depois pede a unidade desse valor e finalmente a unidade da conversão.\nIntroduza massa em gramas: 500\nQual e a unidade desta masa:\n1 - oz\n2 - lb\n3 - kg\n4 - g\nEscolha: 4\n\nQual e a unidade de conversao:\n1 - oz\n2 - lb\n3 - kg\nEscolha: 3\n\n500 g = 0.5000 kg"
  },
  {
    "objectID": "exercises/exercicios.html#ciclos-king",
    "href": "exercises/exercicios.html#ciclos-king",
    "title": "Programação",
    "section": "Ciclos King",
    "text": "Ciclos King\n\nKing 6.1. Maior número de série recebida\nEscreve um programa que encontra o maior número numa série de números introduzidos pelo utilizador. O programa pede os números um a um, até encontrar um número seguido da letra f.\nNúmero: 60\nNúmero: 38.3\nNúmero: 4.89\nNúmero: 100.62\nNúmero: 75.2295f\n\nNúmero maior: 100.62\n\n\nKing 6.2. Máximo Divisor Comum\nEscreve um programa para calcular o máximo divisor comum (MCD) entre 2 inteiros. O programa pede 2 inteiros ao utilizador e indica o MCD.\nNumeros: 12 28\nMCD: 4\nA estratégia mais simples (embora menos eficiente) é verificar o resto da divisão dos 2 números recebidos por todos os números a partir do menos dos 2 recebidos até 1. Assim que encontrar um número cujo resto das duas divisões seja 0, é esse o MCD, e.g.\n28 % 12 != 0\n12 % 12 == 0\n--\n28 % 11 != 0\n12 % 11 != 0\n--\n28 % 10 != 0\n12 % 10 != 0\n--\n    .\n    .\n    .\n28 % 4 == 0\n12 % 4 == 0\nMCD = 4 -&gt; parar ciclo\n\n\nKing 6.3. Simplificar fração\nEscreve um programa que recebe 1 fração e simplifica-a.\nIntroduza fracao: 6/12\nSimplificada: 1/2\nDica: usar a implementação do 6.2. para dividir o numerador e denominador pelo máximo divisor comum.\n\n\nking 6.5.\nEscreve um programa que recebe um inteiro (de qualquer tamanho) e inverte os digitos. Usar apenas aritmética.\n\n\nKing 6.6. Quadrados inferiores a n\nEscreve um programa que recebe um número n e escreve na consola todos os quadrados pares inferiores a n. Por exemplo, se o utilizador introduzir 100:\n4\n16\n36\n64\n100"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-ciclos-afa",
    "href": "exercises/exercicios.html#exercícios-ciclos-afa",
    "title": "Programação",
    "section": "Exercícios Ciclos AFA",
    "text": "Exercícios Ciclos AFA"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-tipos-king",
    "href": "exercises/exercicios.html#exercícios-tipos-king",
    "title": "Programação",
    "section": "Exercícios Tipos King",
    "text": "Exercícios Tipos King\n\nKing 7.1. modificado\nEscreve um programa que determina o menor número cujo quadrado causa overflow para int. Modifica o programa para usar short int, unsigned int, long, unsigned long.\nPara valores inteiros, o valor máximo é dado por 2^n, onde n é o número de bits. Com base nos resultados, consegues perceber qual é o número de bits usado para cada tipo?\nA executar para int\nLado do primeiro quadrado que causa overflow: 46341\nQuadro que causa overflow: -2147479015\nUltimo quadrado antes de overflow: 2147395600\nDica: para verificar quando houve overflow, verifica quando um determinado quadrado passa a ser menor que o quadrado anterior.\n\n\nKing 7.2 Ver livro\n\n\nKing 7.3 Ver livro\n\n\nKing 7.4 Número teclas telemóvel -&gt; número\nEscreve um programa que recebe um conjunto de letras e converte para um número, com a conversão usada nos teclado alfanuméricos antigos.\nNumero em letras: CALLAT\nNumero: 225\nCorrespondência: 2=ABC, 3=DEF, 4=GHI, 5=JKL, 6=MNO, 7=PRS, 8=TUV, 9=WXY\nSe o número original contém carateres não numéricos, devem permanecer inalterados:\nNumero em letras: 1-800-COL-LECT\nNumero: 1-800-265-5328\nAssunção: todos os carateres são em letras maiúsculas.\nAjuda: - mesmo que um scanf peça apenas 1 char, o utilizador pode inserir um input do tamanho que quiser (até ) - podemos ler os restantes carateres com sucessivas chamadas a scanf ou getchar.\n\n\nKing 7.5. scrabble Ver livro\n\n\nKing 7.7. frações\nRefaz o problema King 3.6, mas agora o utilizador pode também escolher a operação entre frações (+, -, *, /).\n\n\nKing 7.8. Ver livro\n\n\nKing 7.9. Horas AM/PM\nCom base na lógica do exercício King 5.2, implementa um programa que agora recebe uma hora no formato 12h e converte para 24h. A hora pode ser recebida das seguintes formas:\n1:15P\n1:15PM\n1:15Pm\n1:15 PM\n1:15 P\n1:15p\n1:15pm\n1:15 pm\n1:15 p\nExemplo de utilização:\nHora 12: 9:11PM\nHora 24: 21:11\n\n\nKing 7.10 Contar vogais\nEscreve um programa que recebe uma frase do utilizador e conta o número de vogais.\n\n\nKing 7.11 Trocar nome\nEscreve um programa que recebe o primeiro e último nome do utilizador, e depois apresenta o nome no formato Ultimo, Primeira letra do primeiro.\nNome: Diogo Silva\nSilva, D.\n\n\nKing 7.12 Avaliar expressão\nEscreve um programa que avalia uma expressão matemática.\nExpressao: 1+2.5*3\nResultado: 10.2\nNotas: - As operações válidas são +, -, *, /. - Os operandos são todos intepretados como valores reais. - Não introduzir parêntises. - Calcular as operações da esquerda para a direita sem atenção à precedência de operações.\n\n\nKing 7.13. Tamanho médio das palavras\nEscreve um programa que recebe uma frase do utilizador e indica o tamanho médio das palavras.\nFrase: Este programa parece mais dificil do que e.\nTamanho medio das palavras: 4.5\nNota: para simplificar, assume que a pontuação faz parte da palavra.\n\n\nKing 7.14 Ver livro"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-tipos-afa",
    "href": "exercises/exercicios.html#exercícios-tipos-afa",
    "title": "Programação",
    "section": "Exercícios Tipos AFA",
    "text": "Exercícios Tipos AFA\n\nAFA 7.1. minúscula -&gt; maiúscula\nEscreve um programa que recebe uma letra minúscula e converte para maiúscula.\n\n\nAFA 7.2. frase -&gt; minúsculas\nEscreve um programa que recebe uma frase e converte todas as letras para minúsculas. Todos os carateres que não são letras maiúsculas não são modificados.\n\n\nAFA 7.3. César letra\n\nEscreve um programa que recebe uma letra e um inteiro (chave), e implementa a cifra de César.\nA cifra de César é um método simples para codificar uma mensagem, com a simples translação do abecedário.\nPor exemplo, se a chave tem o valor 1, então o ‘A’ é convertido para ‘B’, ‘B’ para ‘C’, ‘Z’ para ‘A’.\nSe a chave for negativa, a conversão é no sentido oposto.\nConverte apenas letras.\n\nChave: 2\nLetra: L\nLetra codificada: N\n\n\nAFA 7.4. César frase\n\nEscreve um programa que recebe uma frase e uma chave, e codifica a frase com a cifra de César.\nUsa a lógica do exercício AFA 7.3.."
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-funções-king",
    "href": "exercises/exercicios.html#exercícios-funções-king",
    "title": "Programação",
    "section": "Exercícios Funções King",
    "text": "Exercícios Funções King\n\nKing 9.2. IRS\nReimplementa o exercício King 5.5. na forma de função. A função tem o nome calcular_irs, recebe um rendimento sobre a forma de um valor real e devolve outro valor real correspondente ao imposto devido.\nO programa pede um rendimento ao utilizador e indica no final o imposto devido e o rendimento total líquido (o valor recebido menos o imposto).\nNotas: - a função criada não lê valores da consola nem os escreve - leitura e escrita na consola é feita na função main\n\n\nKing 9.6. polinómio\nEscreve uma função que recebe um valor real x e devolve o resultado da avaliação desse valor no seguinte polinómio:\n3x^5 + 2x^4 - 5x^3 - x^2 + 7x - 6\nNotas:\n\nx^5 significa x \\times x \\times x \\times x \\times x, x^4=…\nresolva primeiro o exercício AFA 8.1. e use essa função para calcular as potências"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-funções-afa",
    "href": "exercises/exercicios.html#exercícios-funções-afa",
    "title": "Programação",
    "section": "Exercícios Funções AFA",
    "text": "Exercícios Funções AFA\n\nAFA 8.1. potência\nEscreve uma função chamada potencia que recebe uma base b (valor real) e um expoente e (inteiro). A função devolve o revolve o resultado da potência.\nNota: - quando um expoente é negativo, o resultado final é 1/(b^e). - não ler nem escrever da consola - usar a função main para testar se a função está a funcionar correctamente.\n\n\nAFA 8.2. máximo divisor comum\n\nReimplementa o exercício do máximo divisor comum (King 6.2.) na forma de função.\nA função\n\nchama-se calcular_mdc\nrecebe 2 valores inteiros\ndevolve o MDC entre esses 2 valores\n\n\n\n\nAFA 8.3. tabela de polinómio\n\nImplementa uma função que avalia um polinómio de 2º grau num determinado intervalo.\nA função\n\nchama-se poli2_intervalo\nrecebe o limite inferior e limite superior do intervalo a avaliar (reais)\nrecebe o número de pontos a avaliar (inteiro positivo)\nrecebe os 3 coeficientes (reais)\nescreve na consola o valor do polinómio nos pontos\ndevolve o valor do polinómio no ponto limite superior\n\n\nA tabela produzida deve ter o seguinte aspeto (se a=0.0, b=1.0, c=0.0, limInf=0.0, limSup=1.0, numPontos=5):\n   ponto    resultado do polinómio no ponto\nf(0.000000) = 0.000000 \nf(0.250000) = 0.250000 \nf(0.500000) = 0.500000 \nf(0.750000) = 0.750000 \nf(1.000000) = 1.000000 \nPossível procedimento: 1. Descobrir a distância entre os pontos a avaliar. 2. Inicializar o ponto a avaliar no limite inferior. 3. Calcular o polinómio no ponto. 4. Incrementar o ponto com a distância entre pontos. 5. Repetir 3-4 até chegar ao limite superior.\nNotas: - Além da função poli2_intervalo, implementa a função poli2_ponto que recebe os coeficientes do polinómio, o ponto x a avaliar e devolve o resultado desse polinómio no ponto recebido (ver exercício King 9.6) - Valores introduzidos pelo utilziador (coeficiente, limite inferior, superior, e nº de pontos) são pedidos na função main. - Um dos primeiros cálculos será a distância entre 2 pontos, e.g. no exemplo acima a distância entre pontos é de 0.25.\n\n\nAFA 8.4. polinómio grau n\n\nEscreve uma função que avalia um polinómio de grau N num determinado ponto.\nA função\n\nchama-se poliN_ponto\nrecebe apenas o ponto onde o polinómio será avaliado\npede ao utilizador o valor dos coeficientes, começando no grau menos elevado (0)\npára de pedir coeficientes quando um dos coeficientes é seguido da letra f (ver King 6.1.)\ndevolve o valor do polinómio no ponto recebido\n\n\nNotas: - o ponto a ser avaliado é recebido na main - o resultado do polinómio deve ser escrito para a consola na main, com 4 casas decimais\nExemplo:\nPonto: 1.0\nCoeficiente do grau 0: 1.0\nCoeficiente do grau 1: 0\nCoeficiente do grau 2: 0\nCoeficiente do grau 3: 2f\nResultado: 1.00\n\n\nAFA 8.5. Lab1 - Part 1 Calendário\n\nImplementa uma função que recebe o número de dias de um mês e o dia da semana do primeiro dia do mês e escreve um calendário na consola.\nO dia da semana é dado como um inteiro:\n\n0=domingo, 1=segunda-feira, 2=terça-feira,…\n\nPara um mês com 31 dias a começar a uma terça-feira, o calendário tem o seguinte formato.\n----------\n D  2  3  4  5  6  S\n       1  2  3  4  5\n 6  7  8  9 10 11 12\n13 14 15 16 17 18 19\n20 21 22 23 24 25 26\n27 28 29 30 31\n----------\nA função tem o seguinte cabeçalho:\n\nvoid escrever_calendario_mes(unsigned char n_dias, unsigned char dia_semana_inicio)\n\n\n\n\nAFA 8.6. Lab1 - Part 2.1 Calendário de data\n\nEscreve uma função que recebe um ano e um mês, e escreve na consola o calendário desse mês, usando a função da Parte 1.\nAssume que o mês de fevereiro tem sempre 28 dias.\nAssume que o mês começa sempre a uma terça-feira.\nA função tem o seguinte cabeçalho:\n\nvoid escrever_calendario_data(unsigned int ano, unsigned char mes)\n\nSe não resolveste a Parte 1, chama a função escrever_calendario_mes como se tivesse sido correctamente implementada. Nota que não vais conseguir executar o código, mas a pontuação será dada.\n\nAjudas: - Código para o número de dias em cada mês: c    int dias_no_mes;    switch(mes){      case 1:      case 3:      case 5:      case 7:      case 8:      case 10:      case 12:        dias_no_mes = 31; break;      case 4:      case 6:      case 9:      case 11:        dias_no_mes = 30; break;      case 2:        dias_no_mes = 28; break;      default:        dias_no_mes = 0;    }\n\n\nAFA 8.7. Lab 1 - Part 2.2 - dia da semana\n\nEscreve uma função que recebe uma data e devolve o dia da semana dessa data, como um inteiro.\nA função tem o seguinte cabeçalho:\n\nunsigned char dia_da_semana(unsigned int ano, unsigned char mes, unsigned char dia)\n\nO lógica desta função já nos foi dado e é o seguinte:\nif (mes &lt; 3) {\n        mes += 12;\n        ano -= 1;\n    }\n\nseculo = ano / 100;\nanoNoSeculo = ano % 100;\n\ndiaDaSemana = dia + 13*(mes+1)/5 + anoNoSeculo + anoNoSeculo/4 + seculo/4 + 5*seculo;\ndiaDaSemana %= 7;\n\n// converter para que o domingo=0, segunda=1, ...\ndiaDaSemana = (diaDaSemana + 6) % 7;\nModifica a função da parte 2.1. para que agora, o dia de início do mês seja calculado com esta função.\n\n\n\nAFA 8.8. Lab 1 - Part 2.3 - Ano bissexto\n\nEscreve uma função para calcular se um ano é bissexto.\nUm ano é bissexto se for (múltiplo de 4 E múltiplo de 100) OU (múltiplo de 400).\nO cabeçalho da função é o seguinte:\n\nunsigned char ano_bissexto(unsigned int ano)\n\nModifica a função da Parte 2.1. para que, se o mês for fevereiro, o número de dias do mês é correctamente calculado."
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-array-king",
    "href": "exercises/exercicios.html#exercícios-array-king",
    "title": "Programação",
    "section": "Exercícios Array King",
    "text": "Exercícios Array King\n\nKing 8.1. digitos repetidos\n\nImplementa um programa que recebe um inteiro do utilizador e indica quais são os digitos repetidos.\nNo final o programa indica quais são os digitos repetidos, por ordem crescente.\n\nExemplo:\nNumero inteiro: 939577\nRepetidos: 7 9\n\n--\n\nNumero inteiro: 9339577\nRepetidos: 3 7 9\n\n\nKing 8.2. histograma digitos\nModifica o programa King 8.1. para devolver quantas vezes cada digito aparece num dado número.\nNumero inteiro: 41271092\nDigitos:    0   1   2   3   4   5   6   7   8   9\nContagem:   1   2   2   0   1   0   0   1   0   1\n\n\nKing 8.7. matriz 5x5\n\nEscreve um programa que recebe uma matriz de 5x5, linha a linha, e escreve no final o total de cada linha e de cada coluna.\nGuarda a matriz num array bidimensional.\n\nExemplo:\nLinha 1: 8 3 9 0 10\nLinha 2: 3 5 17 1 1\nLinha 3: 2 8 6 23 1\nLinha 4: 15 7 3 2 9\nLinha 5: 6 14 2 6 0\n\nTotais linhas: 30 27 40 36 28\nTotais colunas: 34 37 37 32 21\n\n\nKing 8.8. notas testes alunos\n\nModifica o programa King 8.7. para que cada linha corresponda para as 5 notas de testes de um aluno\nO programa indica a nota final (soma) do aluno, assim como a média de cada teste.\nO programa indica ainda, para cada teste, qual foi a nota mínima, máxima e média.\n\n\n\nKing 8.9. random walk\n\nEscreve um programa que gera um passeio aleatório num array 10x10.\nInicialmente todas as posições do array têm o carater ‘.’\nO programa não pode voltar para uma posição já visitada anteriormente.\nCada vez que o programa visita uma posição, essa posição fica com o valor A,B,C… pela ordem de visita.\nÉ necessário verificar se a posição de destino selecionada está dentro da matriz.\nSe por acaso todas as direções possíveis estiverem bloqueadas (ocupadas ou fora da matriz), o programa acaba.\nO passeio acaba na letra Z.\nO programa mostra a matriz apenas no final do passeio.\n\nExemplo normal:\nA . . . . . . . . .\nB C D . . . . . . .\n. F E . . . . . . .\nH G . . . . . . . .\nI . . . . . . . . .\nJ . . . . . . . Z .\nK . . R S T U V Y .\nL M P Q . . . W X .\n. N O . . . . . . .\n. . . . . . . . . .\nExemplo de terminação prematura (acabou no Y):\nA B G H I . . . . .\n. C F . J K . . . .\n. D E . M L . . . .\n. . . . N O . . . .\n. . W X Y P Q . . .\n. . V U T S R . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\n. . . . . . . . . .\nNotas: - para gerar números aleatórios, usar a função rand (ver exemplo abaixo)\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main () {\n   int i, n;\n   time_t t;\n   \n   n = 5;\n   \n   /* Intializes random number generator */\n   srand((unsigned) time(&t));\n\n   /* Print 5 random numbers from 0 to 49 */\n   for( i = 0 ; i &lt; n ; i++ ) {\n      printf(\"%d\\n\", rand() % 50);\n   }\n   \n   return(0);\n}\n\n\nKing 9.1. selection sort\n\nEscreve um programa que recebe um conjunto de inteiros do utilizador e, no final, mostra esses números ordenados.\nO programa recebe os números um a um até que um dos números tenha um ‘f’ após o último digito, e.g. 42f.\nO programa guarda os números num array.\nAssuma que o número máximo de inteiros a receber é 200.\nO programa ordena os números do array com a função selection_sort.\nA função selection_sort recebe um vector e ordena-o. Para isso, faz o seguinte:\n\nProcura no array o maior elemento e passa-o a última posição.\nProcura no array o segundo maior elemento e passa-o para a penúltima posição.\n…\nRepetir n-1 vezes, em que n é o tamanho do vetor.\nO uso de recursão é especialmente adequado.\n\nOs inteiros são pedidos na main.\n\n\n\nKing 9.3. modificado, random walk\n\nModifica o problema King 8.9 para que seja implementado com 3 funções:\n\nvoid fill_array(char walk[10][10], char f) recebe a matriz e preenche em todas as posições da matriz o carater f.\nrandom_walk_generator(char walk[10][10]) recebe a matriz e gera uma nova random walk com a lógica do King 8.9.\nprint_array(char walk[10][10]) recebe a matriz e escreve-a na consola.\n\nNa função main, apenas deve ser criada a matriz e o programa implementa as funcionalidades pretendidas chamando estas funções.\n\n\n\nKing 9.5. magic square\n\n\nEscreve um programa que escreve uma matriz n x n:\n\ncom todos os números de 1 até n^2\nem que a soma de todas as linhas, colunas e diagonais são iguais\nn tem de ser um inteiro ímpar entre 1 e 99\n\nO utilizador especifica a dimensão da matriz, indicando o valor n.\nImplementa a lógica na função generate_magic_square, que recebe um vetor de tamanho variável.\nPara construir a matriz:\n\ncomeçar por escrever 1 no meio da primeira linha\nescrever os valores seguintes na linha acima e na coluna seguinte\nse a linha acima estiver fora da matriz, deve-se dar a volta, e.g. -1 -&gt; n-1\nse a coluna à direita estiver fora da matriz, deve-se dar a volta, e.g. n -&gt; 0\nse a posição já estiver ocupada, deve-se colocar o número na posição abaixo da última posição preenchida.\n\nEscreve uma função print_magic_square que recebe a matriz e apresenta o resultado na consola.\nDeve também indicar qual é o valor da soma das linhas, colunas e diagonais, que é o mesmo valor.\n\nExemplo:\nIntroduza um inteiro ímpar entre 1 e 99: 5\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-array-afa",
    "href": "exercises/exercicios.html#exercícios-array-afa",
    "title": "Programação",
    "section": "Exercícios Array AFA",
    "text": "Exercícios Array AFA\n\nAFA 9.1. polinómio\n\nEscreve uma função poliN que recebe um vetor coef de reais que pode ter qualquer tamanho (deve também receber outro parâmetro n com o tamanho real do vector) e um real x.\nA função avalia um polinómio de grau n-1 no ponto x.\nOs coeficientes do polinómio estão no vetor recebido.\nPode usar a função pow (da biblioteca math.h) para calcular as potências (ou usar a solução do exercício AFA 8.1.).\ncoef[0] corresponde ao coeficiente de menor grau, coef[1] corresponde ao coeficiente do 2º menor grau, …\nPara um polinómio de grau 3:\n\ncoef[0] + coef[1] * x + coef[2] * x^2\nExemplo de utilização da função pow:\n#include &lt;math.h&gt;\n\nint main(){\n  printf(\"2^2 = %lf\", pow(2.0, 2.0));\n}\n\n\nAFA 9.2. IRS generalizado\n\nReimplementa o exercício King 9.2. para funcionar para qualquer número de escalões e com quaisquer limites dos escalões.\nA função recebe um vetor de reais (escaloes) com n elementos, correspondentes aos limites dos escalões.\nExistem no total n-1 escalões.\nescaloes[0] é o limite inferior do primeiro escalão, escalores[1] é o limite superior do primeiro escalão e o inferior do segundo, etc.\nA função recebe ainda um vetor de reais (taxas) com n-1 elementos que contém a taxa a aplicar em cada escalão: taxas[0] é a taxa a aplicar no rendimento do primeiro escalão, taxas[1] é a taxa a aplicar no rendimento do segundo escalão, etc.\n\nDicas: - a lógica para um determinado escalão é sempre igual, mudando apenas os limites do escalão e a taxa a aplicar; - implementa uma função auxiliar para calcular o imposto num determinado escalão; - usa vetores de tamanho variável;\n\n\nAFA 9.3. Ordenar array 2\n\nImplementa uma função que recebe um vector de inteiros de qualquer tamanho e um char.\nO char indica se o vetor deve ser ordenado de forma crescente ou decrescente.\nA função ordena o vector da forma indicada pelo char.\nUsa a implementação do King 9.1\n\nPodes criar outra função para ordenar de forma decrescente e a função deste exercício chama a função do AFA 9.3 (crescente) ou a função para ordenar de forma decrescente, conforme o que seja indicado pelo char.\n\n\n\n\nAFA 9.4. Ordenar indices array\n\n\nImplementa uma função que recebe:\n\num vector de inteiros vals de qualquer tamanho\num vector de inteiros positivos indeces do mesmo tamanho do vals\n\nA função:\n\ninicializa o vetor indeces com os indices de vals (0,1,2,3…)\nmuda a ordem de indeces de forma a refletir uma ordenação crescente do conteúdo de vals\n\n\nExemplo:\nInput:\n   vals:   42  1  9  87\nindeces:    ?  ?  ?   ?\n\nDepois de inicializar indices:\n   vals:   42  1  9  87   (não foi alterado)\nindeces:    0  1  2   3\n\nDepois de ordenar:\n   vals:   42  1  9  87   (não foi alterado)\nindeces:    1  2  0   3\n\n\nAFA 9.5. Redes neuronais: Perceptron\n\nEscreve uma função que implementa um perceptron, que é um conceito da área de inteligência artificial.\nO perceptron recebe um vetor de inteiros x (o input do perceptron) e um vetor de reais w (os pesos de cada input e o bias).\nO vetor x tem tamanho n e o vetor w tem tamanho n+1.\nO perceptron calcula o produto escalar de x e w e devolve 1 se o resultado for positivo e 0 se for negativo ou zero.\nO último elemento do vetor w é o bias.\nO bias é um valor que é adicionado ao produto escalar.\nA fórmula do output do perceptron é a seguinte:\n\n\n\\begin{equation}\n  output = \\begin{cases}\n    1 & \\text{se } (\\sum_{i=1}^{n} x_i \\times w_i) + b &gt; 0 \\\\\n    0 & \\text{caso contrário}\n  \\end{cases}\n\\end{equation}\n\n\n\n\nDiagrama do Perceptron\n\n\n\nO cabeçalho da função é o seguinte:\n\nint perceptron(int n, int x[n], double w[n+1]);\n\nTesta a função com pesos e inputs diferentes.\n\n\n\nAFA 9.6. Redes neuronais: combinar perceptrons\n\nOs perceptrons podem ser combinados para formar redes neuronais mais complexas.\n\n\n\n\nDiagrama de uma rede neuronal\n\n\n\nNo diagrama acima, cada nó da primeira coluna é um dos inputs da rede x_1, x_2, ..., x_n.\nCada nó da segunda, terceira e quarta colunas é um perceptron que recebe os inputs da primeira coluna e devolve um output.\nO output de cada perceptron é o input dos perceptrons da coluna seguinte.\nEscreve uma função que recebe um vetor de reais x (o input da rede) e uma matriz de reais w (os pesos de cada perceptron e o bias).\nO vetor x tem tamanho n e a matriz w tem m linhas e n+1 colunas.\nCada linha da matriz w corresponde aos pesos de um perceptron, portanto a matriz tem m perceptrons.\nA função recebe ainda um vector de reais correspondente aos outputs de cada perceptron.\nO cabeçalho da função é o seguinte:\nvoid camada_perceptron(int n, int m, double x[n], double w[m][n+1], double output[m]);\nA função calcula o output de cada perceptron e guarda-o no vetor output.\nO output de cada perceptron é calculado da mesma forma que no exercício anterior.\nPor exemplo, para um input de 3 elementos e uma camada de 4 perceptrons, a função recebe um vetor x de tamanho 3, uma matriz w de tamanho 4x4 e um vetor output de tamanho 4. O output de cada perceptron seria calculado da seguinte forma:\noutput[0] = perceptron(n, x, w[0]);\noutput[1] = perceptron(n, x, w[1]);\noutput[2] = perceptron(n, x, w[2]);\noutput[3] = perceptron(n, x, w[3]);\nEscreve a função para que funcione para qualquer tamanho de input e qualquer número de perceptrons.\n\n\n\nAFA 9.7. Redes neuronais: rede completa\n\nEscreve um programa completo que implemente uma rede neuronal com 3 elementos de input, uma camada de 4 perceptrons e uma camada final de 1 perceptron.\nCria os vectores necessários para acomodar os inputs e outputs de cada camada.\nCria as matrizes necessárias para acomodar os pesos de cada camada.\nUsa valores arbitrários para os pesos e inputs e testa o programa.\nUsa a função camada_perceptron do exercício anterior para implementar a rede neuronal."
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-strings-king",
    "href": "exercises/exercicios.html#exercícios-strings-king",
    "title": "Programação",
    "section": "10 Exercícios Strings King",
    "text": "10 Exercícios Strings King\n\nKing 13.1 palavras ordem alfabética\n\nEscreve um programa que recebe uma série de palavras.\nO programa pára de pedir palavras quando receber uma palavra de 4 letras.\nAssume-se que nenhuma palavra tem mais de 20 letras.\nNo final o programa indica a primeira e última palavras, se as palavras recebidas tivessem ordenadas por ordem alfabética.\n\nPalavra: peixe\nPalavra: rinoceronte\nPalavra: laranja\nPalavra: livro\nPalavra: ananas\nPalavra: gato\n\nPrimeira: ananas\nÚltima: rinoceronte\nDica: - Usa a função strcmp da biblioteca string.h, que recebe 2 strings (s1 e s2) e devolve 0 se s1 e s2 forem iguais, devolve um valor negativo se o primeiro caracter diferente de s1 for inferior ao primeiro carater diferente de s2, ou um valor positivo se o primeiro carater diferente de s1 for superior ao primeiro carater diferente de s2.\n\n\nKing 13.4 inverter frase, modificado\n\nEscreve um programa que recebe uma frase do utilizador.\nO programa escreve as palavras na ordem inversa às que as recebeu.\n\nFrase:\nexercicio demasiado facil\n\nfacil demasiado exercicio\n\n\nKing 13.5 executar string de soma, modificado\n\nEscreve um programa que recebe uma frase do utilizador do tipo “soma 8 24 62”\nAssume que soma é a única operação.\nPara implementar o programa, implementa uma função que recebe uma string com uma lista de números e devolve a soma desses números.\nA main pede uma string com fgets e usa esta função para calcular a soma.\nDicas:\n\nA função strtok da biblioteca string.h divide uma string de acordo com um separador\n\nrecebe a string a separar e a string que contém o separador\ndepois da primeira chamada de strtok, o primeiro argumento deve ser NULL\nstrtok devolve uma string com a próxima “palavra” (token) separada pelo separador indicado, ou NULL se não houverem mais tokens.\n\nA função atof da biblioteca stdlib.h recebe uma string (com um número) e devolve um número real.\n\nExemplo strtok\n\neste programa divide a string str nas suas palavras constituintes (separadas por um espaço) e escreve essas palavras, uma a uma, em linhas separadas.\nrepara que só a primeira chamada de strtok é que contém a string a processar, as restantes usam NULL nesse argumento.\nrepara que verificamos se a string devolvida é NULL para verificar quando existem algum valor de interesse.\ncódigo: ````c #include &lt;stdio.h&gt; #include &lt;string.h&gt;\nint main() { char str[] = “The quick brown fox”; char* token = strtok(str, ” “);\nwhile (token != NULL) {\n    printf(\"%s\\n\", token);\n    token = strtok(NULL, \" \");\n}\n\nreturn 0;\n} ```\n\nExemplo atof `c   #include &lt;stdlib.h&gt;   int main(){     printf(\"num=%lf\", atof(\"3.14\"));   }\n\n\n\nKing 13.11 tamanho media das palavras, modificado\n\nCom base no exercício King 7.13, escreve um programa que pede frases ao utilizados.\nO programa indica qual é o tamanho médio das palavras de cada frase recebida.\nO programa pára de pedir frases quando receber uma frase apenas com a palavra “parar”.\nDeve implementar uma função que recebe uma string e devolve o tamanaho médio das palavras dessa string."
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-strings-afa",
    "href": "exercises/exercicios.html#exercícios-strings-afa",
    "title": "Programação",
    "section": "10 Exercícios Strings AFA",
    "text": "10 Exercícios Strings AFA\n\nAFA 10.1. Cifras de césar\n\nRefaz o exercício AFA 7.4. mas usando strings.\nEscreve uma função que recebe um char e uma cifra (int) e devolve esse char cifrado.\nEscreve uma função que recebe uma string com uma mensagem.\n\nA função converte essa mensagem numa mensagem cifrada, usando a função acima.\nA função reescreve a mensagem cifrada sobre a mensagem original (mesma string)\n\nA função main é a única que interage com o utilizador.\n\nPede uma frase ao utilizador, guardando-a numa string.\nEssa string é passada para a função que a vai cifrar.\nNo final, escrever na consola a mensagem cifrada."
  },
  {
    "objectID": "exercises/exercicios.html#king-2",
    "href": "exercises/exercicios.html#king-2",
    "title": "Programação",
    "section": "King",
    "text": "King"
  },
  {
    "objectID": "exercises/exercicios.html#afa",
    "href": "exercises/exercicios.html#afa",
    "title": "Programação",
    "section": "AFA",
    "text": "AFA\n\nAFA 12.1 timedelta\n\nImplementa uma função calcular_dif_datahora que recebe 2 marcas temporais (data e hora) e devolve a diferença temporal.\nA marca temporal é uma estrutura DataHora com os campos:\n\nano, mes, dia\nhora, minuto, segundo\n\nA marca temporal é uma estrutura DataHoraDelta com os campos:\n\ndias, horas, minutos, segundos\n\nVai ter de implementar a lógica para saber se um ano é bissexto (ver AFA 8.6.)\n\n\n\nAFA 12.2 aritmética DataHora\n\nImplementa uma função soma_DataHora que recebe uma DataHora (ver AFA 12.1) e um DataHoraDelta.\nA função devolve uma nova DataHora, que resulta da soma entre a DataHora recebida e a DataHoraDelta.\nImaplementa uma função sub_DataHora que faz o mesmo, mas o resultado é a subtração e não a soma."
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-ficheiros-king",
    "href": "exercises/exercicios.html#exercícios-ficheiros-king",
    "title": "Programação",
    "section": "13 Exercícios Ficheiros King",
    "text": "13 Exercícios Ficheiros King"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-ficheiros-afa",
    "href": "exercises/exercicios.html#exercícios-ficheiros-afa",
    "title": "Programação",
    "section": "13 Exercícios Ficheiros AFA",
    "text": "13 Exercícios Ficheiros AFA\n\nA 13.1 Jogadores\n\nEscreva um programa que a partir dum ficheiro chamado “jogadores.txt”, guarde a informação dos jogadores num vetor de registos e escreva um simples número real que indique qual a média de golos dos jogadores.\nO ficheiro “jogadores.txt” tem um conteúdo semelhante ao seguinte:\n  Joao 5 Leixoes \n  Tarquineo 6 Benfica \n  Pedro 3 Sporting \n  Luis 8 Belenenses \n  Miguel 2 Leixoes \n  Joao 1 Sporting \n  Manuel 5 Academica \n  Camoes 5 Porto \n  Fernando 10 Benfica \n  Joaquim 7 Boavista \n  Gervasio 7 Belenenses \nSe não tiver o ficheiro “jogadores.txt”, comece por criar esse ficheiro com o conteúdo apresentado acima.\n\n\n\nA 13.2\n\nO seguinte ficheiro de texto - “alice.txt” – contém uma tradução para português do Brasil de uma das mais famosas obras da literatura em Inglês do século XIX: “Alice no País das Maravilhas”. Pedimos-lhe para escrever um programa para fazer algumas contagens no ficheiro “alice.txt”. Escreva o programa pouco e pouco, introduzindo uma contagem de cada vez:\n\nO número de linhas do ficheiro;\nO número de linhas vazias do ficheiro;\nO número de linhas do ficheiro, onde ocorre a palavra “Alice”.\n\nResolva este problema sem carregar o ficheiro num vetor. Percorra o ficheiro lendo uma linha de cada vez usando a função fgets. Enquanto faz isso, vá atualizando alguns contadores, que foram inicializados a zero.\nOrganize o seu programa por forma a percorrer o ficheiro apenas uma vez. Isto faz com que o programa não possa ser decomposto em muitas funções. Portanto, escreva uma função chamada “processar_ficheiro” que recebe o nome do ficheiro, faz as contagens e escreve os resultados.\nPara testar se a palavra “Alice” ocorre numa linha, pode usar a função char *strstr ( char  *str1, char  *str2)\n\nfunção da biblioteca string.h\nEsta função devolve NULL caso str2 não se encontre em str1;\n\n\n\n\nA 13.3\nEscreva um programa que leia todas as linhas de um ficheiro e diga quantas palavras existem em cada linha do ficheiro.\n\n\nA 13.4\nEscreva um programa que leia todas as linhas de um ficheiro “ler.txt” e escreva no ficheiro “escrever.txt” por ordem inversa todas as linhas do primeiro ficheiro.\n\n\nA 13.5\n\nEscreva um programa que inverta as palavras de cada linha de um ficheiro “inverter.txt”.\nExemplo:\n\nFicheiro\nA hora de almoco e as 12h00.\nA hora de jantar e as 19h00.\nOutput\n.00h21 as e ocomla ed aroh A\n.00h91 sa e ratnaj ed aroh A\n\n\n\n\nA 13.6 grep\n\nEscreva uma função grep que recebe o nome de um ficheiro de texto e uma string e imprime na consola todas as linhas que contêm a string.\nComeça por escrever num ficheiro de texto o primeiro e último nome dos alunos da turma (pelo menos 5-10). Podes partilhar o ficheiro com o resto da turma.\nNeste exemplo, a string é “a”\nSoares, 1189\nFontainha, 1172\nFernandes, 1198\nPedrosa, 1179\nBranco, 1184\nCebola, 1171\nRamalho, 1190\nSantos, 1201\nSalgado, 1174\n\n\n\nA 13.7 grep -i\n\nCom base em A 13.6 grep, crie outra função grep_ignora que ignora a capitalização da string.\nNeste exemplo a string é “r”.\nRodrigues, 1195\nSoares, 1189\nFernandes, 1198\nPedrosa, 1179\nBranco, 1184\nRamalho, 1190\n\n\n\nA 13.8 grep -c\n\nCom base em A 13.6 grep, crie outra função grep_conta que imprime apenas o número de linhas em que a string foi encontrada.\nNeste caso, a capitalização da string interessa.\nNeste exemplo a string é “r”.\n5\n\n\n\nA 13.9 grep -i, modificada\n\nMelhore a função grep_ignora, dando a opção para parar a procura após encontrar a string N vezes.\nSe N=0, então não há limite, e.g. procurar “al” no ficheiro “alunos.txt” com N=2.\nMariana Relvão Carvalho\nInês Carvalho\n\n\n\nA 13.10 grep -c, múltiplos ficheiros\n\nCrie uma função grep_conta_varios dando a opção para para receber vários ficheiros e realizar a procura em cada um deles.\nDeve ser adicionado um prefixo com o nome do ficheiro em cada linha impressa na consola.\nA função recebe um vector de strings e uma string.\nCada string no vector tem um nome de ficheiro e um tamanho máximo definido numa constante.\nA outra string é a “palavra” (pode ser uma frase) a procurar.\nPara cada ficheiro, deve ser chamada a função grep_conta.\nE.g. procurar “al” nos ficheiros\nalunos.txt: 8\nalunos1718.txt: 2\nE.g. procurar “fon” nos ficheiros alunos.txt e alunos1718.txt\nalunos.txt: 1\nalunos1718.txt: 1\n\n\n\nA 13.11 grep -i, vários ficheiros\n\nCrie uma função grep_ignora_varios dando a opção para para receber vários ficheiros e realizar a procura em cada um deles.\nDeve ser adicionado um prefixo com o nome do ficheiro em cada linha impressa na consola.\nA função recebe um vector de strings, uma string e um inteiro.\nCada string no vector tem um nome de ficheiro.\nA outra string é a “palavra” (pode ser uma frase) a procurar.\nO inteiro é o número a partir do qual não se deve contar mais (o N no exercicio anterior).\nPara cada ficheiro, deve ser chamada a função grep_ignora melhorada.\nExemplo para procurar a string “al” nos ficheiros alunos.txt e alunos1718.txt, com N=2:\nalunos.txt: Mariana Relvão Carvalho\nalunos.txt: Inês Carvalho\nalunos1718.txt: 1174 Salgado\nalunos1718.txt: 1190 Ramalho\n\n\n\nA 13.12 ficheiro binário, alunos\n\nConsidera a seguinte estrutura\ntypedef struct {\n  char nome[100];\n  char morada[300];\n  int id_num;\n  float media;\n} Aluno;\nO ficheiro alunos.bin contém vários Aluno.\nEscreve um programa que indica o nome do aluno com a média mais alta."
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-memória-king",
    "href": "exercises/exercicios.html#exercícios-memória-king",
    "title": "Programação",
    "section": "14 Exercícios Memória King",
    "text": "14 Exercícios Memória King"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-memória-afa",
    "href": "exercises/exercicios.html#exercícios-memória-afa",
    "title": "Programação",
    "section": "14 Exercícios Memória AFA",
    "text": "14 Exercícios Memória AFA\n\nAFA 14.1. Image padding\n\nNo domínio da visão computacional, é comum termos de adicionar pixeis à volta de uma imagem.\nImplementa uma função que recebe uma imagem (vector de unsigned char com 3 dimensões) com uma determinada altura h (1ª dimensão) e largura w (2ª dimensão) e o número de pixeis de padding.\nA 3ª dimensão é o número de canais de cor, que será 3.\nA função cria um novo vector (alocado dinâmicamente) com o mesmo tamanho da imagem recebida, mas com a primeira e segunda dimensões incrementadas com o número de pixeis de padding.\nPosteriormente, a função copia a imagem original para a nova imagem com padding.\nO espaço de padding deve estar inicializado com zeros.\nA função retorna a imagem com padding.\n\n\n\nAFA 14.2. Computer Vision - augmentations 1 - occlusion\n\nNo domínio da visão computacional, é comum aumentar o número de imagens de um dataset com as imagens originais, mas com uma parte da imagem escondida.\nO teu objetivo será criar uma função que recebe uma imagem (vector de unsigned char com 3 dimensões) e vai criar uma cópia da imagem original, mas com partes da imagem escondida.\nA função recebe a imagem original, assim como as suas dimensões e o tamanho do quadrado que vai esconder parte da imagem (int)."
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-estruturas-de-dados-dinâmicas-aula",
    "href": "exercises/exercicios.html#exercícios-estruturas-de-dados-dinâmicas-aula",
    "title": "Programação",
    "section": "15 Exercícios Estruturas de Dados Dinâmicas Aula",
    "text": "15 Exercícios Estruturas de Dados Dinâmicas Aula\n\nAula 15.1. deleteNode\n\nConsidera o seguinte programa, onde está implementada uma lista ligada de inteiros.\nO programa tem uma função addNode que adiciona um novo nó à lista.\nImplementa uma função deleteLastNode que remove o último nó da lista.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\n\ntypedef struct {\n  Node * head;\n  int size;\n} LinkedList;\n\nvoid addNode(LinkedList * list, int data) {\n  // criar novo Node\n  Node *new_node = malloc(sizeof(Node));\n  new_node-&gt;data = data;\n  new_node-&gt;next = NULL;\n\n  Node *current = list-&gt;head;\n  Node *prev = NULL;\n\n  // procurar fim da lista\n  while (current != NULL) {\n    prev = current;\n    current = current-&gt;next;\n  }\n  // se prev for NULL, então lista está vazia\n  if (prev == NULL) {\n    list-&gt;head = new_node;\n  } else {\n    prev-&gt;next = new_node;\n  }\n\n  list-&gt;size++;\n}\n\nvoid deleteLastNode(LinkedList * list){\n\n}\n\nint main(void) {\n  LinkedList lista = {NULL, 0};\n\n  addNode(&lista, 1);\n  addNode(&lista, 2);\n  addNode(&lista, 3);\n\n  //\n  printf(\"tamanho da list = %d\\n\", lista.size);\n\n  deleteLastNode(&lista);\n  deleteLastNode(&lista);\n\n  printf(\"tamanho da list = %d\\n\", lista.size);\n\n\n  // imprimir lista\n  Node *c = lista.head;\n  while (c != NULL){\n    printf(\"%d\\n\", c-&gt;data);\n    c = c-&gt;next;\n  }\n\n  return 0;\n}"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-estruturas-de-dados-dinâmicas-king",
    "href": "exercises/exercicios.html#exercícios-estruturas-de-dados-dinâmicas-king",
    "title": "Programação",
    "section": "15 Exercícios Estruturas de Dados Dinâmicas King",
    "text": "15 Exercícios Estruturas de Dados Dinâmicas King"
  },
  {
    "objectID": "exercises/exercicios.html#exercícios-estruturas-de-dados-dinâmicas-afa",
    "href": "exercises/exercicios.html#exercícios-estruturas-de-dados-dinâmicas-afa",
    "title": "Programação",
    "section": "15 Exercícios Estruturas de Dados Dinâmicas AFA",
    "text": "15 Exercícios Estruturas de Dados Dinâmicas AFA\n\nAFA 15.1 receber lista de números reais\n\nImplementa uma lista ligada de números reais.\nEscreve uma função que recebe uma lista ligada e um número real.\n\nA função cria um novo nó com o número real recebido e adiciona-o à lista recebida.\n\nNa main, pede 5 números reais ao utilizador e guarda-os na lista lidada.\nEscreve uma função que escreve na consola o conteúdo de todos os elementos da lista ligada.\nNa main, usa esta função para escrever na consola os elementos introduzidos pelo utilizador.\nModifica a main para que o número de elementos pedidos ao utilizador não esteja pré-definido.\n\nO programa vai pedindo valores ao utilizador enquanto os quiser inserir.\nPara sinalizar que se inseriu o último valor, o utilizador irá escrever um “f” após o último número, e.g. 3.14f.\n\n\n\n\nAFA 15.2 listlen\n\nCom base no AFA 15.1, adiciona escreve uma função que recebe uma lista ligada de números reais e devolve o número de elementos dessa lista.\n\n\n\nAFA 15.3 soma e média\n\nCom base no AFA 15.1, adiciona escrve 2 funções que recebem uma lista ligada de números reais e devolvem um valor:\n\nA função soma recebe uma lista ligada e devolve a soma de todos os elementos existentes na lista.\nA função media recebe uma lista ligada e devolve a média de todos os elementos existentes na lista.\n\n\n\n\nAFA 15.4. filtro\n\nCom base no AFA 15.1, adiciona uma função que recebe uma lista ligada e 2 valores lower e upper.\nA função irá remover da lista todos os elementos que estão abaixo do valor lower e os que estão acima de upper.\n\n\n\nAFA 15.5. círculos concêntricos - implementação de lista ligada\n\nNo desenvolvimento de um sistema de aterragem automática com base em visão, uma das tarefas foi a deteção dos círculos de um marcador, com base em visão computacional.\nConsidera a seguinte implementação de uma lista ligada de círculos.\ntypedef struct circle {\n  int x;\n  int y;\n  int radius;\n  struct circle *next;\n} Circle;\n\ntypedef struct {\n  Circle * head;\n  int size;\n} CircleList;\nCria uma função addCircle que recebe uma lista ligada de círculos e os dados de um novo círculo.\nA função cria um novo círculo com os dados recebidos e adiciona-o à lista ligada.\n\nexemplo:\n\nlista ligada: c1 -&gt; c2 -&gt; c3 -&gt; c4\nnovo círculo: c5\nlista ligada: c1 -&gt; c2 -&gt; c3 -&gt; c4 -&gt; c5\n\n\nUsa o seguinte vector tridimensional de floats com os centros e raios como base dos dados para preencher a lista ligada:\nfloat circles[5][3] = {\n  { 10, 10, 5 },\n  { 10.1, 10.1, 15},\n  { 9.9, 10.1, 10},\n\n  { 20, 20, 10 },\n  { 19.9, 20.2, 15},\n  { 19.8, 20.1, 2},\n\n  { 5, 5.2, 5 },\n  { 5.3, 4.8, 10 },\n  { 4.9, 4.9, 15 },\n};\nImplementa uma função printCircleList que recebe uma lista ligada de círculos e escreve na consola os dados de todos os círculos da lista.\nNa main, cria uma nova lista ligada e adiciona os círculos do vector circles à lista ligada, usando a função addCircle.\nNo final da main, usa a função printCircleList para escrever na consola os dados de todos os círculos da lista ligada.\n\n\n\nAFA 15.6. círculos concêntricos - família de círculos\n\nCom base no AFA 15.5, adiciona uma função newCircleFamily que recebe uma lista ligada de círculos, as coordenadas de um centro e um desvio máximo.\nA função devolve uma nova lista ligada com todos os círculos da lista recebida que estão dentro do desvio máximo em relação ao círculo recebido. Cada círculo adicionado é retirado da lista original.\n\nexemplo:\n\nlista ligada: c1 -&gt; c2 -&gt; c3 -&gt; c4\ncentro: c2\ndesvio máximo: 2\nlista ligada: c1 -&gt; c3\nnova lista ligada: c2 -&gt; c4\n\n\nNa main, verifica o correto funcionamento da função escolhendo as coordenadas do centro de um dos círculos conhecidos e um desvio máximo adequado. Depois usa a função printCircleList para escrever na consola os dados de todos os círculos da nova lista ligada (com a família de círculos).\nConfirma também que a lista ligada original ficou corretamente atualizada (sem os círculos da nova lista ligada).\n\n\n\nAFA 15.7. círculos concêntricos - famílias de círculos\n\nCom base no AFA 15.6, cria um vector de listas ligadas de círculos. Cada uma destas listas deve ser correctamente inicializada como estando vazia (head = NULL, size = 0).\nCada lista ligada do vector representa uma família de círculos.\nCria uma função que recebe o vector de listas ligadas de círculos (com o seu tamanho) e a lista ligada com os círculos detetados.\nA função preenche o vector de listas ligadas de círculos atualizado e devolve o número de famílias criadas.\n\nexemplo:\n\nlista ligada de círculos detetados: c1 -&gt; c2 -&gt; c3 -&gt; c4 -&gt; c5 -&gt; c6\nvector de listas ligadas de círculos:\n\nfamília 1: c1 -&gt; c5 -&gt; c6\nfamília 2: c2 -&gt; c4\nfamília 3: c3\n\n\n\nNa main, verifica o correto funcionamento da função imprimindo na consola cada uma das famílias de círculos."
  },
  {
    "objectID": "exercises/exercicios.html#section",
    "href": "exercises/exercicios.html#section",
    "title": "Programação",
    "section": "22/23",
    "text": "22/23\n\nLab 1\n\n\nLab 2\n\n\nLab 3\n\n\nLab 4"
  },
  {
    "objectID": "exercises/exercicios.html#section-1",
    "href": "exercises/exercicios.html#section-1",
    "title": "Programação",
    "section": "15",
    "text": "15\n\nAFA 15.1\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct node {\n  float value;\n  struct node *next;\n} Node;\n\ntypedef struct {\n  Node * head;\n  int size;\n} List;\n\n// adiciona no final da lista\nvoid add(List *list, float value) {\n  Node *newNode = (Node *) malloc(sizeof(Node));\n  newNode-&gt;value = value;\n  newNode-&gt;next = NULL;\n\n  if (list-&gt;head == NULL) {\n    list-&gt;head = newNode;\n  } else {\n    Node *current = list-&gt;head;\n    while (current-&gt;next != NULL) {\n      current = current-&gt;next;\n    }\n    current-&gt;next = newNode;\n  }\n  list-&gt;size++;\n}\n\nvoid printList(List *list) {\n  Node *current = list-&gt;head;\n  while (current != NULL) {\n    printf(\"%f\\n\", current-&gt;value);\n    current = current-&gt;next;\n  }\n}\n\nint main() {\n  List list;\n  list.head = NULL;\n  list.size = 0;\n\n  float value;\n  char c;\n  do {\n    scanf(\"%f%c\", &value, &c);\n    add(&list, value);\n  } while (c != 'f');\n\n  printList(&list);\n\n  return 0;\n}\n\n\nAFA 15.2 listlen\nint listlen(List *list) {\n  int count = 0;\n  Node *current = list-&gt;head;\n  while (current != NULL) {\n    count++;\n    current = current-&gt;next;\n  }\n  return count;\n}\n\n\nAFA 15.3 soma e média\n\nfloat soma(List *list) {\n  float sum = 0;\n  Node *current = list-&gt;head;\n  while (current != NULL) {\n    sum += current-&gt;value;\n    current = current-&gt;next;\n  }\n  return sum;\n}\n\nfloat media(List *list) {\n  return soma(list) / listlen(list);\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programação 23/24 S2",
    "section": "",
    "text": "Links úteis\n\nTeams 2324\nSharePoint 2324\nAmbientes de desenvolvimento\n\nReplit - IDE Online\nCodeBlocks\nVisual Studio Code\n\nSetup VSCode locally\n\n\n\n\n\nEquipa docente\n\nCapitão Diogo Silva | dasilva@academiafa.edu.pt\nTenente Gabriel Santos | gcsantos@academiafa.edu.pt\n\n\n\nAulas\n\nApresentação da UC\nMotivação [Slides]\nC Fundamentals [Slides]"
  },
  {
    "objectID": "lectures/01_course_intro.revealjshtml#equipa",
    "href": "lectures/01_course_intro.revealjshtml#equipa",
    "title": "Apresentação da UC Programação",
    "section": "Equipa",
    "text": "Equipa\n\nCAP Diogo Silva\n\n501753\ndasilva@academiafa.edu.pt\n\nTEN Gabriel Santos\n\n500877\ngcsantos@academiafa.edu.pt"
  },
  {
    "objectID": "lectures/01_course_intro.revealjshtml#avaliação",
    "href": "lectures/01_course_intro.revealjshtml#avaliação",
    "title": "Apresentação da UC Programação",
    "section": "Avaliação",
    "text": "Avaliação\n\n\n\nPeso\nDescrição\n\n\n\n\n20%\n4 laboratórios x 5%\n\n\n40%\nProjecto 1\n\n\n40%\nTeste 2\n\n\n\nTodos os elementos de um grupo são responsáveis pelo trabalho de grupo.Numa avaliação oral, qualquer aluno deverá ser capaz e apresentar e responder a perguntas sobre toda a avaliação."
  },
  {
    "objectID": "lectures/01_course_intro.revealjshtml#laboratórios",
    "href": "lectures/01_course_intro.revealjshtml#laboratórios",
    "title": "Apresentação da UC Programação",
    "section": "Laboratórios",
    "text": "Laboratórios\n\nLab 1 | Tipos, decisões, funções e ciclos.\nLab 2 | Arrays e strings.\nLab 3 | Pointers, struct e ficheiros.\nLab 4 | Alocação de memória e estruturas dinâmicas."
  },
  {
    "objectID": "lectures/01_course_intro.revealjshtml#exame",
    "href": "lectures/01_course_intro.revealjshtml#exame",
    "title": "Apresentação da UC Programação",
    "section": "Exame",
    "text": "Exame\n\nIncide sobre as componentes reprovadas."
  },
  {
    "objectID": "lectures/01_course_intro.revealjshtml#bibliografia",
    "href": "lectures/01_course_intro.revealjshtml#bibliografia",
    "title": "Apresentação da UC Programação",
    "section": "Bibliografia",
    "text": "Bibliografia\n\nLuís Damas, Linguagem C, FCA [qualquer ano]\n“C Programming: A Modern Approach, 2nd Edition”, K. N. King, 2008.\nBrian W. Kernighan, Dennis M. Ritchie, The C programming language, 2nd Edition, Prentice-Hall, 1988"
  },
  {
    "objectID": "lectures/01_course_intro.html",
    "href": "lectures/01_course_intro.html",
    "title": "Apresentação da UC Programação",
    "section": "",
    "text": "CAP Diogo Silva\n\n501753\ndasilva@academiafa.edu.pt\n\nTEN Gabriel Santos\n\n500877\ngcsantos@academiafa.edu.pt"
  },
  {
    "objectID": "lectures/01_course_intro.html#equipa",
    "href": "lectures/01_course_intro.html#equipa",
    "title": "Apresentação da UC Programação",
    "section": "",
    "text": "CAP Diogo Silva\n\n501753\ndasilva@academiafa.edu.pt\n\nTEN Gabriel Santos\n\n500877\ngcsantos@academiafa.edu.pt"
  },
  {
    "objectID": "lectures/01_course_intro.html#avaliação",
    "href": "lectures/01_course_intro.html#avaliação",
    "title": "Apresentação da UC Programação",
    "section": "Avaliação",
    "text": "Avaliação\n\n\n\nPeso\nDescrição\n\n\n\n\n20%\n4 laboratórios x 5%\n\n\n40%\nProjecto 1\n\n\n40%\nTeste 2\n\n\n\n\n\nNota mínima de 9,5 em cada componente:\n\nTeórica = teste\nPrática = média dos laboratórios com o projecto (20%/40%) normalizada a 20 valores"
  },
  {
    "objectID": "lectures/01_course_intro.html#laboratórios",
    "href": "lectures/01_course_intro.html#laboratórios",
    "title": "Apresentação da UC Programação",
    "section": "Laboratórios",
    "text": "Laboratórios\n\nLab 1 | Tipos, decisões, funções e ciclos.\nLab 2 | Arrays e strings.\nLab 3 | Pointers, struct e ficheiros.\nLab 4 | Alocação de memória e estruturas dinâmicas."
  },
  {
    "objectID": "lectures/01_course_intro.html#exame",
    "href": "lectures/01_course_intro.html#exame",
    "title": "Apresentação da UC Programação",
    "section": "Exame",
    "text": "Exame\n\nIncide sobre as componentes reprovadas."
  },
  {
    "objectID": "lectures/01_course_intro.html#bibliografia",
    "href": "lectures/01_course_intro.html#bibliografia",
    "title": "Apresentação da UC Programação",
    "section": "Bibliografia",
    "text": "Bibliografia\n\nLuís Damas, Linguagem C, FCA [qualquer ano]\n“C Programming: A Modern Approach, 2nd Edition”, K. N. King, 2008.\nBrian W. Kernighan, Dennis M. Ritchie, The C programming language, 2nd Edition, Prentice-Hall, 1988"
  },
  {
    "objectID": "lectures/01_course_intro.html#footnotes",
    "href": "lectures/01_course_intro.html#footnotes",
    "title": "Apresentação da UC Programação",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTodos os elementos de um grupo são responsáveis pelo trabalho de grupo.↩︎\nNuma avaliação oral, qualquer aluno deverá ser capaz e apresentar e responder a perguntas sobre toda a avaliação.↩︎"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#estruturas-estáticas",
    "href": "lectures/15_data_structs.revealjshtml#estruturas-estáticas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Estruturas estáticas",
    "text": "Estruturas estáticas\nEstruturas de dados que vimos:\n\narray\nstring (=array)\nstruct\n\n\nEstas estruturas são estáticas, i.e. o seu tamanho é fixo e definido no início.\nint mat[10][10];\nchar frase[200];\nstruct aluno {\n    char nome[50];\n    int nip;\n}"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#alocação-dinâmica-de-memória",
    "href": "lectures/15_data_structs.revealjshtml#alocação-dinâmica-de-memória",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Alocação dinâmica de memória",
    "text": "Alocação dinâmica de memória\nCom alocação dinâmica de memória, aprendemos a criar estruturas de dados com um tamanho definido durante a execução do programa.\n// allocate array, vec_size=size of vector\nint * vect = calloc(vec_size, sizeof(int));\n\n// allocate bidimensional array\n// dim1_size = #lines, dim2_size = #cols\nint ** mat = calloc(dim1_size, sizeof(int*));\nfor(int i=0; i&lt;dim1_size; i++)\n    mat[i] = calloc(dim2_size, sizeof(int));"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#e-as-estruturas-dinâmicas",
    "href": "lectures/15_data_structs.revealjshtml#e-as-estruturas-dinâmicas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "E as estruturas dinâmicas?",
    "text": "E as estruturas dinâmicas?\nEstas crescem e diminuem conforme adicionamos ou removemos dados.\nAlém disso, a forma de organização e ligação entre os dados permite otimizar o tempo de várias operações ou o espaço ocupado."
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#estruturas-de-dados-dinâmicas",
    "href": "lectures/15_data_structs.revealjshtml#estruturas-de-dados-dinâmicas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Estruturas de dados dinâmicas",
    "text": "Estruturas de dados dinâmicas\n\nLista ligada simples\nLista duplamente ligada\nFila (queue)\nPilha (stack)\nentre muitas outras…"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#lista-ligada-simples",
    "href": "lectures/15_data_structs.revealjshtml#lista-ligada-simples",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\nUm conjunto de elementos ligados não pela sua posição na memória (array), mas por referências explicitas entre elementos."
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#lista-ligada-simples-1",
    "href": "lectures/15_data_structs.revealjshtml#lista-ligada-simples-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\n\nDiagrama de lista ligada simples\nHEAD aponta para o elemento inicial da lista.\nCada elemento aponta para o elemento seguinte (apontador)."
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#algumas-caracteristicas-12",
    "href": "lectures/15_data_structs.revealjshtml#algumas-caracteristicas-12",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas caracteristicas 1/2",
    "text": "Algumas caracteristicas 1/2\n\n\nO último elemento aponta sempre para NULL.\n\nSe a lista estiver vazia, HEAD aponta para NULL.\n\nSó podemos percorrer a lista numa direção\nse quisermos o elemento na posição X, temos de percorrer todos os elementos nas posições [0,X["
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#algumas-caracteristicas-22",
    "href": "lectures/15_data_structs.revealjshtml#algumas-caracteristicas-22",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas caracteristicas 2/2",
    "text": "Algumas caracteristicas 2/2\n\n\nsempre que removemos um elemento da lista, não esquecer de libertar a memória.\nSempre que removemos um elemento\n\nlibertar e memória associada.\nmudar a referência da lista que apontava para esse elemento"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#lista-ligada-simples-2",
    "href": "lectures/15_data_structs.revealjshtml#lista-ligada-simples-2",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\nOs elementos de uma lista ligada também são frequentemente denominados por nós.\n\nUm nó pode ser implementado com struct.\nstruct node {\n    int data;\n    struct node * next;\n}\n\n\n\nDiagrama de um nó de lista ligada simples."
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#exemplo",
    "href": "lectures/15_data_structs.revealjshtml#exemplo",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Exemplo",
    "text": "Exemplo\n\nCriar lista e primeiro nó\n\nstruct node * head;\n\n\nhead = malloc(sizeof(struct node));\nhead-&gt;data = 42;\nhead-&gt;next = NULL;\n\n\nCriar segundo nó\n\nstruct node * b = malloc(sizeof(struct node));\nb-&gt;data = 87;\nb-&gt;next = NULL;\n\n\n\nAdicionar segundo nó à lista\n\n// adicionar b à lista\nhead-&gt;next = b;"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#algumas-operações-em-listas-ligadas",
    "href": "lectures/15_data_structs.revealjshtml#algumas-operações-em-listas-ligadas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas operações em listas ligadas",
    "text": "Algumas operações em listas ligadas\n\ninserir novo elemento em determinada posição\neliminar elemento em determinada posição\ntirar elemento de determinada posição\nprocurar nó por valor\ncontar número de nós"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#demo-implementação",
    "href": "lectures/15_data_structs.revealjshtml#demo-implementação",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Demo implementação",
    "text": "Demo implementação\n\nGravação em aula\n\nParte 1 [18min], Loom, Sharepoint\nParte 2 [10min], Loom, Sharepoint"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#lista-duplamente-ligada",
    "href": "lectures/15_data_structs.revealjshtml#lista-duplamente-ligada",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista duplamente ligada",
    "text": "Lista duplamente ligada\nEm tudo igual à lista ligada simples, mas cada nó aponta para o elemento anterior e para o seguinte.\n\n\n\n\nDiagram de um nó\n\n\n\n\n\n\n\nDiagrama de como os nós se ligam"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#fila",
    "href": "lectures/15_data_structs.revealjshtml#fila",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Fila",
    "text": "Fila\n(queue)\n\nParecida com uma lista ligada, mas os elementos são sempre adicionados no fim e retirados do início.\nO primeiro elemento a entrar é o primeiro elemento a sair (FIFO - first in first out)"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#fila-1",
    "href": "lectures/15_data_structs.revealjshtml#fila-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Fila",
    "text": "Fila\n\n\n\n\n\nAdicionar um nó\n\n\n\n\n\n\nRemover um nó"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#pilha",
    "href": "lectures/15_data_structs.revealjshtml#pilha",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Pilha",
    "text": "Pilha\n(stack)\n\nParecida com uma lista ligada, mas os elementos são sempre adicionados no fim e retirados do fim, ou adicionados no início e retirados do início.\nO último elemento a entrar é o primeiro elemento a sair (LIFO - last in first out)"
  },
  {
    "objectID": "lectures/15_data_structs.revealjshtml#pilha-1",
    "href": "lectures/15_data_structs.revealjshtml#pilha-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Pilha",
    "text": "Pilha\n\n\n\n\n\nAdicionar um nó\n\n\n\n\n\n\nRemover um nó"
  },
  {
    "objectID": "lectures/15_data_structs.html",
    "href": "lectures/15_data_structs.html",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "",
    "text": "Estruturas de dados que vimos:\n\narray\nstring (=array)\nstruct\n\n. . .\nEstas estruturas são estáticas, i.e. o seu tamanho é fixo e definido no início.\nint mat[10][10];\nchar frase[200];\nstruct aluno {\n    char nome[50];\n    int nip;\n}"
  },
  {
    "objectID": "lectures/15_data_structs.html#estruturas-estáticas",
    "href": "lectures/15_data_structs.html#estruturas-estáticas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "",
    "text": "Estruturas de dados que vimos:\n\narray\nstring (=array)\nstruct\n\n. . .\nEstas estruturas são estáticas, i.e. o seu tamanho é fixo e definido no início.\nint mat[10][10];\nchar frase[200];\nstruct aluno {\n    char nome[50];\n    int nip;\n}"
  },
  {
    "objectID": "lectures/15_data_structs.html#alocação-dinâmica-de-memória",
    "href": "lectures/15_data_structs.html#alocação-dinâmica-de-memória",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Alocação dinâmica de memória",
    "text": "Alocação dinâmica de memória\nCom alocação dinâmica de memória, aprendemos a criar estruturas de dados com um tamanho definido durante a execução do programa.\n// allocate array, vec_size=size of vector\nint * vect = calloc(vec_size, sizeof(int));\n\n// allocate bidimensional array\n// dim1_size = #lines, dim2_size = #cols\nint ** mat = calloc(dim1_size, sizeof(int*));\nfor(int i=0; i&lt;dim1_size; i++)\n    mat[i] = calloc(dim2_size, sizeof(int));\n\nMas depois de criadas, o tamanho destas estruturas não é alterado1, i.e. um array não pode crescer ou diminuir conforme a necessidade."
  },
  {
    "objectID": "lectures/15_data_structs.html#e-as-estruturas-dinâmicas",
    "href": "lectures/15_data_structs.html#e-as-estruturas-dinâmicas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "E as estruturas dinâmicas?",
    "text": "E as estruturas dinâmicas?\nEstas crescem e diminuem conforme adicionamos ou removemos dados.\nAlém disso, a forma de organização e ligação entre os dados permite otimizar o tempo de várias operações ou o espaço ocupado."
  },
  {
    "objectID": "lectures/15_data_structs.html#estruturas-de-dados-dinâmicas",
    "href": "lectures/15_data_structs.html#estruturas-de-dados-dinâmicas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Estruturas de dados dinâmicas",
    "text": "Estruturas de dados dinâmicas\n\nLista ligada simples\nLista duplamente ligada\nFila (queue)\nPilha (stack)\nentre muitas outras…"
  },
  {
    "objectID": "lectures/15_data_structs.html#lista-ligada-simples",
    "href": "lectures/15_data_structs.html#lista-ligada-simples",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\nUm conjunto de elementos ligados não pela sua posição na memória (array), mas por referências explicitas entre elementos."
  },
  {
    "objectID": "lectures/15_data_structs.html#lista-ligada-simples-1",
    "href": "lectures/15_data_structs.html#lista-ligada-simples-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\n\n\n\nDiagrama de lista ligada simples\n\n\n\nHEAD aponta para o elemento inicial da lista.\nCada elemento aponta para o elemento seguinte (apontador)."
  },
  {
    "objectID": "lectures/15_data_structs.html#algumas-caracteristicas-12",
    "href": "lectures/15_data_structs.html#algumas-caracteristicas-12",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas caracteristicas 1/2",
    "text": "Algumas caracteristicas 1/2\n\n\nO último elemento aponta sempre para NULL.\n\nSe a lista estiver vazia, HEAD aponta para NULL.\n\nSó podemos percorrer a lista numa direção\nse quisermos o elemento na posição X, temos de percorrer todos os elementos nas posições [0,X["
  },
  {
    "objectID": "lectures/15_data_structs.html#algumas-caracteristicas-22",
    "href": "lectures/15_data_structs.html#algumas-caracteristicas-22",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas caracteristicas 2/2",
    "text": "Algumas caracteristicas 2/2\n\n\nsempre que removemos um elemento da lista, não esquecer de libertar a memória.\nSempre que removemos um elemento\n\nlibertar e memória associada.\nmudar a referência da lista que apontava para esse elemento"
  },
  {
    "objectID": "lectures/15_data_structs.html#lista-ligada-simples-2",
    "href": "lectures/15_data_structs.html#lista-ligada-simples-2",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista ligada simples",
    "text": "Lista ligada simples\nOs elementos de uma lista ligada também são frequentemente denominados por nós.\n. . .\nUm nó pode ser implementado com struct.\nstruct node {\n    int data;\n    struct node * next;\n}\n\n\n\nDiagrama de um nó de lista ligada simples."
  },
  {
    "objectID": "lectures/15_data_structs.html#exemplo",
    "href": "lectures/15_data_structs.html#exemplo",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Exemplo",
    "text": "Exemplo\n\nCriar lista e primeiro nó\n\nstruct node * head;\n\n\nhead = malloc(sizeof(struct node));\nhead-&gt;data = 42;\nhead-&gt;next = NULL;\n. . .\n\nCriar segundo nó\n\nstruct node * b = malloc(sizeof(struct node));\nb-&gt;data = 87;\nb-&gt;next = NULL;\n. . .\n\nAdicionar segundo nó à lista\n\n// adicionar b à lista\nhead-&gt;next = b;"
  },
  {
    "objectID": "lectures/15_data_structs.html#algumas-operações-em-listas-ligadas",
    "href": "lectures/15_data_structs.html#algumas-operações-em-listas-ligadas",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Algumas operações em listas ligadas",
    "text": "Algumas operações em listas ligadas\n\ninserir novo elemento em determinada posição\neliminar elemento em determinada posição\ntirar elemento de determinada posição\nprocurar nó por valor\ncontar número de nós"
  },
  {
    "objectID": "lectures/15_data_structs.html#demo-implementação",
    "href": "lectures/15_data_structs.html#demo-implementação",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Demo implementação",
    "text": "Demo implementação\n\nGravação em aula\n\nParte 1 [18min], Loom, Sharepoint\nParte 2 [10min], Loom, Sharepoint"
  },
  {
    "objectID": "lectures/15_data_structs.html#lista-duplamente-ligada",
    "href": "lectures/15_data_structs.html#lista-duplamente-ligada",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Lista duplamente ligada",
    "text": "Lista duplamente ligada\nEm tudo igual à lista ligada simples, mas cada nó aponta para o elemento anterior e para o seguinte.\n. . .\n\n\n\nDiagram de um nó\n\n\n. . .\n\n\n\nDiagrama de como os nós se ligam"
  },
  {
    "objectID": "lectures/15_data_structs.html#fila",
    "href": "lectures/15_data_structs.html#fila",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Fila",
    "text": "Fila\n\n(queue)\n\nParecida com uma lista ligada, mas os elementos são sempre adicionados no fim e retirados do início.\nO primeiro elemento a entrar é o primeiro elemento a sair (FIFO - first in first out)"
  },
  {
    "objectID": "lectures/15_data_structs.html#fila-1",
    "href": "lectures/15_data_structs.html#fila-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Fila",
    "text": "Fila\n\n\n\n\n\nAdicionar um nó\n\n\n\n\n\n\nRemover um nó"
  },
  {
    "objectID": "lectures/15_data_structs.html#pilha",
    "href": "lectures/15_data_structs.html#pilha",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Pilha",
    "text": "Pilha\n\n(stack)\n\nParecida com uma lista ligada, mas os elementos são sempre adicionados no fim e retirados do fim, ou adicionados no início e retirados do início.\nO último elemento a entrar é o primeiro elemento a sair (LIFO - last in first out)"
  },
  {
    "objectID": "lectures/15_data_structs.html#pilha-1",
    "href": "lectures/15_data_structs.html#pilha-1",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Pilha",
    "text": "Pilha\n\n\n\n\n\nAdicionar um nó\n\n\n\n\n\n\nRemover um nó"
  },
  {
    "objectID": "lectures/15_data_structs.html#footnotes",
    "href": "lectures/15_data_structs.html#footnotes",
    "title": "Estruturas de Dados Dinâmicas",
    "section": "Footnotes",
    "text": "Footnotes\n\n\na função realloc muda um pouco esta dinâmica↩︎"
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#tipos-básicos-do-c",
    "href": "lectures/7_basic_types.revealjshtml#tipos-básicos-do-c",
    "title": "Tipos básicos do C",
    "section": "Tipos básicos do C",
    "text": "Tipos básicos do C"
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#inteiros",
    "href": "lectures/7_basic_types.revealjshtml#inteiros",
    "title": "Tipos básicos do C",
    "section": "Inteiros",
    "text": "Inteiros"
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#inteiros-1",
    "href": "lectures/7_basic_types.revealjshtml#inteiros-1",
    "title": "Tipos básicos do C",
    "section": "Inteiros",
    "text": "Inteiros\nConstantes\nAté agora definimos constantes de inteiros no formato decimal simples, i.e. usando 10 digitos distintos.\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  int v = 42;  // 42 é constante de inteiro\n}"
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#reais",
    "href": "lectures/7_basic_types.revealjshtml#reais",
    "title": "Tipos básicos do C",
    "section": "Reais",
    "text": "Reais\nfloat\ndouble\nlong double\n–\n\nO long double não aparece porque os intervalos variam bastante de máquina para máquina."
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#texto",
    "href": "lectures/7_basic_types.revealjshtml#texto",
    "title": "Tipos básicos do C",
    "section": "Texto",
    "text": "Texto\nchar"
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#conversão-de-tipos",
    "href": "lectures/7_basic_types.revealjshtml#conversão-de-tipos",
    "title": "Tipos básicos do C",
    "section": "Conversão de tipos",
    "text": "Conversão de tipos\n\nNo C, é possível converter de uns tipos para outros.\nNa verdade, nós já usámos esta funcionalidade sem saber, porque existem conversões que são automáticas e implicitas.\nOutras têm de ser explicitamente declaradas."
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#definições-de-tipos",
    "href": "lectures/7_basic_types.revealjshtml#definições-de-tipos",
    "title": "Tipos básicos do C",
    "section": "Definições de tipos",
    "text": "Definições de tipos\nO C permite a definição de novos tipos com o comando typedef.\ntypedef int Altura;\n\ntypedef é seguido do nome original do tipo\ne depois do novo nome que queremos usar"
  },
  {
    "objectID": "lectures/7_basic_types.revealjshtml#sizeof",
    "href": "lectures/7_basic_types.revealjshtml#sizeof",
    "title": "Tipos básicos do C",
    "section": "sizeof",
    "text": "sizeof\nA função sizeof recebe um valor ou um tipo e indica qual é o tamanho, em bytes, que esse tipo ocupa em memória.\nchar c;\nprintf(\"size of int = %lu bytes\\n\", sizeof(int));  // 4\nprintf(\"size of char = %lu bytes\\n\", sizeof(3.14));  // 8 -&gt; double\nprintf(\"size of char = %lu bytes\\n\", sizeof(c));  // 1"
  },
  {
    "objectID": "lectures/7_basic_types.html#inteiros",
    "href": "lectures/7_basic_types.html#inteiros",
    "title": "Tipos básicos do C",
    "section": "Inteiros",
    "text": "Inteiros\n\nAté agora usámos apenas o tipo int para representar números inteiros, mas existem outros:\nshort int\nunsigned short int\n\nint\nunsigned int\n\nlong int\nunsigned lont int\n\nDiferentes tipos podem representar números inteiros em diferentes intervalos e ocupam mais ou menos espaço em memória.\nEstes intervalos e espaço ocupado em memória pode variar de máquina para máquina, mas é garantido que:\nshort int &lt; int &lt; long int\n\nProcessadores com arquitecturas de 64 bits começam a ser comuns e os intervalos de valores comuns são:\n\n\nUma forma rápida de verificar os limites de um determinado tipo numa máquina, é usar a biblioteca &lt;limits.h&gt;.\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  int v;\n  printf(\"max long=%ld\\n\", LONG_MAX);\n}\nLista de todas as constantes na documentação da biblioteca.\nhttps://man7.org/linux/man-pages/man0/limits.h.0p.html"
  },
  {
    "objectID": "lectures/7_basic_types.html#inteiros-1",
    "href": "lectures/7_basic_types.html#inteiros-1",
    "title": "Tipos básicos do C",
    "section": "Inteiros",
    "text": "Inteiros\n\nConstantes\nAté agora definimos constantes de inteiros no formato decimal simples, i.e. usando 10 digitos distintos.\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  int v = 42;  // 42 é constante de inteiro\n}\n\nMas existem outras formas.\nÉ possível definir constantes em formato octal e hexadecimal. Não iremos explorar estas bases, mas veremos como escrever constantes de inteiros diferentes.\n\n15L  -&gt; interpretar 15 como um long int\n15U  -&gt; interpretar 15 como um unsigned int\n15UL -&gt; interpretar 15 como um unsigned long int\nTambém se pode escrever U e L em minúsculas. Pode-se escrever UL ou LU.\n\n\n\nOverflow\nComo vimos anteriormente, os tipos inteiros têm um valor máximo e mínimo que podem representar.\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  int v = INT_MAX;\n  printf(\"v=%d\\n\", v);\n  printf(\"v=%d\\n\", v+1);\n  return 0;\n}\n\nv = ?\nv + 1 = ?\n\n\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n  int v = INT_MAX;\n  printf(\"v=%d\\n\", v);\n  printf(\"v=%d\\n\", v+1);\n  return 0;\n}\n\nv     = 2147483647\nv + 1 = -2147483648\n\n\n\n\nprintf e scanf\nscanf(\"%u\", &v);  // unsigned int\nprintf(\"%u\", v);   \n\nscanf(\"%hd\", &v);  // short int\nprintf(\"%hd\", v);\n\nscanf(\"%hu\", &v);  // unsigned short int\nprintf(\"%hu\", v);\n\nscanf(\"%ld\", &v);  // long int\nprintf(\"%ld\", v);  \n\nscanf(\"%lu\", &v);  // unsigned long int\nprintf(\"%lu\", v);"
  },
  {
    "objectID": "lectures/7_basic_types.html#reais",
    "href": "lectures/7_basic_types.html#reais",
    "title": "Tipos básicos do C",
    "section": "Reais",
    "text": "Reais\nfloat\ndouble\nlong double\n–\n\nO long double não aparece porque os intervalos variam bastante de máquina para máquina.\n\n\nconstantes\nDiferentes formas de escrever o número 57:\n57.0\n57.\n57.0e0\n57E0\n5.7e1\n5.7e+1\n.57e2\n570.e-1\n\n\n\nprintf scanf\ndouble d;\nscanf(\"lf\", &d);\nprintf(\"lf\", d);\n\nlong double ld;\nscanf(\"%Lf\", &ld);\nprintf(\"%Lf\", ld);"
  },
  {
    "objectID": "lectures/7_basic_types.html#texto",
    "href": "lectures/7_basic_types.html#texto",
    "title": "Tipos básicos do C",
    "section": "Texto",
    "text": "Texto\n\nchar\n\n\nchar\nAté agora usámos texto apenas no contexto do scanf e print.\nO C tem um tipo para texto: o char.\nchar letra = 'C';\n\n\nUm char guarda 1 letra.\nAs constantes de char são escritas com plicas ’’. Não confundir com as aspas “” usadas para strings (e.g. o printf e scanf).\n\n\n\nInternamente, um char é apenas um número inteiro que pode ser interpretado como letras, através da tabela ASCII.\n\n\n\nascii\n\n\nASCII = American standard Code for Information Interchange\n\nNão precisamos de saber esta correspondência, porque podemos sempre interpretar um char como um inteiro e vice-versa.\nchar letra = 'A';\nprintf(\"A letra %c tem o valor %d\\n\", letra, letra);  // A 65\n\nA especificação de conversão para char é o %c. \n\nPor serem números inteiros, podemos realizar operações aritméticas sobre char.\nchar letra = 'C';\nprintf(\"A letra depois do %c = %c\\n\", letra, letra+1);  // C D\n\n// abecedário completado em maísculas\nfor(char l='A'; l&lt;'Z'; l++)\n  printf(\"%c,\"l);\nprintf(\"\\n\");\n\n\nTal como vimos para os tipos inteiros, o char também pode ser signed ou unsigned.\nchar n = 127+1;\nprintf(\"n=%d\\n\", n); // -128\n\nunsigned char n2 = 255+1;\nprintf(\"n2=%d\\n\", n2);  // 0\nTambém está sujeito a overflow. \n\n\nJá usámos anteriormente caracteres especiais, e.g. '\\n' e '\\t'. Existem outros.\nAlguns só podem ser especificados em formato octal ou hexadecimal.\n\n\n\n\n\nscanf\n\nQuando o scanf acaba de processar um determinado input, existem caracteres que ficam por consumir.\nComo todos os caracteres são válidos para o tipo char, isso pode ser um problema.\n\n\n\n\nscanf\nchar c1, c2;\nprintf(\"Introduza um caracter:\");\nscanf(\"%c\", &c1);\n\nprintf(\"Introduza outro caracter:\");\nscanf(\"%c\", &c2);\n\nprintf(\"c1=%c   c2=%c  \\n\", c1, c2);\nIntroduza um caracter:a\nIntroduza outro caracter:c1=a   c2=\n  \n\n\nAparentemente, o segundo scanf foi ignorado:\n\no utilizador não escreveu nada\no que estaria depois de c2= está vazio\n\n\n\n\n\nNa verdade, o primeiro scanf deixa um enter '\\n' por consumir.\nNo scanf seguinte, o que é pedido é um char. \nComo 'n' é um char válido, a especificação de conversão aceita-o como input \nDeixa de ser necessário pedir input ao utilizador porque as especificações de conversão já foram satisfeitas. \n\n\nComo confirmar? Vamos interpretar c2 como um inteiro.\nchar c1, c2;\nprintf(\"Introduza um caracter:\");\nscanf(\"%c\", &c1);\n\nprintf(\"Introduza outro caracter:\");\nscanf(\"%c\", &c2);\n\nprintf(\"c1=%c   c2=%d  \\n\", c1, c2);\n\nIntroduza um caracter:a\nIntroduza outro caracter:c1=a   c2=10\n\n\n\n\nalternativas para ler e escrever char\nExistem outras formas de ler e escrever um char. - getchar - putchar\n\n\n\nputchar\nA função putchar escreve um caracter na consola.\nputchar('C');\n\n\ngetchar\nA função getchar lê um único char.\nl = getchar();\n⚠️Tal como no scanf, o getchar não salta espaços em branco quando lê um char.⚠️ \n\nE se quisermos ler vários chars?\nUsamos um ciclo. \n// lê chars até encontrar \\n\nchar l;\ndo{\n  scanf(\"%c\", &l);\n} while (l != '\\n');\n\nchar l;\nwhile ((l = getchar()) != '\\n')\n  ;\n\n\n\n\n\nexercicio\n\nCalcular comprimento de mensagem"
  },
  {
    "objectID": "lectures/7_basic_types.html#conversão-de-tipos",
    "href": "lectures/7_basic_types.html#conversão-de-tipos",
    "title": "Tipos básicos do C",
    "section": "Conversão de tipos",
    "text": "Conversão de tipos\n\nNo C, é possível converter de uns tipos para outros.\nNa verdade, nós já usámos esta funcionalidade sem saber, porque existem conversões que são automáticas e implicitas.\nOutras têm de ser explicitamente declaradas.\n\n\n\nconversões implicitas\n\nQuando realizamos operações binárias, o C consegue detectar se os 2 operandos são do mesmo tipo.\nSe não forem, um dos tipos é convertido no outro, porque as operações são feitas com operandos do mesmo tipo.\nO resultado da operação será do tipo “superior”.\n\n\n\n\nconversões implicitas\nint i;\nfloat f, p;\np = f + i;\n\nNeste caso, o valor de i será convertido para float.\nSe o contrário ocorresse, perdiamos por completo a componente decimal de f.\nDesta forma, o pior que pode acontecer é o valor de i perder precisão depois de convertido.\n\n\n\n\nconversões implicitas &gt; ambos operandos da mesma “classe”\n  reais                 inteiros\n\nlong double         unsigned long int\n    ^                       ^\n    |                       |\n  double                long int\n    ^                       ^\n    |                       |\n  float                unsigned int\n                            ^\n                            |\n                           int\n\n\n\nconversões implicitas &gt; exemplos\nchar c;\nshort int s;\nint i;\nunsigned int u;\nlong int l;\n\ni = i + c; // c convertido para int\ni = i + s; // s convertido para int\nu = u + i; // i convertido para unsigned int\nl = l + u; // u convertido para long int\n\n\n\nconversões implicitas &gt; mais exemplos\nlong int l;\nunsigned long int ul;\nfloat f;\ndouble d;\nlong double ld;\n\nul = ul + l; // l convertido para unsigned long int\nf = f + ul; // ul convertido para float\nd = d + f; // f convertido para double\nld = ld + d // d convertido para long double\n\n\n\nconversões implicitas &gt; atribuição\nchar c;\nint i;\nfloat f;\ndouble d;\n\ni = c; // c convertido para int\nf = i; // i convertido para float\nd = f; // f convertido para double\n\ni = 3.14; // 3.14 convertido para 3\nc = 10000; // overflow\nf = 1.0e100; // excede limite\n\n\n\nconversões explicitas &gt; casting\n\nPara fazer uma conversão explicita, escrevemos o nome do tipo final entre parêntises, seguido do valor que queremos converter.\n\nfloat f = 3 / 2; // 1.0 -&gt; divisão de inteiros dá inteiro\nf = (float) 3 / 2; // 1.5 -&gt; converter 3 para float e dividir por 2\n\nO operador de casting é uma operação unária.\nOperações unárias têm precedência sobre operações binárias.\n\n\n\n\nconversões explicitas &gt; casting\nQuando realizamos algumas operações aritméticas, pode ser necessário fazer uma conversão explicita.\nlong i;\nint j = 10000; // 10000 * 10000 -&gt; 100 000 000\n\ni = j * j;\n\nO resultado da multiplicação na linha 4 cabe na variável i de tipo long.\nContudo, o resultado da operação será um int e em algumas máquinas o resultado pode levar a overflow.\n\n\n\n\nconversões explicitas &gt; casting\nlong i;\nint j = 10000; // 10000 * 10000 -&gt; 100 000 000\n\ni = j * j;\n\ni = (long) j * j;\n\ni = (long) (j * j); // ERRADO\n\nPara resolver isso, podemos fazer o cast da linha 6.\nNa linha 8, a multiplicação é feita antes da conversão porque está entre ()."
  },
  {
    "objectID": "lectures/7_basic_types.html#definições-de-tipos",
    "href": "lectures/7_basic_types.html#definições-de-tipos",
    "title": "Tipos básicos do C",
    "section": "Definições de tipos",
    "text": "Definições de tipos\nO C permite a definição de novos tipos com o comando typedef.\ntypedef int Altura;\n\ntypedef é seguido do nome original do tipo\ne depois do novo nome que queremos usar\n\n\n\ntypedef\ntypedef int Altura;\ntypedef int Massa;\nAltura a = 180;\nMassa m = 75;\n\nEssencialmente, o que fizemos foi criar um int com um novo nome.\nÚtil para tornar o código mais legível\n\n\n\n\ntypedef\ntypedef int Altura;\ntypedef int massa;  // aceite, mas não é convenção\n\nint main(){\n  //...\n}\n\nAs definições de tipo ocorrem fora de qualquer função, tipicamente após os #include.\nOs nomes dos tipos obedecem às mesmas regras dos nomes das variáveis.\nÉ convenção no C, capitalizar os nomes dos tipos."
  },
  {
    "objectID": "lectures/7_basic_types.html#sizeof",
    "href": "lectures/7_basic_types.html#sizeof",
    "title": "Tipos básicos do C",
    "section": "sizeof",
    "text": "sizeof\nA função sizeof recebe um valor ou um tipo e indica qual é o tamanho, em bytes, que esse tipo ocupa em memória.\nchar c;\nprintf(\"size of int = %lu bytes\\n\", sizeof(int));  // 4\nprintf(\"size of char = %lu bytes\\n\", sizeof(3.14));  // 8 -&gt; double\nprintf(\"size of char = %lu bytes\\n\", sizeof(c));  // 1"
  },
  {
    "objectID": "lectures/06_ciclos.revealjshtml#ciclos",
    "href": "lectures/06_ciclos.revealjshtml#ciclos",
    "title": "Programação",
    "section": "Ciclos",
    "text": "Ciclos\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/06_ciclos.revealjshtml#ciclos-1",
    "href": "lectures/06_ciclos.revealjshtml#ciclos-1",
    "title": "Programação",
    "section": "Ciclos",
    "text": "Ciclos\n\nVideos\nSlides, PDF\n\n–\nVideos\n\nIntro - 1min\nwhile - 7min\ndo while - 4min\nfor - 6min\nfor demo - 3min\nfor demo 2 - 5min\nbreak, continue - 7min\nciclos infinitos - 3min"
  },
  {
    "objectID": "lectures/06_ciclos.html#ciclos",
    "href": "lectures/06_ciclos.html#ciclos",
    "title": "Programação",
    "section": "Ciclos",
    "text": "Ciclos\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/06_ciclos.html#ciclos-1",
    "href": "lectures/06_ciclos.html#ciclos-1",
    "title": "Programação",
    "section": "Ciclos",
    "text": "Ciclos\n\nVideos\nSlides, PDF\n\n–\n\nVideos\n\nIntro - 1min\nwhile - 7min\ndo while - 4min\nfor - 6min\nfor demo - 3min\nfor demo 2 - 5min\nbreak, continue - 7min\nciclos infinitos - 3min\n\n\n\n\nVideo 1/8 - Intro\n\n\n\n–\n\n\nVideo 2/8 - while\n\n\n\n–\n\n\nvideo 3/8 - do while\n\n\n\n–\n\n\nvideo 4/8 - for\n\n\n\n–\n\n\nvideo 5/8 - demo, for\n\n\n\n–\n\n\nvideo 5/8 - demo 2, for\n\n\n\n–\n\n\nvideo 7/8 - break, continue\n\n\n\n–\n\n\nvideo 8/8 - ciclos infinitos"
  },
  {
    "objectID": "lectures/08_funcoes.revealjshtml#funções",
    "href": "lectures/08_funcoes.revealjshtml#funções",
    "title": "Programação",
    "section": "Funções",
    "text": "Funções\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/08_funcoes.revealjshtml#funções-1",
    "href": "lectures/08_funcoes.revealjshtml#funções-1",
    "title": "Programação",
    "section": "Funções",
    "text": "Funções\n\nSlides, PDF\nVideos\n\n–\nFunções - videos 1/2\n\n\nIntro - 3min\nCaracteristicas - 3min\nExemplos, mais caracteristicas - 6min\nParâmetros - 9min\n\nIntro teórica - 2min\nDemo - 4min\nTipos - 1min\nErros de compilador - 1min\nReturn - 1min\n\n\n–\nFunções - videos 2/2\n\nProtótipos - 2min\nDemo - 4min\nVariáveis globais - 4min\nExercício variáveis globais - 4min"
  },
  {
    "objectID": "lectures/08_funcoes.html#funções",
    "href": "lectures/08_funcoes.html#funções",
    "title": "Programação",
    "section": "Funções",
    "text": "Funções\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/08_funcoes.html#funções-1",
    "href": "lectures/08_funcoes.html#funções-1",
    "title": "Programação",
    "section": "Funções",
    "text": "Funções\n\nSlides, PDF\nVideos\n\n–\n\nFunções - videos 1/2\n\n\nIntro - 3min\nCaracteristicas - 3min\nExemplos, mais caracteristicas - 6min\nParâmetros - 9min\n\nIntro teórica - 2min\nDemo - 4min\nTipos - 1min\nErros de compilador - 1min\nReturn - 1min\n\n\n–\n\n\nFunções - videos 2/2\n\nProtótipos - 2min\nDemo - 4min\nVariáveis globais - 4min\nExercício variáveis globais - 4min"
  },
  {
    "objectID": "lectures/09_arrays.revealjshtml#array",
    "href": "lectures/09_arrays.revealjshtml#array",
    "title": "Programação",
    "section": "Array",
    "text": "Array\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/09_arrays.revealjshtml#array-1",
    "href": "lectures/09_arrays.revealjshtml#array-1",
    "title": "Programação",
    "section": "Array",
    "text": "Array\n\nVideos\nSlides, PDF\nSlides, extra\n\n–\n\nvideos 1/2\n\nIntro, criar, mudar - 5min\nArrays e funções - 5min\nDemo exercício salários - 14min\n\n00:00 explicar enunciado\n01:10 inicio da solução\n02:28 função pedir salarios\n04:05 função para mostrar salários\n07:25 função para somar salários\n9:30 função para a média dos salários\n11:56 utilizador indica quantos salários quer introduzir\n\n\n–\nvideos 2/2\n\nArrays multi-dimensionais - 4min\nDemo Arrays multi-dimensionais - 10min\n\n0:00 explicação do enunciado\n0:56 inicio do resolução\n\nErros comuns, VLAs - 5min"
  },
  {
    "objectID": "lectures/09_arrays.html#array",
    "href": "lectures/09_arrays.html#array",
    "title": "Programação",
    "section": "Array",
    "text": "Array\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/09_arrays.html#array-1",
    "href": "lectures/09_arrays.html#array-1",
    "title": "Programação",
    "section": "Array",
    "text": "Array\n\nVideos\nSlides, PDF\nSlides, extra\n\n–\n\n\nvideos 1/2\n\nIntro, criar, mudar - 5min\nArrays e funções - 5min\nDemo exercício salários - 14min\n\n00:00 explicar enunciado\n01:10 inicio da solução\n02:28 função pedir salarios\n04:05 função para mostrar salários\n07:25 função para somar salários\n9:30 função para a média dos salários\n11:56 utilizador indica quantos salários quer introduzir\n\n\n–\n\n\nvideos 2/2\n\nArrays multi-dimensionais - 4min\nDemo Arrays multi-dimensionais - 10min\n\n0:00 explicação do enunciado\n0:56 inicio do resolução\n\nErros comuns, VLAs - 5min\n\n\n\n\n\nErros comuns\n\nAceder a posições inexistentes do array\nC permite mas o comportamento não está definido.\n\nint vec[20];\nvec[25] = 4;\n\n\n\nArrays de tamanho variável (VLA)\n\nO que são?\nExemplos\nVLA e funções\nVLA multidimensional e funções\n\n–\n\n\nVLA - o que são?\n\nVariable Length Arrays (VLA)\nDisponíveis apenas para compiladores &gt;C99\nPermitem criar arrays cujo tamanho é definido durante a execução do programa\nEstes arrays não podem ser globais.\nAplicável a arrays multi-dimensionais.\n\n–\n\nVLA - exemplo 1\nunsigned int n;\nprintf(\"tamanho do vector:\");\nscanf(\"%u\", &n);\nint posicoes[n];\n–\n\n\nVLA - exemplo 2 - multi-dimensional\nunsigned int rows, cols;\nprintf(\"linhas e colunas da matriz:\");\nscanf(\"%u%u\", &rows, &cols);\nint matrix[rows][cols];\n–\n\n\nVLA e funções\nint func(int n, int vec[n]){\n   //...\n}\n–\n\n\nVLA multi-dimensional e funções\nint func(int rows, int cols, int mat[rows][cols]){\n   //...\n}\nDesta forma, deixa de ser necessário especificar o tamanho concreto das últimas N-1 dimensões."
  },
  {
    "objectID": "lectures/0_home.revealjshtml#programação",
    "href": "lectures/0_home.revealjshtml#programação",
    "title": "Programação",
    "section": "Programação",
    "text": "Programação\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt"
  },
  {
    "objectID": "lectures/0_home.revealjshtml#links-úteis",
    "href": "lectures/0_home.revealjshtml#links-úteis",
    "title": "Programação",
    "section": "Links úteis",
    "text": "Links úteis\n\nReplit PROG\nTeams PROG\nFicheiros SharePoint"
  },
  {
    "objectID": "lectures/0_home.revealjshtml#índice",
    "href": "lectures/0_home.revealjshtml#índice",
    "title": "Programação",
    "section": "Índice",
    "text": "Índice\n\n\n\nApresentação da UC\n\n\nC Fundamentals\n\n\nLeitura e escrita formatada\n\n\nExpressões\n\n\nTestes e Condições\n\n\nCiclos\n\n\nTipos básicos do C\n\n\nFunções\n\n\nArrays\n\n\nStrings\n\n\nApontadores\n\n\nStruct\n\n\nFicheiros\n\n\nMemória\n\n\nDynamic Data Structures\n\n\nExtra\n\n\nExercícios\n\n\n\nPressionar a tecla Esc (Escape) para ver todos os slides."
  },
  {
    "objectID": "lectures/0_home.html#programação",
    "href": "lectures/0_home.html#programação",
    "title": "Labs",
    "section": "Programação",
    "text": "Programação\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n\n\n\natalhos da apresentação\nEsc    | mostra panaroma de todos os slides\nWASD   | navegar nos slides\nEspaço | slide seguinte\n← →    | slide anterior/seguinte"
  },
  {
    "objectID": "lectures/0_home.html#links-úteis",
    "href": "lectures/0_home.html#links-úteis",
    "title": "Labs",
    "section": "Links úteis",
    "text": "Links úteis\n\nReplit PROG\nTeams PROG\nFicheiros SharePoint"
  },
  {
    "objectID": "lectures/0_home.html#índice",
    "href": "lectures/0_home.html#índice",
    "title": "Labs",
    "section": "Índice",
    "text": "Índice\n\n\n\nApresentação da UC\n\n\nC Fundamentals\n\n\nLeitura e escrita formatada\n\n\nExpressões\n\n\nTestes e Condições\n\n\nCiclos\n\n\nTipos básicos do C\n\n\nFunções\n\n\nArrays\n\n\nStrings\n\n\nApontadores\n\n\nStruct\n\n\nFicheiros\n\n\nMemória\n\n\nDynamic Data Structures\n\n\nExtra\n\n\nExercícios\n\n\n\nPressionar a tecla Esc (Escape) para ver todos os slides.\n\n\n\nSetup VSCode locally"
  },
  {
    "objectID": "lectures/10_strings.revealjshtml#string",
    "href": "lectures/10_strings.revealjshtml#string",
    "title": "Programação",
    "section": "String",
    "text": "String\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/10_strings.revealjshtml#string-1",
    "href": "lectures/10_strings.revealjshtml#string-1",
    "title": "Programação",
    "section": "String",
    "text": "String\n\nVideos\nSlides, PDF\n\n–\n\nvideos sharepoint\n\nStrings Playlist\n\nIntro - 1min\nCriar, inicializar, literal - 5min\nLer, escrever - 5min\nFunções, string.h\nDemo - strlen\nDemo - strcpy\nDemo - strcat\nDemo - strcmp\n\n\n–\nvideos 1/2\n\n\nIntro - 1min\nCriar, inicializar, literal - 5min\nLer, escrever - 5min\nFunções, string.h\n\n–\nvideos 2/2\n\n\nDemos\n\nstrlen\nstrcpy\nstrcat\nstrcmp"
  },
  {
    "objectID": "lectures/10_strings.html#string",
    "href": "lectures/10_strings.html#string",
    "title": "Programação",
    "section": "String",
    "text": "String\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/10_strings.html#string-1",
    "href": "lectures/10_strings.html#string-1",
    "title": "Programação",
    "section": "String",
    "text": "String\n\nVideos\nSlides, PDF\n\n–\n\n\nvideos sharepoint\n\nStrings Playlist\n\nIntro - 1min\nCriar, inicializar, literal - 5min\nLer, escrever - 5min\nFunções, string.h\nDemo - strlen\nDemo - strcpy\nDemo - strcat\nDemo - strcmp\n\n\n–\n\n\nvideos 1/2\n\n\nIntro - 1min\nCriar, inicializar, literal - 5min\nLer, escrever - 5min\nFunções, string.h\n\n–\n\n\nvideos 2/2\n\n\nDemos\n\nstrlen\nstrcpy\nstrcat\nstrcmp"
  },
  {
    "objectID": "lectures/11_pointer.revealjshtml#apontadores",
    "href": "lectures/11_pointer.revealjshtml#apontadores",
    "title": "Programação",
    "section": "Apontadores",
    "text": "Apontadores\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/11_pointer.revealjshtml#apontadores-1",
    "href": "lectures/11_pointer.revealjshtml#apontadores-1",
    "title": "Programação",
    "section": "Apontadores",
    "text": "Apontadores\n\nVideos\nSlides, PDF\n\n–\nVideos\n\n\nIntro, declaração, endereço e desreferenciar - 4min, Loom, Sharepoint\nExemplos - 6min, Loom, Sharepoint\nOperações - 5min, Loom, Sharepoint\nLoom, Apontadores e arrays - 4min, Sharepoint\nApontadores de apontadores - 4min, Loom, Sharepoint\nFunções - passagem por valor vs. referência - 3min, Loom, Sharepoint\nExercício - passagem por valor vs. referência - 2min, Loom, Sharepoint"
  },
  {
    "objectID": "lectures/11_pointer.html#apontadores",
    "href": "lectures/11_pointer.html#apontadores",
    "title": "Programação",
    "section": "Apontadores",
    "text": "Apontadores\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/11_pointer.html#apontadores-1",
    "href": "lectures/11_pointer.html#apontadores-1",
    "title": "Programação",
    "section": "Apontadores",
    "text": "Apontadores\n\nVideos\nSlides, PDF\n\n–\n\nVideos\n\n\nIntro, declaração, endereço e desreferenciar - 4min, Loom, Sharepoint\nExemplos - 6min, Loom, Sharepoint\nOperações - 5min, Loom, Sharepoint\nLoom, Apontadores e arrays - 4min, Sharepoint\nApontadores de apontadores - 4min, Loom, Sharepoint\nFunções - passagem por valor vs. referência - 3min, Loom, Sharepoint\nExercício - passagem por valor vs. referência - 2min, Loom, Sharepoint"
  },
  {
    "objectID": "lectures/12_struct.revealjshtml#struct",
    "href": "lectures/12_struct.revealjshtml#struct",
    "title": "Programação",
    "section": "Struct",
    "text": "Struct\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/12_struct.revealjshtml#struct-1",
    "href": "lectures/12_struct.revealjshtml#struct-1",
    "title": "Programação",
    "section": "Struct",
    "text": "Struct\n\nVideos\nSlides, PDF\nExercícios\n\n–\n\nvideos 1/2\n\nIntro, motivação | 1.5min\nDeclarar, aceder | 4min\nComparação, estruturas dentro de estruturas, funções | 4min\ntypedef | 2min\nestruturas e apontadores | 4min\n\n–\nvideos 2/2\n\nDemo 1 | 10min\nDemo 1 | correção de criar_aluno | 3min\nDemo 1a | vector de Aluno | 4min\nDemo 1b\nDemo 1c\nDemo 1d\nDemo 1f\nDemo 1g\n\n–\nExercício 1\n\nEscreva um programa que guarde e mostre o registo de um aluno Aluno da cadeira de programação.\nUm aluno tem os seguintes parâmetros:\n\nnome (string)\nNIP (int)\nnotas (vector com 3 números reais para guardar as classificações das avaliações)\n\nEscreva uma função criar_aluno que pede os dados do aluno ao utilizador e devolve um registo de aluno com esses dados.\nEscreva uma função mostrar_aluno que recebe o apontador de um registo de aluno e imprime os seus valores na consola.\n\n–\nExercício 1a\n\nExpanda o programa anterior para mostrar os registos dos alunos da cadeira de Programação.\nCrie um vector de Aluno de tamanho MAX_ALUNOS e uma variável n_alunos que recebe do utilizador quantos alunos vai receber.\nPeça os dados de todos os alunos a receber e no final, escreva na consola os dados de todos os alunos.\n\n–\nExercício 1b\n\nModifique o programa anterior por forma a termos várias Unidades Curriculares (UC).\nCrie uma estrutura para uma UC, com os seguintes campos:\n\nnome (string, max 50 chars)\nabreviatura (vector 4 chars)\nn_creditos (int): número de créditos (ECTS)\nalunos (vector de apontadores para Aluno, max 100): lista de alunos inscritos\nn_inscritos (unsigned char): número de alunos inscritos\navals (vector de reais): notas finais dos alunos à UC\n\nAgora a estrutura Aluno já não precisa do campo notas, estes dados estão guardados nas UCs. Remova esse campo.\nAgora a lista de Aluno é a lista de todos os alunos.\nCrie um vector para a lista de UCs (tamanho de MAX_UC) na main.\nCrie a função criarUC:\n\nnão recebe argumentos\npede os dados de uma UC (nome, abreviatura, número de créditos) ao utilizador\ndevolver a UC criada\n\nCria a função mostrarUC\n\nrecebe um apontador de UC\nmostra os dados da UC, incluindo a lista dos alunos inscritos\n\nDicas:\n\npara facilitar o teste das funcionalidades, inicialize o vector de todos os alunos com dados no código\npara facilitar o teste das funcionalidades, inicialize o vetor de todas as UCs com algumas UCs já com alunos inscritos\n\n\n–\nExercício 1c\n\nImplementa a função media_UC que recebe um apontador de UC e calcula a média das notas dos alunos.\nAltera a função mostrarUC para mostrar a média da UC que recebe.\n\n–\nExercício 1d\n\nImplementa a função media_aluno\n\nrecebe\n\napontador de Aluno\nlista de todas as UCs\n\ndevolve\n\nvalor real com a média ponderada (ter em conta os ECTS de cada UC) de todas as UCs em que o aluno está inscrito\n\nesta função tem de percorrer todas as UCs e verificar se o aluno está inscrito nessa UC\n\n\n–\nExercício 1e\n\nImplementa a função media_total\n\nrecebe\n\nlista de todos os alunos\nlista de todas as UCs\n\ndevolve\n\nreal correspondente à média aritmética da média ponderada de todos os alunos\n\n\n\n–\nExercício 1f\n\nImplementa a função inscrever_UC\n\nrecebe apontador de UC\nlista de todos os alunos\n\nmostra lista de todos os alunos\nutilizador escolhe quais os alunos da lista a inscrever nesta UC\n\nescrever os índices e terminar lista com algum carater não numérico\nexemplo:\nLista de todos os alunos:\n        0 - 136787 - Asimov\n        1 - 136867 - Turing\n        2 - 122444 - Oppenheimer\n        3 - 133555 - Newton\nÍndices dos alunos que quer inscrever (separados por espaço):\n1 5 3 f\n\nadicionar os alunos escolhidos ao vetor alunos da UC\n\n–\nExercício 1g\n\nImplementa a função inscrever_aluno\n\nrecebe\n\napontador de Aluno\nlista de todas as UCs\n\nmostra lista de todas as UCs e permite escolher as UCs em que o aluno está inscrito\npara cada UC selecionada\n\nadicionar o aluno à lista de inscritos\n\nnão devolve nada"
  },
  {
    "objectID": "lectures/12_struct.html#struct",
    "href": "lectures/12_struct.html#struct",
    "title": "Programação",
    "section": "Struct",
    "text": "Struct\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/12_struct.html#struct-1",
    "href": "lectures/12_struct.html#struct-1",
    "title": "Programação",
    "section": "Struct",
    "text": "Struct\n\nVideos\nSlides, PDF\nExercícios\n\n–\n\n\nvideos 1/2\n\nIntro, motivação | 1.5min\nDeclarar, aceder | 4min\nComparação, estruturas dentro de estruturas, funções | 4min\ntypedef | 2min\nestruturas e apontadores | 4min\n\n–\n\n\nvideos 2/2\n\nDemo 1 | 10min\nDemo 1 | correção de criar_aluno | 3min\nDemo 1a | vector de Aluno | 4min\nDemo 1b\nDemo 1c\nDemo 1d\nDemo 1f\nDemo 1g\n\n–\n\n\nExercício 1\n\nEscreva um programa que guarde e mostre o registo de um aluno Aluno da cadeira de programação.\nUm aluno tem os seguintes parâmetros:\n\nnome (string)\nNIP (int)\nnotas (vector com 3 números reais para guardar as classificações das avaliações)\n\nEscreva uma função criar_aluno que pede os dados do aluno ao utilizador e devolve um registo de aluno com esses dados.\nEscreva uma função mostrar_aluno que recebe o apontador de um registo de aluno e imprime os seus valores na consola.\n\n–\n\n\nExercício 1a\n\nExpanda o programa anterior para mostrar os registos dos alunos da cadeira de Programação.\nCrie um vector de Aluno de tamanho MAX_ALUNOS e uma variável n_alunos que recebe do utilizador quantos alunos vai receber.\nPeça os dados de todos os alunos a receber e no final, escreva na consola os dados de todos os alunos.\n\n–\n\n\nExercício 1b\n\nModifique o programa anterior por forma a termos várias Unidades Curriculares (UC).\nCrie uma estrutura para uma UC, com os seguintes campos:\n\nnome (string, max 50 chars)\nabreviatura (vector 4 chars)\nn_creditos (int): número de créditos (ECTS)\nalunos (vector de apontadores para Aluno, max 100): lista de alunos inscritos\nn_inscritos (unsigned char): número de alunos inscritos\navals (vector de reais): notas finais dos alunos à UC\n\nAgora a estrutura Aluno já não precisa do campo notas, estes dados estão guardados nas UCs. Remova esse campo.\nAgora a lista de Aluno é a lista de todos os alunos.\nCrie um vector para a lista de UCs (tamanho de MAX_UC) na main.\nCrie a função criarUC:\n\nnão recebe argumentos\npede os dados de uma UC (nome, abreviatura, número de créditos) ao utilizador\ndevolver a UC criada\n\nCria a função mostrarUC\n\nrecebe um apontador de UC\nmostra os dados da UC, incluindo a lista dos alunos inscritos\n\nDicas:\n\npara facilitar o teste das funcionalidades, inicialize o vector de todos os alunos com dados no código\npara facilitar o teste das funcionalidades, inicialize o vetor de todas as UCs com algumas UCs já com alunos inscritos\n\n\n–\n\n\nExercício 1c\n\nImplementa a função media_UC que recebe um apontador de UC e calcula a média das notas dos alunos.\nAltera a função mostrarUC para mostrar a média da UC que recebe.\n\n–\n\n\nExercício 1d\n\nImplementa a função media_aluno\n\nrecebe\n\napontador de Aluno\nlista de todas as UCs\n\ndevolve\n\nvalor real com a média ponderada (ter em conta os ECTS de cada UC) de todas as UCs em que o aluno está inscrito\n\nesta função tem de percorrer todas as UCs e verificar se o aluno está inscrito nessa UC\n\n\n–\n\n\nExercício 1e\n\nImplementa a função media_total\n\nrecebe\n\nlista de todos os alunos\nlista de todas as UCs\n\ndevolve\n\nreal correspondente à média aritmética da média ponderada de todos os alunos\n\n\n\n–\n\n\nExercício 1f\n\nImplementa a função inscrever_UC\n\nrecebe apontador de UC\nlista de todos os alunos\n\nmostra lista de todos os alunos\nutilizador escolhe quais os alunos da lista a inscrever nesta UC\n\nescrever os índices e terminar lista com algum carater não numérico\nexemplo:\nLista de todos os alunos:\n        0 - 136787 - Asimov\n        1 - 136867 - Turing\n        2 - 122444 - Oppenheimer\n        3 - 133555 - Newton\nÍndices dos alunos que quer inscrever (separados por espaço):\n1 5 3 f\n\nadicionar os alunos escolhidos ao vetor alunos da UC\n\n–\n\n\nExercício 1g\n\nImplementa a função inscrever_aluno\n\nrecebe\n\napontador de Aluno\nlista de todas as UCs\n\nmostra lista de todas as UCs e permite escolher as UCs em que o aluno está inscrito\npara cada UC selecionada\n\nadicionar o aluno à lista de inscritos\n\nnão devolve nada"
  },
  {
    "objectID": "lectures/13_files.revealjshtml#ficheiros",
    "href": "lectures/13_files.revealjshtml#ficheiros",
    "title": "Programação",
    "section": "Ficheiros",
    "text": "Ficheiros\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/13_files.revealjshtml#ficheiros-1",
    "href": "lectures/13_files.revealjshtml#ficheiros-1",
    "title": "Programação",
    "section": "Ficheiros",
    "text": "Ficheiros\n\nVideos\nSlides, PDF\n\n–\nvideos\n\nIntro\nFicheiros geral\nFicheiros de texto\nTexto demo\nFicheiros binários\n\nErrata: eu digo que o valor de retorno de fread e fwrite é o número de bytes. Na verdade é o número de items lidos. Só é o número de bytes se o tamanho do item for 1 byte.\n\nBinários demo"
  },
  {
    "objectID": "lectures/13_files.html#ficheiros",
    "href": "lectures/13_files.html#ficheiros",
    "title": "Programação",
    "section": "Ficheiros",
    "text": "Ficheiros\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/13_files.html#ficheiros-1",
    "href": "lectures/13_files.html#ficheiros-1",
    "title": "Programação",
    "section": "Ficheiros",
    "text": "Ficheiros\n\nVideos\nSlides, PDF\n\n–\n\nvideos\n\nIntro\nFicheiros geral\nFicheiros de texto\nTexto demo\nFicheiros binários\n\nErrata: eu digo que o valor de retorno de fread e fwrite é o número de bytes. Na verdade é o número de items lidos. Só é o número de bytes se o tamanho do item for 1 byte.\n\nBinários demo"
  },
  {
    "objectID": "lectures/14_memoria.revealjshtml#memória",
    "href": "lectures/14_memoria.revealjshtml#memória",
    "title": "Programação",
    "section": "Memória",
    "text": "Memória\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/14_memoria.revealjshtml#memória-1",
    "href": "lectures/14_memoria.revealjshtml#memória-1",
    "title": "Programação",
    "section": "Memória",
    "text": "Memória\n\nVideos\nSlides, PDF\n\n–\nvideos\n\nIntro, Loom, SharePoint\nmalloc, calloc, free, Loom, SharePoint"
  },
  {
    "objectID": "lectures/14_memoria.html#memória",
    "href": "lectures/14_memoria.html#memória",
    "title": "Programação",
    "section": "Memória",
    "text": "Memória\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–"
  },
  {
    "objectID": "lectures/14_memoria.html#memória-1",
    "href": "lectures/14_memoria.html#memória-1",
    "title": "Programação",
    "section": "Memória",
    "text": "Memória\n\nVideos\nSlides, PDF\n\n–\n\nvideos\n\nIntro, Loom, SharePoint\nmalloc, calloc, free, Loom, SharePoint"
  },
  {
    "objectID": "lectures/16_extra.revealjshtml#extra",
    "href": "lectures/16_extra.revealjshtml#extra",
    "title": "Programação",
    "section": "Extra",
    "text": "Extra\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–\nTópicos extra\n\nUnit testing"
  },
  {
    "objectID": "lectures/16_extra.html#extra",
    "href": "lectures/16_extra.html#extra",
    "title": "Programação",
    "section": "Extra",
    "text": "Extra\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n–\n\n\nTópicos extra\n\nUnit testing"
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#tópicos",
    "href": "lectures/2_fundamentals.revealjshtml#tópicos",
    "title": "Fundamentos do C",
    "section": "Tópicos",
    "text": "Tópicos\n\nO primeiro programa\nComponentes de um programa\nComentários\nVariáveis\nI/O Receber Valores\nConstantes\nIdentificadores"
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#o-primeiro-programa",
    "href": "lectures/2_fundamentals.revealjshtml#o-primeiro-programa",
    "title": "Fundamentos do C",
    "section": "O primeiro programa",
    "text": "O primeiro programa\n\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nO que está a acontecer? \nEste programa simples escreve no terminal a frase “Hello world!”, sem as “."
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#componentes-de-um-programa",
    "href": "lectures/2_fundamentals.revealjshtml#componentes-de-um-programa",
    "title": "Fundamentos do C",
    "section": "Componentes de um programa",
    "text": "Componentes de um programa\n\n#diretivas\n\nint main(){\n    instruções;\n}"
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#comentários",
    "href": "lectures/2_fundamentals.revealjshtml#comentários",
    "title": "Fundamentos do C",
    "section": "Comentários",
    "text": "Comentários\n\nO nosso primeiro programa não tem algo importante:\ndocumentação"
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#variáveis",
    "href": "lectures/2_fundamentals.revealjshtml#variáveis",
    "title": "Fundamentos do C",
    "section": "Variáveis",
    "text": "Variáveis\nA maior parte dos programas executa uma série de cálculos. \nPara isso, precisam de um mecanismo para guardar dados de forma temporária. \nÉ para isso que servem as variáveis."
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#io-receber-valores",
    "href": "lectures/2_fundamentals.revealjshtml#io-receber-valores",
    "title": "Fundamentos do C",
    "section": "I/O receber valores",
    "text": "I/O receber valores\nJá sabemos mostrar valores ao utilizador do programa, mas como receber dados?\nUsamos a função scanf."
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#constantes",
    "href": "lectures/2_fundamentals.revealjshtml#constantes",
    "title": "Fundamentos do C",
    "section": "Constantes",
    "text": "Constantes"
  },
  {
    "objectID": "lectures/2_fundamentals.revealjshtml#identificadores",
    "href": "lectures/2_fundamentals.revealjshtml#identificadores",
    "title": "Fundamentos do C",
    "section": "Identificadores",
    "text": "Identificadores\nOs nomes que escolhemos para as nossas variáveis, funções, etc. designam-se por identificadores e existem regras que devem ser seguidas."
  },
  {
    "objectID": "lectures/2_fundamentals.html",
    "href": "lectures/2_fundamentals.html",
    "title": "Fundamentos do C",
    "section": "",
    "text": "O primeiro programa\nComponentes de um programa\nComentários\nVariáveis\nI/O Receber Valores\nConstantes\nIdentificadores"
  },
  {
    "objectID": "lectures/2_fundamentals.html#tópicos",
    "href": "lectures/2_fundamentals.html#tópicos",
    "title": "Fundamentos do C",
    "section": "",
    "text": "O primeiro programa\nComponentes de um programa\nComentários\nVariáveis\nI/O Receber Valores\nConstantes\nIdentificadores"
  },
  {
    "objectID": "lectures/2_fundamentals.html#o-primeiro-programa",
    "href": "lectures/2_fundamentals.html#o-primeiro-programa",
    "title": "Fundamentos do C",
    "section": "O primeiro programa",
    "text": "O primeiro programa\n\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nO que está a acontecer? \nEste programa simples escreve no terminal a frase “Hello world!”, sem as “. \n\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\n“Importa” código externo ao nosso programa, permitindo chamar a função printf, que não está aqui definida.\n\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nÉ a função principal do programa. Os programas em C começam sempre nesta função. Todos os programas têm uma função main.\n\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nÉ uma instrução que chama a função printf da biblioteca stdio.h (que faz parte do próprio C), dando-lhe como input o literal de string \"Hello world!\".\nA função “imprime” no terminal o input recebido.\nTodas as instruções no C acabam com ;. \n\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nEspecifica o valor de retorno do nosso programa, neste caso 0.\n\n\nEscrevi o código, e agora?\n\n\npré-processamento\n\nobedece a comandos que começam com # (diretivas) \nfunciona um pouco como um editor de texto, onde se adicionam ou modificam partes do código \n\ncompilação\n\ntransformar o código C numa linguagem que o computador perceba = linguagem máquina \n\nlinking\n\ncombina o output gerado pela compilação com outro código necessário à execução do programa (e.g. stdio.h para usar o printf) \n\n\n\nQuando damos indicação ao nosso IDE para compilar e correr o código, estes 3 passos tipicamente acontecem de forma automática."
  },
  {
    "objectID": "lectures/2_fundamentals.html#componentes-de-um-programa",
    "href": "lectures/2_fundamentals.html#componentes-de-um-programa",
    "title": "Fundamentos do C",
    "section": "Componentes de um programa",
    "text": "Componentes de um programa\n\n#diretivas\n\nint main(){\n    instruções;\n}\n\n\nA diretiva include\n#include &lt;stdio.h&gt;\nEsta diretiva indica que o conteúdo da biblioteca stdio.h deve ser incluida no programa atual.\n\n\n\nFunções\nFunções são procedimentos ou subrotinas que executam uma determinado conjunto de instruções.\nCada função é uma determinada receita para um determinado comportamento ou funcionalidade. \nIsto permite que o mesmo comportamento seja executado diversas vezes num programa sem o ter que implementar múltiplas vezes. \n\n\n\nInstruções\nUma instrução é um comando que é executado quando o programa corre, e.g.\nprintf(\"Hello world!\");\n\n\n\nI/O printf\nA capacidade de um programa comunicar com o mundo exterior é fundamental para que seja útil.\nNo nosso primeiro programa, essa comunicação foi feita com a função printf e o output foi apresentado num terminal.\n\nAnteriormente foi referido que a função recebeu um literal de string, uma série sequencial de caracteres entre ““.\nAs “” não são incluidas no que aparece no terminal. Se quisermos incluir ” no nosso output, é necessário escrever \".\n\nO printf não inclui automaticamente o fim de linha.\nPara garantir que o printf seguinte não apresenta o seu conteúdo na mesma linha do anterior, é necessário adicionar \\n.\nprintf(\"Hello world!\\n\");\nprintf(\"Good morning, Vietnam!\");"
  },
  {
    "objectID": "lectures/2_fundamentals.html#comentários",
    "href": "lectures/2_fundamentals.html#comentários",
    "title": "Fundamentos do C",
    "section": "Comentários",
    "text": "Comentários\n\nO nosso primeiro programa não tem algo importante:\n\ndocumentação\n\nOs programas devem ter várias informações sobre o programa em si, e.g. autor, propósito, etc.\n/* Nome: hello_world.c*/\n/* Autor: Diogo Silva*/\n/* Proposito: Mostrar \"Hello world!\" na consola.*/\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nNo C, escrevemos comentários entre /* */. Todo o texto entre estes símbolos é ignorado pelo comentário, i.e. não é interpretado como código. \n\n/*\nNome: hello_world.c\nAutor: Diogo Silva\nProposito: Mostrar \"Hello world!\" na consola.\n*/\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\");\n    return 0;\n}\nUm comentário pode compreender várias linhas.\n\nTambém podemos escrever comentários de apenas uma linha com o símbolo //.\nTudo o que vem depois deste símbolo é interpretado como um comentário.\n#include &lt;stdio.h&gt;\n\nint main(){\n    printf(\"Hello world!\"); // escrever na consola\n    return 0;\n}\nA legibilidade do programa aumenta bastante quando existem comentários que descrevem de forma sumária porções do código."
  },
  {
    "objectID": "lectures/2_fundamentals.html#variáveis",
    "href": "lectures/2_fundamentals.html#variáveis",
    "title": "Fundamentos do C",
    "section": "Variáveis",
    "text": "Variáveis\nA maior parte dos programas executa uma série de cálculos. \nPara isso, precisam de um mecanismo para guardar dados de forma temporária. \nÉ para isso que servem as variáveis. \n\nAs variáveis são locais na memória onde é possível gravar algum dado, temporáriamente, durante a execução do programa.\n\n\nVariáveis: Tipos\nNo C, todas as variáveis têm um tipo associado.\nO C tem vários tipos de dados, mas para já usaremos apenas 2 tipos numéricos: \n\nint (inteiro)\nfloat (real, floating point)\n\n\n\nUma analogia aos tipos são os domínios na matemática, e.g. int pode ser comparado ao dominio dos números naturais.\nAssociado a um tipo, existe:  - um conjunto de valores válidos (e.g. números inteiros positivos até 65.535)  - operações válidas nos valores desse tipo (+ - * /) \n\nDiferentes tipos incluem diferentes conjuntos de valores válidos.\nO C tem vários int que incluem diferentes intervalos de valores possíveis e.g. típicamente, int inclui valores inteiros no intervalo [-65536, 65535].\n\nO float inclui valores muito maiores que um int, e contempla valores reais, e.g. 3.14.\nOperações aritméticas em float podem ser mais lentas.\n\n\n\nVariáveis: declaração\nQuando queremos usar uma variável, esta tem de ser declarada.\nint altura; // em cm\nfloat massa; // em kg\naltura é uma variável do tipo int e massa é uma variável do tipo float.\n\nTambém podemos declarar várias variáveis de um determinado tipo numa só linha.\nint altura, idade; // cm, meses\nfloat massa, lucro; // kg, €\n\n\n\nVariáveis: atribuição\nAs variáveis recebem valores através da instrução de atribuição =.\nint altura; // em cm\nfloat massa; // em kg\n\naltura = 180;\nmassa = 75.2;\naltura tem agora o valor 180 e massa tem o valor 75.2 \n180 e 75.2 são constantes. \n\nDepois das variáveis terem um valor atribuido, podem ser usadas no cálculo de outros valores.\nint altura; // em cm\nfloat massa, imc; // em kg\n\naltura = 180;\nmassa = 75.2;\nimc = massa / (altura / 100.0); //indice massa corporal\n\nAs variáveis só podem ser usadas depois de declaradas. Ver linha 3.\nint altura; // em cm\n\nmassa = 75.2;\n\nfloat massa, imc; // em kg\n\naltura = 180;\n\nimc = massa / (altura / 100.0); //indice massa corporal\nEste código é inválido porque estamos a atribuir um valor à variável massa, que ainda não foi declarada.\n\n\n\nVariáveis: printf\nSe quisermos mostrar o valor de uma determinada variável, podemos usar novamente a função printf.\nint altura; // em cm\nfloat massa, imc; // em kg\n\naltura = 180;\nmassa = 75.2;\nprintf(\"Altura: %d\\n\", altura);\nO que significa o símbolo %d? \n\n%d indica como é que o valor contido na variável altura deve ser interpretado.\nNeste caso, %d indica que deve ser interpretado como um valor inteiro int. \nO descritor escolhido deve ser coerente com o tipo da variável que se vai mostrar. \naltura é do tipo int, logo usamos o descritor %d. \n\nint altura; // em cm\nfloat massa, imc; // em kg\n\naltura = 180;\nmassa = 75.2;\nimc = massa / (altura / 100.0); //indice massa corporal\nprintf(\"Indice massa corporal: %f\\n\", imc);\nO descritor %f é usado para valores do tipo float.\n\n\nint -&gt; %d\nfloat -&gt; %f\n\n\n\n\n\n\n\nImportante\n\n\n\n\n\nO C não impede um “desalinhamento” entre tipo e descritor - é responsabildiade do programador garantir a coerência.\n\n\n\n\n\n\nVariáveis: printf de expressões\nO cálculo do IMC na variável intermédia imc é desnecessário, uma vez que podemos inserir a expressão completa do cálculo na função printf.\nint altura; // em cm\nfloat massa, imc; // em kg\n\naltura = 180;\nmassa = 75.2;\nprintf(\"Indice massa corporal: %f\\n\", massa / (altura / 100.0));\n\n\n\nO que é uma expressão?\n\nUma expressão é algo que produz um valor concreto.\nUma expressão produz sempre um valor com um valor concreto, mesmo quando variáveis de tipos diferentes são misturadas (conversão automática de tipos será abordada posteriormente.)\nUm valor de um determinado tipo pode sempre ser substituido por uma expressão do mesmo tipo.\n\n\n\n\nVariáveis: inicialização\n\nAlgumas variáveis são automaticamente inicializadas com o valor de 0 quando são declaradas, mas a maior parte não é.\nUma variável que não tenha um valor por defeito e que não tenha sofrido nenhuma atribuição está não inicializada.\n\n\nÉ importante perceber que o C permite que uma variável seja usada em cálculos, mesmo não tenha sido inicializada.\nint altura; // em cm\nfloat massa, imc; // em kg\n\nmassa = 75.2;\nimc = massa / (altura / 100.0); //indice massa corporal\nÉ responsabilidade do programador saber que o programa pode ter um comportamento inválido, porque a variável que não foi inicializada (não teve nenhuma atribuição) pode conter qualquer valor. \n\nAs variáveis podem ser inicializadas no momento da sua declaração.\nint altura=180; // em cm\nfloat massa=75.2, imc=0.0; // em kg\n\n\n\nExercício\n\nConversão de Fahrenheit para Celsius.\nC = \\frac{5}{9}(F-32)"
  },
  {
    "objectID": "lectures/2_fundamentals.html#io-receber-valores",
    "href": "lectures/2_fundamentals.html#io-receber-valores",
    "title": "Fundamentos do C",
    "section": "I/O receber valores",
    "text": "I/O receber valores\nJá sabemos mostrar valores ao utilizador do programa, mas como receber dados?\nUsamos a função scanf. \n\nA função scanf funciona como o printf, mas na direção oposta.\nscanf(\"%d\", &a);\nscanf(\"%f\", &b);\nIndicamos o formato dos dados que vamos receber e a variável onde os queremos guardar. \n\nscanf(\"%d\", &a);  // receber altura do utilizador\nscanf(\"%f\", &b);  // receber altura do utilizador\nAssumindo que já foram declaradas, qual será o tipo das variáveis a e b?\nSabemos que %d funciona com valores int, logo a deverá ser do tipo int. \nNa mesma linha, b deverá ser um float. \n\nE o que significa o & antes do nome das variáveis?\nscanf(\"%d\", &a);\nscanf(\"%f\", &b);\nÉ um operador que devolve o endereço de memória da variável. \nIremos explorar este operador em detalhe no futuro. Até lá, saibam apenas que usamos quase sempre o & antes do nome da variável. \n\n\nExercício\nConversão de ºF para ºC.\nAlterar o exercício anterior para receber os valores do utilizador."
  },
  {
    "objectID": "lectures/2_fundamentals.html#constantes",
    "href": "lectures/2_fundamentals.html#constantes",
    "title": "Fundamentos do C",
    "section": "Constantes",
    "text": "Constantes\n\n\nO que faz este programa?\n#include &lt;stdio.h&gt;\n\nint main(){\n    float r;\n    printf(\"Insira o raio do circulo[cm]:\");\n    scanf(\"%f\", &r);\n\n    printf(\"Perimetro do circulo: %f\", 2 * 3.1415 * r);\n    printf(\"Area do circulo: %f\", 3.1415 * r * r);\n    return 0;\n}\nNeste programa o valor 3.1415, o valor do π repete-se. \nSeria útil se pudéssemos fazer referência a este valor com um identificador em todo o programa. \n\nO C tem uma diretiva que nos permite fazer exatamente isso.\n#include &lt;stdio.h&gt;\n#define PI 3.1415\n\nint main(){\n    //...\n\n    printf(\"Perimetro do circulo: %f\", 2 * PI * r);\n    printf(\"Area do circulo: %f\", PI * r * r);\n    return 0;\n}\nA diretiva #define permite-nos definir constantes que, durante o pré-processamento, são substituidas pelo valor especificado. \n\nPor convenção, os nomes das constantes são sempre em letras maíusculas e os nomes das variáveis são em minúsculas."
  },
  {
    "objectID": "lectures/2_fundamentals.html#identificadores",
    "href": "lectures/2_fundamentals.html#identificadores",
    "title": "Fundamentos do C",
    "section": "Identificadores",
    "text": "Identificadores\nOs nomes que escolhemos para as nossas variáveis, funções, etc. designam-se por identificadores e existem regras que devem ser seguidas. \n\nExemplos de identificadores válidos\ntimes10 proximo_numero _altura alturaMAX\nExemplos de identificadores inválidos\n10times proximo-numero\nO caracter - é inválido, mas _ é aceite. \n\nOs identificadores são sensíveis a letras maísculas e minúsculas, e.g. alturaMAX e alturamax seriam 2 identificadores distintos num programa.\nExiste um conjunto de palavras-chave que não podem ser usadas. Estas correspondem a elementos intrínsecos ao C, como o nome dos tipos básicos e dos ciclos, e.g. int, while.\n\nOutros exemplos:\nint float double char void long short typedef\nif else switch default\nwhile do for continue break \nstruct enum union\n\n\n\n\n\n\nImportante\n\n\n\n\n\nO uso do nome de funções frequentemente usadas e pertencentes à biblioteca standard do C também é de evitar, e.g. printf, scanf, …"
  },
  {
    "objectID": "lectures/3_formated_io.revealjshtml#leitura-e-escrita-formatada",
    "href": "lectures/3_formated_io.revealjshtml#leitura-e-escrita-formatada",
    "title": "Programação",
    "section": "Leitura e escrita formatada",
    "text": "Leitura e escrita formatada\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt"
  },
  {
    "objectID": "lectures/3_formated_io.revealjshtml#exercício",
    "href": "lectures/3_formated_io.revealjshtml#exercício",
    "title": "Programação",
    "section": "Exercício",
    "text": "Exercício\nSoma de frações."
  },
  {
    "objectID": "lectures/3_formated_io.html#leitura-e-escrita-formatada",
    "href": "lectures/3_formated_io.html#leitura-e-escrita-formatada",
    "title": "Programação",
    "section": "Leitura e escrita formatada",
    "text": "Leitura e escrita formatada\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n\n\n\n\nI/O formatado\nO printf e scanf são 2 das funções mais usadas quando programamos em C.\nAmbas as funções permitem escrever/ler um número arbitrário de valores: \nprintf(\"string\", expr1, ..., exprN);\nscanf(\"string\", &var1, ..., &varN);\n\nint altura, idade;\nfloat massa, imc;\nprintf(\"Insira a idade e massa separadas por um espaco:\");\nscanf(\"%d %f\", &altura, &massa);\nprintf(\"altura: %d\\nmassa:%f\\n\", altura, massa);\n\n–\nscanf(\"%d %f\", &altura, &massa);\nprintf(\"altura: %d\\nmassa:%f\\n\", altura, massa);\nQuando usamos múltiplos descritores nestas funções, a correspondência com as variáveis/expressões é feita por ordem sequencial: - linha 1: o primeiro %d corresponde à variável altura, %f corresponde à massa - linha 2: idem\n\n–\nOs compiladores de C não são obrigados a verificar que o número de descritores é coerente com o número de valores fornecidos.\nprintf(\"%d %d %d\\n\", i); /*** ERRADO ***/\nprintf(\"%d\\n\", i, j, x, y, k); /*** ERRADO ***/\n–\nOs compiladores de C não são obrigados a verificar que o descritor % usado é o apropriado para o tipo da expressão/variável.\nint natural;\nfloat real;\nprintf(\"%f %d\\n\", natural, realj); /*** ERRADO ***/\n\n\n\nprintf\nOs descritores %d, %f, … também podem ser denominados por especificações de conversão.\n–\n\n\nNúmero de digitos\n%d escreve o número inteiro que recebe, mas podemos definir um número de ditigos mínimo.\nc [] // output no comentário após as linhas // • significa um espaço printf(\"%d\\n\", 42);    // -&gt; 42 printf(\"%5d\\n\", 42);   // -&gt; •••42 (3 espaços antes do 2) printf(\"%05d\\n\", 422); // -&gt; 00042 (3 zeros antes do 2) \n\na linha 2 especifica que o que é escrito deve ter pelo menos 5 caracteres, se não tiver, são adicionados espaços antes do número até os perfazer;\na linha 3 indica o mesmo, para são usados 0s para preencher.\n\n\n–\n\n\ncasas decimais\nPodemos fazer o mesmo com os números reais.\nc [] printf(\"%f\\n\", 3.14159);     // -&gt; 3.141590 printf(\"%.2f\\n\", 3.14159);   // -&gt; 3.14 (2 casas decimais) printf(\"%.f\\n\", 3.14159);    // -&gt; 3 (0 casas decimais, arredonda)                              //também podia ser %.0f\nc [] printf(\"%5.2f\\n\", 3.14159);  // -&gt; •3.14 (2 casas decimais,                              // pelo menos 5 characteres no total,                              // adiciona 1 espaço antes) printf(\"%05.2f\\n\", 3.14159); // -&gt; 03.14 (adiciona 0s) \n```c [] printf(“%-5.2f”, 3.14159); // -&gt; 3.14• (2 casas decimais, // pelo menos 5 characteres no total, // adiciona 1 espaço depois)\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\n### regra geral\n\nTemos a fórmula\n&lt;span style=\"color:Salmon\"&gt;`%m.pX`&lt;/span&gt; ou \n&lt;span style=\"color:Salmon\"&gt;`%-m.pX`&lt;/span&gt;, onde\n&lt;span style=\"color:Salmon\"&gt;`m`&lt;/span&gt; e \n&lt;span style=\"color:Salmon\"&gt;`p`&lt;/span&gt; são números naturais positivos, mas opcionais.\n&lt;span style=\"color:Salmon\"&gt;`X`&lt;/span&gt; é uma letra válida para conversão, e.g. `d` ou `f`.\n\n\n&lt;span style=\"color:Salmon\"&gt;`m`&lt;/span&gt;\n é o número de caracteres mínimo que devem ser escritos, sendo adicionados, à esquerda, espaços, ou zeros se designarmos\n &lt;span style=\"color:Salmon\"&gt;`0m`&lt;/span&gt;.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n\n&lt;span style=\"color:Salmon\"&gt;`p`&lt;/span&gt;\né o número de casas decimais a usar.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\nQuando temos\n&lt;span style=\"color:Salmon\"&gt;`-m`&lt;/span&gt;, adicionamos os espaços à direita do número.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\n`p` nem sempre faz sentido, pois depende da letra `X` escolhida.\n\n--\n\n### tabela de especificações de conversão\n\n| letras | descrição |\n| ------ | --------- | \n| d      | inteiros, `p` não faz sentido, `m` é o número mínimo de caracteres a serem escritos |\n| e      | reais em notação científica, `p` é o número de casas decimais\n| f      | reais em \"decimal fixo\", sem expoente, `p` tem o mesmo significado |\n\n--\n\n### símbolos especiais\n\n| Símbolo | descrição |\n| --- | ---- |\n| \\n  | nova linha |\n| \\t | tabulação |\n| `\\\\` | permite inserir um \\ |\n| \\a | causa um alerta sonoro na maior parte dos computadores |\n\n---\n\n## ``scanf``\n\n### Como funciona?\n\n--\n\nNa sua essência, o `scanf` faz correspondência de padrões.\nTenta fazer a correspondência entre grupos de *input* com especificações de conversão.\n\nPara cada especificação de conversão, o `scanf` tenta encontrar um item do tipo apropriado no *input* recebido, parando quando recebe um caracter incompatível com esse tipo.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\nSe algum item não for lido com sucesso, o ``scanf`` retorna sem tentar fazer a correspondência entre as restantes especificações de conversão com o resto do *input*.\n&lt;!-- .element: class=\"fragment\" --&gt;\n\n--\n\nAo procurar pelo início de um número, todos os espaços em branco são ignorados, e.g. espaços, novas linhas, tabulações, ...\n\n--\n\n```c\nint i, j;\nfloat x, y;\nscanf(\"%d%d%f%f\", &i, &j, &x, &y);\nprintf(\"i=%d, j=%d\\nx=%f, y=%f\\n\", i, j, x, y);\nEste programa irá ler os seguintes números de igual forma:\nbash [2] Introduza 2 inteiros e 2 reais: 1 2 3 4 5 i=1, j=2 x=3.000000, y=4.000000\nbash [2-4] Introduza 2 inteiros e 2 reais: 3     4 5 6 i=3, j=4 x=5.000000, y=6.000000\n–\nPorquê é que isto acontece?\nO scanf lê todo o input como uma sequência de caracteres. Os espaços, enters, tabulações, etc. são todos caracteres.\n3\n    4\n5 6\né equivalente a\n3¤••••4¤5•6¤\nonde ¤ é uma nova linha e • é um espaço.\n–\nO scanf pára de ler quando encontra um enter (nova linha) após a correspondência da última especificação de conversão.\n⚠️Importante⚠️ Contudo, o último enter não é consumido do input e por isso será o primeiro caracter a ser lido na próxima chamada do scanf.\n–\nRegras de correspondência para inteiros %d: - procura pelo primeiro digito ou sinal de + ou - - lê digitos até encontrar o primeiro caracter não digito\n–\nRegras de correspondência para reais %f %e: - procura pelo sinal de + ou - (opcional) - lê uma série de digitos, que podem conter 1 . a indicar que depois vêm casas decimais - um expoente (opcional): consiste na letra e ou E seguida de um sinal e mais digitos, e.g. 1e-3 (=0.001), 1E3 (=10000).\n–\nQuando o scanf lê um caracter que não encaixa na especificação de conversão que está a ser processada, é novamente colocado no input para ser processado\n–\nLer apenas N digitos\nint d1, d2;\nprintf(\"Numero inteiro:\");\nscanf(\"%1d%2d\", &d1, &d2);  // utilizador escreve 242\nprintf(\"d1=%d\\n\", d1); // d1=2\nprintf(\"d2=%d\\n\", d2); // d2=42\n%Nd permite ler N digitos inteiros."
  },
  {
    "objectID": "lectures/3_formated_io.html#exercício",
    "href": "lectures/3_formated_io.html#exercício",
    "title": "Programação",
    "section": "Exercício",
    "text": "Exercício\nSoma de frações."
  },
  {
    "objectID": "lectures/4_expressions.revealjshtml#expressões",
    "href": "lectures/4_expressions.revealjshtml#expressões",
    "title": "Programação",
    "section": "Expressões",
    "text": "Expressões\nDiogo Silva\nCAP / ENGEL\ndasilva@academiafa.edu.pt"
  },
  {
    "objectID": "lectures/4_expressions.html#expressões",
    "href": "lectures/4_expressions.html#expressões",
    "title": "Programação",
    "section": "Expressões",
    "text": "Expressões\n\nDiogo Silva\n\nCAP / ENGEL\ndasilva@academiafa.edu.pt\n\n\n\n\n\nO que são?\nExpressões devolvem sempre um valor concreto com um determinado tipo.\n    int raio = 2;\n    float area = 3.14 * raio * raio;\n\n\n\nOperações aritméticas\n1+2    // soma\n3.14-2 // subtração\n1*2.3  // multiplicação\n5/2    // divisão, devolve 2 -&gt; porquê?\n5%2    // resto da divisão\n\nint v = 2;\n-v     // torna valor negativo, operação unária\n–\nOperação unária? Operação que recebe apenas 1 operando.\nPor outro lado, as outras operações são binárias (2 operandos).\n–\n⚠️ Cuidado com a divisão! ⚠️\nO operador para a divisão, quando recebe 2 operandos inteiros, devolve sempre um valor inteiro (ignorando, sem arredondamento, a parte decimal)\n5/2 // devolve 2\nQuando misturamos um inteiro com um real, o inteiro é automaticamente convertido e o resultado será o valor preciso\n5.0/2 // devolve 2.5\n–\nO resto da divisão % requer 2 operandos inteiros.\nUsar 0 como o segundo operando da divisão / ou resto da divisão %, i.e. divisão por 0, gera comportamento não definido.\n\n\n\nPrecedência e associatividade\n\n1+2*-2\nÉ o tipo de expressão que não devem escrever. Devem usar () para melhorar legibilidade.\nMas se vissem esta expressão, qual seria o resultado? \n–\nAs operações no C têm uma precedência.\n\n\n\nPrecedência\nOperadores\n\n\n\n\nAlta\n+ - unários (e.g. -2)\n\n\n---\n* / %\n\n\nBaixa\n+ -\n\n\n\n1 + 2 * -2 == 1 + (2 * (-2))\n–\ni + j * k == i + (j * k)\n-i * -j == (-i) * (-j)\n–\nE quando uma expressão tem 2 operações com a mesma precedência?\ni - j + k\ni / j * k\n–\nTem-se em conta a associatividade.\ni - j + k == (i - j) + k\ni / j * k == (i / j) * k\n+ - * / % têm associtividade à esquerda, o que quer dizer que agrupam o que está antes do operador.\nOs operadores unários têm associatividade à direita.\n- -2 == - (-2)\n\n\n\nOperadores de atribuição\n\nJá conhecemos o operador de atribuição simples =.\nÉ o que designamos por uma operação com efeitos secundários, porque altera o estado dos operandos. \n–\na = 2 altera o estado da variável a porque o seu valor é agora 2.\nAdicionalmente, a = 2 é uma expressão válida que devolve o valor que foi atribuido à variável \nint a=10;\nprintf(\"a=%d\\n\", a=2); // escreve 2 na consola e altera o valor de a\n\n–\nTodas as operações de atribuição exigem que o operando da esquerda seja uma variável.\n–\nExistem outros que se combinam com operações aritméticas.\n\n\n\n\n\n\n\nExpressão\nDescrição\n\n\n\n\nvar+=3\nsoma 3 ao valor de var e atribui o resultado a var\n\n\nvar-=3\nsubtrai 3 ao valor de var e atribui o resultado a var\n\n\nvar/=3\nmultiplica 3 com o valor de var e atribui o resultado a var\n\n\nvar/=3\ndivide o valor de var por 3 e atribui o resultado a var\n\n\nvar%=3\nfaz o resto da divisão entre var e 3 e atribui o resultado a var\n\n\n\n–\nv*=3 não é equivalente a v = v * 3, embora na maior parte das utilizações o resultado seja o mesmo.\nPorquê? Observem a expressão v*=3+10\nNão é equivalente a v = v * 3 + 10. Esta expressão, deviso às regras de precedência a associatividade iria dar um resultado diferente.\nint a=3;\nprintf(\"a=%d\\n\", (a = a * 3 + 10)); // a=19\na=3;\nprintf(\"a=%d\\n\", a*=3+10); // a=39\n–\nNão confundir += com =+.\nA primeira operação acumula o valor à direita.\nA segunda atribui o valor que a variável já tem.\n–\nPosto isto, usem sempre ( ) para deixar claro qual é a ordem das operações.\n\n\n\nIncremento e decremento\n\nExiste uma instrução que é frequentemente usada no C (irão perceber porquê quando abordarmos ciclos):\ni = i + 1;\ni += 1;\n–\nExiste outra forma de escrever esta instrução, com o operador de incremento ++\ni = i + 1;\ni += 1;\ni++;\n–\nEste operador pode ser usado tanto antes de uma variável (pré-incremento) como depois (pós-incremneto).\nQual será a diferença?\nint i=10;\nprintf(\"%d\\n\", ++i); // ?\nprintf(\"%d\\n\", i);   // ?\ni=10;\nprintf(\"%d\\n\", i++); // ?\nprintf(\"%d\\n\", i);   // ?\n–\nint i=10;\nprintf(\"%d\\n\", ++i); // 11\nprintf(\"%d\\n\", i);   // 11\ni=10;\nprintf(\"%d\\n\", i++); // 10\nprintf(\"%d\\n\", i);   // 11\n–\nAlém do incremento ++, também temos disponível o decremento --, que funciona da mesma forma, mas subtrai em uma unidade.\n\n\n\nAvaliação de expressões\n\nResumo das operações que já vimos:\n\npostfix == pós-incremento\nprefix == pré-incremento\n–\nCom este conhecimento conseguimos avaliar expressões complicadas.\na= b += c++ - d + --e / -f\n\nEncontrar o operador com maior precedência.\nColocar ( ) à volta do operador e operandos.\n\nAplicar regras de precedência e associatividade.\n\nRepetir.\n\n–\na= b += c++ - d + --e / -f\nc++ e depois –e (precedência) \na= b += (c++) - d + (--e) / -f \noperador unário -f (precedência) \na= b += (c++) - d + (--e) / (-f) \ndivisão (precedência) \na= b += (c++) - d + ((--e) / (-f)) \n–\na= b += (c++) - d + ((--e) / (-f))\n- e + com a mesma precedência e com operando em comum d (precedência) \nagrupam da esquerda para a direita, logo - primeiro (associatividade) \na= b += ((c++) - d) + ((--e) / (-f)) \ne depois o + (precedência) \na= b += (((c++) - d) + ((--e) / (-f))) \n= e += com mesma precedência (precedência) \nagrupam da direita para a esquerda, logo += primeiro (associatividade) \na= (b += (((c++) - d) + ((--e) / (-f)))) \nsobra apenas o = (precedência) \n(a= (b += (((c++) - d) + ((--e) / (-f)))))"
  }
]